// Generated by CoffeeScript 1.9.2

/*! Oo3d 0.0.47 //// MIT Licence //// http://oo3d.richplastow.com/ */

(function() {
  var Item, Layer, Main, Nwang, Program, Renderer, Tudor, mat4, pick, tudor, uri, ª, ªA, ªB, ªC, ªE, ªF, ªMAX, ªMIN, ªN, ªO, ªR, ªS, ªU, ªV, ªW, ªX, ªex, ªhas, ªisU, ªredefine, ªtype, ªuid,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  ªC = 'Oo3d';

  ªV = '0.0.47';

  ªA = 'array';

  ªB = 'boolean';

  ªE = 'error';

  ªF = 'function';

  ªN = 'number';

  ªO = 'object';

  ªR = 'regexp';

  ªS = 'string';

  ªU = 'undefined';

  ªX = 'null';

  ªMAX = 9007199254740991;

  ªMIN = -9007199254740991;

  ªW = this;

  ª = console.log.bind(console);

  ªex = function(x, a, b) {
    var pos;
    if (-1 === (pos = a.indexOf(x))) {
      return x;
    } else {
      return b.charAt(pos);
    }
  };

  ªhas = function(h, n, t, f) {
    if (t == null) {
      t = true;
    }
    if (f == null) {
      f = false;
    }
    if (-1 !== h.indexOf(n)) {
      return t;
    } else {
      return f;
    }
  };

  ªtype = function(x) {
    return {}.toString.call(x).match(/\s([a-z0-9]+)/i)[1].toLowerCase();
  };

  ªisU = function(x) {
    return ªU === typeof x;
  };

  ªuid = function(p) {
    return p + '_' + (Math.random() + '1111111111111111').slice(2, 18);
  };

  ªredefine = function(obj, name, value, kind) {
    switch (kind) {
      case 'constant':
        return Object.defineProperty(obj, name, {
          value: value,
          enumerable: true
        });
      case 'private':
        return Object.defineProperty(obj, name, {
          value: value,
          enumerable: false
        });
    }
  };

  Layer = (function() {
    Layer.prototype.C = 'Layer';

    Layer.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function Layer(main1, config) {
      var float, i, j, len, ref;
      this.main = main1;
      if (config == null) {
        config = {};
      }
      if (ªO !== ªtype(config)) {
        throw TypeError("`config` must be object not " + (ªtype(config)));
      }
      if (ªO !== ªtype(this.main)) {
        throw TypeError("`main` must be object not " + (ªtype(this.main)));
      }
      if ('[object Oo3d]' !== '' + this.main) {
        throw TypeError("`main` must be [object Oo3d] not " + this.main);
      }
      if (!config.rendererIs) {
        this.renderers = [];
      } else if ('uint16array' !== ªtype(config.rendererIs)) {
        throw TypeError("If set, config.rendererIs must be Uint16Array not " + (ªtype(config.rendererIs)));
      } else {
        this.renderers = (function() {
          var j, len, ref, results;
          ref = config.rendererIs;
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            i = ref[j];
            results.push(this.main.renderers[i] || (function() {
              throw RangeError("No such index " + i + " in main.renderers");
            })());
          }
          return results;
        }).call(this);
      }
      this.scissor = config.scissor;
      if (!this.scissor) {
        this.scissor = null;
      } else if ('float32array' !== ªtype(this.scissor)) {
        throw TypeError("If set, config.scissor must be Float32Array not " + (ªtype(this.scissor)));
      } else if (4 !== this.scissor.length) {
        throw RangeError("If set, config.scissor.length must be 4 not " + this.scissor.length);
      } else {
        ref = this.scissor;
        for (j = 0, len = ref.length; j < len; j++) {
          float = ref[j];
          if (0 > float || 1 < float) {
            throw RangeError("config.scissor contains out-of-range " + float);
          }
        }
      }
    }

    Layer.prototype.render = function() {
      var j, len, ref, renderer, results;
      if (this.scissor) {
        this.main.gl.scissor(this.scissor[0] * this.main.$main.width, this.scissor[1] * this.main.$main.height, this.scissor[2] * this.main.$main.width, this.scissor[3] * this.main.$main.height);
      }
      ref = this.renderers;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        renderer = ref[j];
        results.push(renderer.render());
      }
      return results;
    };

    return Layer;

  })();

  Main = (function() {
    Main.prototype.C = "/src/class-main.litcoffee:" + ªC;

    Main.prototype.toString = function() {
      return "[object " + ªC + "]";
    };

    function Main(config) {
      var M, k, v;
      if (config == null) {
        config = {};
      }
      M = this.C + ":constructor()\n  ";
      if (ªO !== ªtype(config)) {
        throw TypeError(M + "Optional `config` is " + (ªtype(config)) + " not object");
      }
      for (k in config) {
        v = config[k];
        this[k] = v;
      }
      if (!Nwang) {
        throw Error(M + "Dependency 'Nwang' could not be found");
      }
      this.nwang = new Nwang;
      this.$main = config.$main || null;
      if (this.$main && '[object HTMLCanvasElement]' !== '' + this.$main) {
        throw TypeError(M + "Optional `config.$main` is " + (ªtype(this.$main)) + " not HTMLCanvasElement");
      }
      if (!config.bkgnd) {
        this.bkgndR = this.bkgndG = this.bkgndB = 0.25;
        this.bkgndA = 1;
      } else if ('float32array' === ªtype(config.bkgnd)) {
        if (4 !== config.bkgnd.length) {
          throw Error(M + "If set `config.bkgnd` must contain four elements");
        }
        this.bkgndR = config.bkgnd[0] || 0;
        this.bkgndG = config.bkgnd[1] || 0;
        this.bkgndB = config.bkgnd[2] || 0;
        this.bkgndA = config.bkgnd[3] || 0;
        if (0 > this.bkgndR || this.bkgndR > 1) {
          throw RangeError(M + "`config.bkgnd[0]` (red) is not within range 0-1");
        }
        if (0 > this.bkgndG || this.bkgndG > 1) {
          throw RangeError(M + "`config.bkgnd[1]` (green) is not within range 0-1");
        }
        if (0 > this.bkgndB || this.bkgndB > 1) {
          throw RangeError(M + "`config.bkgnd[2]` (blue) is not within range 0-1");
        }
        if (0 > this.bkgndA || this.bkgndA > 1) {
          throw RangeError(M + "`config.bkgnd[3]` (alpha) is not within range 0-1");
        }
      } else {
        throw TypeError(M + "Optional `config.bkgnd` is " + (ªtype(config.bkgnd)) + " not float32array");
      }
      this.gl = null;
      this.cameras = [];
      this.programs = [];
      this.renderers = [];
      this.layers = [];
      this.meshes = [];
      this.positionBuffers = [];
      this.colorBuffers = [];
      if (this.$main) {
        this.initGL();
        if (this.gl) {
          this.initCanvas();
          this.initBuffers();
        }
      }
    }

    Main.prototype.initGL = function() {
      var M, ctx, j, len, ref;
      M = this.C + ":initGL()\n  ";
      try {
        ref = ['webgl', 'experimental-webgl'];
        for (j = 0, len = ref.length; j < len; j++) {
          ctx = ref[j];
          this.gl = this.$main.getContext(ctx, {
            preserveDrawingBuffer: true
          });
          if (this.gl) {
            break;
          }
        }
      } catch (_error) {

      }
      if (!this.gl) {
        throw Error(M + "Unable to initialize WebGL. Your browser may not support it.");
      }
    };

    Main.prototype.initCanvas = function() {
      this.gl.clearColor(this.bkgndR, this.bkgndG, this.bkgndB, this.bkgndA);
      this.gl.enable(this.gl.DEPTH_TEST);
      this.gl.enable(this.gl.SCISSOR_TEST);
      this.gl.depthFunc(this.gl.LEQUAL);
      this.gl.scissor(0, 0, this.$main.width, this.$main.height);
      this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
      return this.gl.enable(this.gl.VERTEX_PROGRAM_POINT_SIZE);
    };

    Main.prototype.initBuffers = function() {
      this.addPositionBuffer([]);
      return this.addColorBuffer([]);
    };

    Main.prototype.cleanUp = function() {};

    Main.prototype.addMesh = function(config) {
      var index;
      index = this.meshes.length;
      this.meshes[index] = new Item.Mesh(this, index, config);
      return index;
    };

    Main.prototype.addCamera = function(config) {
      var index;
      index = this.cameras.length;
      this.cameras[index] = new Item.Camera(this, index, config);
      return index;
    };

    Main.prototype.addProgram = function(config) {
      var index;
      if (ªO !== ªtype(config)) {
        throw TypeError("`config` must be object not " + (ªtype(config)));
      }
      if (ªS !== ªtype(config.subclass)) {
        throw TypeError("`config.subclass` must be string not " + (ªtype(config.subclass)));
      }
      if (!Program[config.subclass]) {
        throw RangeError("`Program." + config.subclass + "` does not exist");
      }
      index = this.programs.length;
      this.programs[index] = new Program[config.subclass](this, config);
      return index;
    };

    Main.prototype.addRenderer = function(config) {
      var index;
      index = this.renderers.length;
      this.renderers[index] = new Renderer(this, config);
      return index;
    };

    Main.prototype.addLayer = function(config) {
      var index;
      index = this.layers.length;
      this.layers[index] = new Layer(this, config);
      return index;
    };

    Main.prototype.addPositionBuffer = function(positions) {
      var index;
      index = this.positionBuffers.length;
      if (ªA !== ªtype(positions)) {
        throw Error("`positions` must be an array not " + (ªtype(positions)));
      } else if (positions.length % 3) {
        throw Error("`positions.length` must be divisible by 3");
      }
      this.positionBuffers[index] = this.gl.createBuffer();
      this.positionBuffers[index].count = positions.length / 3;
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffers[index]);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(positions), this.gl.STATIC_DRAW);
      return index;
    };

    Main.prototype.addColorBuffer = function(colors) {
      var index;
      index = this.colorBuffers.length;
      if (ªA !== ªtype(colors)) {
        throw Error("`colors` must be an array not " + (ªtype(colors)));
      } else if (colors.length % 4) {
        throw Error("`colors.length` must be divisible by 4");
      }
      this.colorBuffers[index] = this.gl.createBuffer();
      this.colorBuffers[index].count = colors.length / 4;
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffers[index]);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(colors), this.gl.STATIC_DRAW);
      return index;
    };

    Main.prototype.rotate = function(x, y, z, targetIndex) {
      var c, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, mat, s, target, x0, y0, z0;
      target = this.meshes[targetIndex] || this.cameras[0];
      mat = target.matTransform;
      x0 = 0 === x;
      y0 = 0 === y;
      z0 = 0 === z;
      if (x0 && y0 && z0) {
        return this;
      } else if (y0 && z0) {
        s = Math.sin(x);
        c = Math.cos(x);
        m10 = mat[4];
        m11 = mat[5];
        m12 = mat[6];
        m13 = mat[7];
        m20 = mat[8];
        m21 = mat[9];
        m22 = mat[10];
        m23 = mat[11];
        mat[4] = m10 * c + m20 * s;
        mat[5] = m11 * c + m21 * s;
        mat[6] = m12 * c + m22 * s;
        mat[7] = m13 * c + m23 * s;
        mat[8] = m20 * c - m10 * s;
        mat[9] = m21 * c - m11 * s;
        mat[10] = m22 * c - m12 * s;
        mat[11] = m23 * c - m13 * s;
        target.rX += x;
      } else if (x0 && z0) {
        s = Math.sin(y);
        c = Math.cos(y);
        m00 = mat[0];
        m01 = mat[1];
        m02 = mat[2];
        m03 = mat[3];
        m20 = mat[8];
        m21 = mat[9];
        m22 = mat[10];
        m23 = mat[11];
        mat[0] = m00 * c - m20 * s;
        mat[1] = m01 * c - m21 * s;
        mat[2] = m02 * c - m22 * s;
        mat[3] = m03 * c - m23 * s;
        mat[8] = m00 * s + m20 * c;
        mat[9] = m01 * s + m21 * c;
        mat[10] = m02 * s + m22 * c;
        mat[11] = m03 * s + m23 * c;
        target.rY += y;
      } else if (x0 && y0) {
        s = Math.sin(z);
        c = Math.cos(z);
        m00 = mat[0];
        m01 = mat[1];
        m02 = mat[2];
        m03 = mat[3];
        m10 = mat[4];
        m11 = mat[5];
        m12 = mat[6];
        m13 = mat[7];
        mat[0] = m00 * c + m10 * s;
        mat[1] = m01 * c + m11 * s;
        mat[2] = m02 * c + m12 * s;
        mat[3] = m03 * c + m13 * s;
        mat[4] = m10 * c - m00 * s;
        mat[5] = m11 * c - m01 * s;
        mat[6] = m12 * c - m02 * s;
        mat[7] = m13 * c - m03 * s;
        target.rZ += z;
      } else {
        this.rotate(x, 0, 0, targetIndex);
        this.rotate(0, y, 0, targetIndex);
        this.rotate(0, 0, z, targetIndex);
      }
      if (target === this.cameras[0]) {
        this.cameras[0].updateCamera();
      }
      return this;
    };

    Main.prototype.scale = function(x, y, z, targetIndex) {
      var mat, target, x1, y1, z1;
      target = this.meshes[targetIndex] || this.cameras[0];
      mat = target.matTransform;
      x1 = 1 === x;
      y1 = 1 === y;
      z1 = 1 === z;
      if (!x1) {
        mat[0] *= x;
        mat[1] *= x;
        mat[2] *= x;
        mat[3] *= x;
        target.sX *= x;
      }
      if (!y1) {
        mat[4] *= y;
        mat[5] *= y;
        mat[6] *= y;
        mat[7] *= y;
        target.sY *= y;
      }
      if (!z1) {
        mat[8] *= z;
        mat[9] *= z;
        mat[10] *= z;
        mat[11] *= z;
        target.sZ *= z;
      }
      if (target === this.cameras[0]) {
        this.cameras[0].updateCamera();
      }
      return this;
    };

    Main.prototype.translate = function(x, y, z, targetIndex) {
      var mat, target, x0, y0, z0;
      target = this.meshes[targetIndex] || this.cameras[0];
      mat = target.matTransform;
      x0 = 0 === x;
      y0 = 0 === y;
      z0 = 0 === z;
      if (x0 && y0 && z0) {
        return this;
      } else if (y0 && z0) {
        mat[12] += mat[0] * x;
        mat[13] += mat[1] * x;
        mat[14] += mat[2] * x;
        mat[15] += mat[3] * x;
        target.tX += x;
      } else if (x0 && z0) {
        mat[12] += mat[4] * y;
        mat[13] += mat[5] * y;
        mat[14] += mat[6] * y;
        mat[15] += mat[7] * y;
        target.tY += y;
      } else if (x0 && y0) {
        mat[12] += mat[8] * z;
        mat[13] += mat[9] * z;
        mat[14] += mat[10] * z;
        mat[15] += mat[11] * z;
        target.tZ += z;
      } else {
        mat[12] += mat[0] * x + mat[4] * y + mat[8] * z;
        mat[13] += mat[1] * x + mat[5] * y + mat[9] * z;
        mat[14] += mat[2] * x + mat[6] * y + mat[10] * z;
        mat[15] += mat[3] * x + mat[7] * y + mat[11] * z;
        target.tX += x;
        target.tY += y;
        target.tZ += z;
      }
      if (target === this.cameras[0]) {
        this.cameras[0].updateCamera();
      }
      return this;
    };

    Main.prototype.resetTransform = function(targetIndex) {
      var mat, target;
      target = this.meshes[targetIndex] || this.cameras[0];
      mat = target.matTransform;
      target.rX = target.rY = target.rZ = 0;
      target.sX = target.sY = target.sZ = 1;
      target.tX = target.tY = target.tZ = 0;
      target.matTransform = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
      if (target === this.cameras[0]) {
        this.cameras[0].tZ = -4;
        this.cameras[0].matTransform[14] = -4;
        this.cameras[0].updateCamera();
      }
      return this;
    };

    Main.prototype.setRenderMode = function(renderMode, targetIndex) {
      if (!this.meshes[targetIndex]) {
        return;
      }
      this.meshes[targetIndex].renderMode = renderMode;
      return this;
    };

    Main.prototype.getColorAt = function(x, y) {
      var pixels;
      pixels = new Uint8Array(4);
      this.gl.readPixels(x, y, 1, 1, this.gl.RGBA, this.gl.UNSIGNED_BYTE, pixels);
      return pixels;
    };

    Main.prototype.getMeshIByColor = function(color) {
      return pick.colorToIndex(color);
    };

    Main.prototype.getCameraSnapshot = function(cameraI) {
      var camera, mat;
      camera = this.cameras[cameraI];
      mat = new Float32Array(16);
      mat.set(camera.matTransform);
      return {
        mat: mat,
        rX: camera.rX,
        rY: camera.rY,
        rZ: camera.rZ,
        sX: camera.sX,
        sY: camera.sY,
        sZ: camera.sZ,
        tX: camera.tX,
        tY: camera.tY,
        tZ: camera.tZ
      };
    };

    Main.prototype.getMeshSnapshot = function(meshI) {
      var item, mat;
      item = this.meshes[meshI];
      mat = new Float32Array(16);
      mat.set(item.matTransform);
      return {
        mat: mat,
        rX: item.rX,
        rY: item.rY,
        rZ: item.rZ,
        sX: item.sX,
        sY: item.sY,
        sZ: item.sZ,
        tX: item.tX,
        tY: item.tY,
        tZ: item.tZ
      };
    };

    Main.prototype.setCameraSnapshot = function(snapshot, cameraI) {
      var camera;
      camera = this.cameras[cameraI];
      camera.matTransform = new Float32Array(16);
      camera.matTransform.set(snapshot.mat);
      camera.rX = snapshot.rX;
      camera.rY = snapshot.rY;
      camera.rZ = snapshot.rZ;
      camera.sX = snapshot.sX;
      camera.sY = snapshot.sY;
      camera.sZ = snapshot.sZ;
      camera.tX = snapshot.tX;
      camera.tY = snapshot.tY;
      camera.tZ = snapshot.tZ;
      return this;
    };

    Main.prototype.setMeshSnapshot = function(snapshot, meshI) {
      var item;
      item = this.meshes[meshI];
      item.matTransform = new Float32Array(16);
      item.matTransform.set(snapshot.mat);
      item.rX = snapshot.rX;
      item.rY = snapshot.rY;
      item.rZ = snapshot.rZ;
      item.sX = snapshot.sX;
      item.sY = snapshot.sY;
      item.sZ = snapshot.sZ;
      item.tX = snapshot.tX;
      item.tY = snapshot.tY;
      item.tZ = snapshot.tZ;
      return this;
    };

    Main.prototype.render = function() {
      var j, layer, len, ref;
      if (!this.gl) {
        throw Error("The WebGL rendering context is " + (ªtype(this.gl)));
      }
      this.gl.clearColor(this.bkgndR, this.bkgndG, this.bkgndB, this.bkgndA);
      this.gl.scissor(0, 0, this.$main.width, this.$main.height);
      this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
      ref = this.layers;
      for (j = 0, len = ref.length; j < len; j++) {
        layer = ref[j];
        layer.render();
      }
      return this;
    };

    return Main;

  })();

  if (ªF === typeof define && define.amd) {
    define(function() {
      return Main;
    });
  } else if (ªO === typeof module && module && module.exports) {
    module.exports = Main;
  } else {
    ªW[ªC] = Main;
  }

  if (ªF === typeof define && define.amd) {

  } else if (ªO === typeof module && module && module.exports) {
    Nwang = require('nwang');
  } else {
    Nwang = window.Nwang;
  }

  mat4 = {};

  mat4.multiply = function(a, b) {
    var a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23, a30, a31, a32, a33, b0, b1, b2, b3, out;
    out = new Float32Array(16);
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    a30 = a[12];
    a31 = a[13];
    a32 = a[14];
    a33 = a[15];
    b0 = b[0];
    b1 = b[1];
    b2 = b[2];
    b3 = b[3];
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return out;
  };

  mat4.perspective = function(fovy, aspect, near, far) {
    var f, nf, out;
    f = 1.0 / Math.tan(fovy / 2);
    nf = 1 / (near - far);
    out = new Float32Array(16);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (2 * far * near) * nf;
    out[15] = 0;
    return out;
  };

  mat4.rotateX = function(a, rad) {
    var a10, a11, a12, a13, a20, a21, a22, a23, c, s;
    s = Math.sin(rad);
    c = Math.cos(rad);
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    a[4] = a10 * c + a20 * s;
    a[5] = a11 * c + a21 * s;
    a[6] = a12 * c + a22 * s;
    a[7] = a13 * c + a23 * s;
    a[8] = a20 * c - a10 * s;
    a[9] = a21 * c - a11 * s;
    a[10] = a22 * c - a12 * s;
    a[11] = a23 * c - a13 * s;
    return a;
  };

  mat4.rotateY = function(a, rad) {
    var a00, a01, a02, a03, a20, a21, a22, a23, c, s;
    s = Math.sin(rad);
    c = Math.cos(rad);
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    a[0] = a00 * c - a20 * s;
    a[1] = a01 * c - a21 * s;
    a[2] = a02 * c - a22 * s;
    a[3] = a03 * c - a23 * s;
    a[8] = a00 * s + a20 * c;
    a[9] = a01 * s + a21 * c;
    a[10] = a02 * s + a22 * c;
    a[11] = a03 * s + a23 * c;
    return a;
  };

  mat4.rotateZ = function(a, rad) {
    var a00, a01, a02, a03, a10, a11, a12, a13, c, s;
    s = Math.sin(rad);
    c = Math.cos(rad);
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a[0] = a00 * c + a10 * s;
    a[1] = a01 * c + a11 * s;
    a[2] = a02 * c + a12 * s;
    a[3] = a03 * c + a13 * s;
    a[4] = a10 * c - a00 * s;
    a[5] = a11 * c - a01 * s;
    a[6] = a12 * c - a02 * s;
    a[7] = a13 * c - a03 * s;
    return a;
  };

  mat4.translate = function(a, x, y, z) {
    a[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    a[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    a[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    a[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    return a;
  };

  mat4.ortho = function(left, right, bottom, top, near, far) {
    var bt, lr, nf, out;
    lr = 1 / (left - right);
    bt = 1 / (bottom - top);
    nf = 1 / (near - far);
    out = new Float32Array(16);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
  };

  mat4.makeTranslation = function(tx, ty, tz) {
    return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, tz, 1]);
  };

  mat4.makeXRotation = function(angleInRadians) {
    var c, s;
    c = Math.cos(angleInRadians);
    s = Math.sin(angleInRadians);
    return new Float32Array([1, 0, 0, 0, 0, c, s, 0, 0, -s, c, 0, 0, 0, 0, 1]);
  };

  mat4.makeYRotation = function(angleInRadians) {
    var c, s;
    c = Math.cos(angleInRadians);
    s = Math.sin(angleInRadians);
    return new Float32Array([c, 0, -s, 0, 0, 1, 0, 0, s, 0, c, 0, 0, 0, 0, 1]);
  };

  mat4.makeZRotation = function(angleInRadians) {
    var c, s;
    c = Math.cos(angleInRadians);
    s = Math.sin(angleInRadians);
    return new Float32Array([c, s, 0, 0, -s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
  };

  mat4.makeScale = function(sx, sy, sz) {
    return new Float32Array([sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1]);
  };

  mat4.makeProjection = function(width, height, depth) {
    return new Float32Array([2 / width, 0, 0, 0, 0, -2 / height, 0, 0, 0, 0, 2 / depth, 0, -1, 1, 0, 1]);
  };

  pick = {};

  pick.indexToColor = function(index) {
    var b, g, i, r;
    i = ('00000000000000000000000' + index.toString(2)).slice(-24).split('');
    r = "" + i[23] + i[20] + i[17] + i[14] + i[11] + i[8] + i[5] + i[2];
    g = "" + i[22] + i[19] + i[16] + i[13] + i[10] + i[7] + i[4] + i[1];
    b = "" + i[21] + i[18] + i[15] + i[12] + i[9] + i[6] + i[3] + i[0];
    return new Float32Array([parseInt(r, 2) / 255, parseInt(g, 2) / 255, parseInt(b, 2) / 255, 1.0]);
  };

  pick.colorToIndex = function(color) {
    var b, g, i, r;
    if (0 === (0x1f & color[0]) + (0x1f & color[1]) + (0x1f & color[2])) {
      return pick.qikColorToIndex(color);
    }
    r = ('0000000' + color[0].toString(2)).slice(-8).split('');
    g = ('0000000' + color[1].toString(2)).slice(-8).split('');
    b = ('0000000' + color[2].toString(2)).slice(-8).split('');
    i = ("" + b[7] + g[7] + r[7]) + ("" + b[6] + g[6] + r[6]) + ("" + b[5] + g[5] + r[5]) + ("" + b[4] + g[4] + r[4]) + ("" + b[3] + g[3] + r[3]) + ("" + b[2] + g[2] + r[2]) + ("" + b[1] + g[1] + r[1]) + ("" + b[0] + g[0] + r[0]);
    return parseInt(i, 2);
  };

  pick.qikColorToIndex = function(color) {
    var b, g, i, r;
    r = (color[0].toString(2)).split('');
    g = (color[1].toString(2)).split('');
    b = (color[2].toString(2)).split('');
    i = ("" + (b[2] || 0) + (g[2] || 0) + (r[2] || 0)) + ("" + (b[1] || 0) + (g[1] || 0) + (r[1] || 0)) + ("" + b[0] + g[0] + r[0]);
    return parseInt(i, 2);
  };

  uri = {};

  uri.r2Tenmin = function(r) {
    return Math.round(r * uri.RESOLUTION_R);
  };

  uri.tenmin2r = function(r) {
    return r / uri.RESOLUTION_R;
  };

  uri.r2uri = function(radians) {
    var PI2, c1, c1i, c2, c2i, tenmin;
    PI2 = Math.PI * 2;
    radians = radians % PI2;
    if (0 > radians) {
      radians += PI2;
    }
    tenmin = uri.r2Tenmin(radians);
    c1 = uri.USUAL_R2URI[tenmin];
    if (c1) {
      return c1;
    }
    c1i = tenmin % 36;
    c2i = (tenmin - c1i) / 36;
    c1 = "0123456789abcdefghijklmnopqrstuvwxyz"[c1i];
    c2 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWX"[c2i];
    return '' + c1 + c2;
  };

  uri.s2uri = function(s) {
    var c1, c2, c3, m, n, nM64, neg;
    if (0 > s) {
      neg = true;
      s = Math.abs(s);
    }
    if (0.0001 > s) {
      return 'A';
    }
    if (0.001 > s) {
      m = neg ? 'a' : 'p';
      n = s * 10000000;
    } else if (0.01 > s) {
      m = neg ? 'b' : 'o';
      n = s * 1000000;
    } else if (0.1 > s) {
      m = neg ? 'c' : 'n';
      n = s * 100000;
    } else if (1 > s) {
      m = neg ? 'd' : 'm';
      n = s * 10000;
    } else if (10 > s) {
      m = neg ? 'e' : 'l';
      n = s * 1000;
    } else if (100 > s) {
      m = neg ? 'f' : 'k';
      n = s * 100;
    } else if (1000 > s) {
      m = neg ? 'g' : 'j';
      n = s * 10;
    } else if (10000 > s) {
      m = neg ? 'h' : 'i';
      n = s;
    } else {
      return 'Z';
    }
    n = n / 4;
    n = Math.floor(n);
    c1 = uri.USUAL_S2URI[m + n];
    if (c1) {
      return c1;
    }
    nM64 = n % 64;
    c1 = m;
    c2 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-"[nM64];
    c3 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-"[(n - nM64) / 64];
    if (ªU === typeof c1 || ªU === typeof c2 || ªU === typeof c3) {
      ª('UNDEFINED RESULT s2uri(' + s + ')', n, nM64, (n - nM64) / 64, '' + c1 + c2 + c3);
    }
    return c1 + c2 + c3;
  };

  uri.t2uri = function(t) {
    var c1, c2, c3, m, n, nM64, neg;
    if (0 > t) {
      neg = true;
      t = Math.abs(t);
    }
    if (0.0001 > t) {
      return 'A';
    }
    if (0.001 > t) {
      m = neg ? 'a' : 'p';
      n = t * 10000000;
    } else if (0.01 > t) {
      m = neg ? 'b' : 'o';
      n = t * 1000000;
    } else if (0.1 > t) {
      m = neg ? 'c' : 'n';
      n = t * 100000;
    } else if (1 > t) {
      m = neg ? 'd' : 'm';
      n = t * 10000;
    } else if (10 > t) {
      m = neg ? 'e' : 'l';
      n = t * 1000;
    } else if (100 > t) {
      m = neg ? 'f' : 'k';
      n = t * 100;
    } else if (1000 > t) {
      m = neg ? 'g' : 'j';
      n = t * 10;
    } else if (10000 > t) {
      m = neg ? 'h' : 'i';
      n = t;
    } else {
      return 'Z';
    }
    n = n / 4;
    n = Math.floor(n);
    c1 = uri.USUAL_T2URI[m + n];
    if (c1) {
      return c1;
    }
    nM64 = n % 64;
    c1 = m;
    c2 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-"[nM64];
    c3 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-"[(n - nM64) / 64];
    if (ªU === typeof c1 || ªU === typeof c2 || ªU === typeof c3) {
      ª('UNDEFINED RESULT t2uri(' + t + ')', n, nM64, (n - nM64) / 64, '' + c1 + c2 + c3);
    }
    return c1 + c2 + c3;
  };

  uri.uri2r = function(str) {
    var c1, c2, usual;
    usual = uri.USUAL_URI2R[str];
    if (ªN === typeof usual) {
      return uri.tenmin2r(usual);
    }
    c1 = uri.B64DECODE[str[0]];
    c2 = uri.B64DECODE[str[1]];
    return uri.tenmin2r(c1 * 60 + c2);
  };

  uri.uri2s = function(str) {
    var c1, c2, c3, usual;
    usual = uri.USUAL_URI2S[str];
    if (ªN === typeof usual) {
      return usual;
    }
    c1 = uri.MULTIPLIER[str[0]];
    c2 = uri.B64DECODE[str[1]];
    c3 = uri.B64DECODE[str[2]];
    return c1 * (c2 + c3 * 64 * 4);
  };

  uri.uri2t = function(str) {
    var c1, c2, c3, usual;
    usual = uri.USUAL_URI2T[str];
    if (ªN === typeof usual) {
      return usual;
    }
    c1 = uri.MULTIPLIER[str[0]];
    c2 = uri.B64DECODE[str[1]];
    c3 = uri.B64DECODE[str[2]];
    return c1 * (c2 + c3 * 64 * 4);
  };

  uri.RESOLUTION_R = 1 / (Math.PI * 2 / 36 / 60);

  uri.USUAL_R2URI = (function() {
    var PI, out;
    PI = Math.PI;
    out = {};
    out[0] = 'A';
    out[uri.r2Tenmin(PI / 6.0)] = 'B';
    out[uri.r2Tenmin(PI / 4.0)] = 'C';
    out[uri.r2Tenmin(PI / 3.0)] = 'D';
    out[uri.r2Tenmin(PI * 0.5)] = 'E';
    out[uri.r2Tenmin(PI / 1.5)] = 'F';
    out[uri.r2Tenmin(PI * 0.75)] = 'G';
    out[uri.r2Tenmin(PI / 1.2)] = 'H';
    out[uri.r2Tenmin(PI)] = 'I';
    out[uri.r2Tenmin(PI / 6.0 + PI)] = 'J';
    out[uri.r2Tenmin(PI / 4.0 + PI)] = 'K';
    out[uri.r2Tenmin(PI / 3.0 + PI)] = 'L';
    out[uri.r2Tenmin(PI * 1.5)] = 'M';
    out[uri.r2Tenmin(PI / 1.5 + PI)] = 'N';
    out[uri.r2Tenmin(PI * 1.75)] = 'O';
    out[uri.r2Tenmin(PI / 1.2 + PI)] = 'P';
    out[uri.r2Tenmin(PI * 2.0)] = 'Q';
    return out;
  })();

  uri.USUAL_URI2R = (function() {
    var key, out, ref, val;
    out = {};
    ref = uri.USUAL_R2URI;
    for (key in ref) {
      val = ref[key];
      out[val] = +key;
    }
    return out;
  })();

  uri.USUAL_S2URI = {
    d1250: 'C',
    d2500: 'D',
    d5000: 'E',
    e1000: 'F',
    e2000: 'G',
    e4000: 'H',
    e8000: 'I',
    m1250: 'R',
    m2500: 'S',
    m5000: 'T',
    l1000: 'U',
    l2000: 'V',
    l4000: 'W',
    l8000: 'X'
  };

  uri.USUAL_URI2S = {
    A: 0,
    C: -0.125,
    D: -0.25,
    E: -0.5,
    F: -1,
    G: -2,
    H: -4,
    I: -8,
    R: 0.125,
    S: 0.25,
    T: 0.5,
    U: 1,
    V: 2,
    W: 4,
    X: 8,
    Z: 10000
  };

  uri.USUAL_T2URI = {
    d1250: 'C',
    d2500: 'D',
    d5000: 'E',
    e1000: 'F',
    e2000: 'G',
    e4000: 'H',
    e8000: 'I',
    m1250: 'R',
    m2500: 'S',
    m5000: 'T',
    l1000: 'U',
    l2000: 'V',
    l4000: 'W',
    l8000: 'X'
  };

  uri.USUAL_URI2T = {
    A: 0,
    C: -0.125,
    D: -0.25,
    E: -0.5,
    F: -1,
    G: -2,
    H: -4,
    I: -8,
    R: 0.125,
    S: 0.25,
    T: 0.5,
    U: 1,
    V: 2,
    W: 4,
    X: 8,
    Z: 10000
  };

  uri.MULTIPLIER = {
    a: -1 / 10000000,
    b: -1 / 1000000,
    c: -1 / 100000,
    d: -1 / 10000,
    e: -1 / 1000,
    f: -1 / 100,
    g: -1 / 10,
    h: -1,
    p: 1 / 10000000,
    o: 1 / 1000000,
    n: 1 / 100000,
    m: 1 / 10000,
    l: 1 / 1000,
    k: 1 / 100,
    j: 1 / 10,
    i: 1
  };

  uri.B64DECODE = (function() {
    var b64, i, j, out;
    out = {};
    b64 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-";
    for (i = j = 0; j <= 63; i = ++j) {
      out[b64[i]] = i;
    }
    return out;
  })();

  Item = (function() {
    Item.prototype.C = "/src/item/base-item.litcoffee:Item";

    Item.prototype.toString = function() {
      return "[object Item]";
    };

    function Item(main1, index1, config) {
      var M;
      this.main = main1;
      this.index = index1;
      if (config == null) {
        config = {};
      }
      M = "/src/item/base-item.litcoffee:Item:constructor()\n  ";
      if (ªO !== ªtype(config)) {
        throw TypeError(M + "Optional `config` is " + (ªtype(config)) + " not object");
      }
      if (ªO !== ªtype(this.main)) {
        throw TypeError(M + "`main` is " + (ªtype(this.main)) + " not object");
      }
      if ('[object Oo3d]' !== '' + this.main) {
        throw TypeError(M + "`main` is '" + this.main + "' not '[object Oo3d]'");
      }
      if (ªN !== ªtype(this.index)) {
        throw TypeError(M + "`index` is " + (ªtype(this.index)) + " not number");
      }
      if (ªMAX < this.index || this.index % 1 || 0 > this.index) {
        throw RangeError(M + "`index` is " + this.index + " not 0 or a positive integer below 2^53");
      }
      this.matTransform = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
      this.rX = 0;
      this.rY = 0;
      this.rZ = 0;
      this.sX = 1;
      this.sY = 1;
      this.sZ = 1;
      this.tX = 0;
      this.tY = 0;
      this.tZ = 0;
    }

    Item.prototype.getSnapshot = function(format) {
      var M, m, mat, sf3;
      M = "/src/item/base-item.litcoffee:Item:getSnapshot()\n  ";
      if ('log' === format) {
        m = this.matTransform;
        return "m:[" + m[0] + "," + m[1] + "," + m[2] + "," + m[3] + ", " + m[4] + "," + m[5] + "," + m[6] + "," + m[7] + ", " + m[8] + "," + m[9] + "," + m[10] + "," + m[11] + ", " + m[12] + "," + m[13] + "," + m[14] + "," + m[15] + "], rX:" + this.rX + ", rY:" + this.rY + ", rZ:" + this.rZ + ", sX:" + this.sX + ", sY:" + this.sY + ", sZ:" + this.sZ + ", tX:" + this.tX + ", tY:" + this.tY + ", tZ:" + this.tZ;
      } else if ('nwang' === format) {
        sf3 = this.main.nwang.sf3;
        return [sf3(this.rX), sf3(this.rY), sf3(this.rZ), sf3(this.sX), sf3(this.sY), sf3(this.sZ), sf3(this.tX), sf3(this.tY), sf3(this.tZ)].join('');
      } else {
        mat = new Float32Array(16);
        mat.set(this.matTransform);
        return {
          mat: mat,
          rX: this.rX,
          rY: this.rY,
          rZ: this.rZ,
          sX: this.sX,
          sY: this.sY,
          sZ: this.sZ,
          tX: this.tX,
          tY: this.tY,
          tZ: this.tZ
        };
      }
    };

    Item.prototype.setSnapshot = function(snapshot) {
      var M, captureFn, captureFns, captureI, captureKey, captureKeys, captureLength, captureLengths, ch, chI, format, l, m, matches, nwang;
      M = "/src/item/base-item.litcoffee:Item:setSnapshot()\n  ";
      format = ªtype(snapshot);
      if (ªS === format) {
        format = 'm:[' === snapshot.slice(0, 3) ? 'log' : 'nwang';
      }
      if ('log' === format) {
        matches = snapshot.match(/^m:\[(.*)\],\s*rX:(-?[.\d]*),\s*rY:(-?[.\d]*),\s*rZ:(-?[.\d]*),\s*sX:(-?[.\d]*),\s*sY:(-?[.\d]*),\s*sZ:(-?[.\d]*),\s*tX:(-?[.\d]*),\s*tY:(-?[.\d]*),\s*tZ:(-?[.\d]*)$/);
        if (null === matches) {
          throw Error(M + "log-format snapshot is invalid");
        }
        snapshot = matches[0], m = matches[1], this.rX = matches[2], this.rY = matches[3], this.rZ = matches[4], this.sX = matches[5], this.sY = matches[6], this.sZ = matches[7], this.tX = matches[8], this.tY = matches[9], this.tZ = matches[10];
        this.matTransform = new Float32Array(m.split(','));
      } else if ('nwang' === format) {
        nwang = this.main.nwang;
        captureKeys = ['rX', 'rY', 'rZ', 'sX', 'sY', 'sZ', 'tX', 'tY', 'tZ'];
        captureLengths = [1, 1, 1, 1, 1, 1, 1, 1, 1];
        captureFns = [nwang.sf3, nwang.sf3, nwang.sf3, nwang.sf3, nwang.sf3, nwang.sf3, nwang.sf3, nwang.sf3, nwang.sf3];
        chI = 0;
        l = snapshot.length;
        captureI = 0;
        while (chI < l) {
          captureKey = captureKeys[captureI];
          captureLength = captureLengths[captureI];
          captureFn = captureFns[captureI];
          ch = snapshot[chI];
          chI++;
          this[captureKey] = captureFn(ch);
          captureI++;
        }
      }
      this.matTransform = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
      this.main.rotate(this.rX, this.rY, this.rZ, this.index);
      this.main.scale(this.sX, this.sY, this.sZ, this.index);
      return this.main.translate(this.tX, this.tY, this.tZ, this.index);
    };

    return Item;

  })();

  Item.Camera = (function(superClass) {
    extend(Camera, superClass);

    Camera.prototype.C = "/src/item/class-item-camera.litcoffee:Item.Camera";

    Camera.prototype.toString = function() {
      return "[object Item.Camera]";
    };

    function Camera(main, index, config) {
      var M;
      if (config == null) {
        config = {};
      }
      M = this.C + ":constructor()\n  ";
      Camera.__super__.constructor.call(this, main, index, config);
      this.fovy = config.fovy;
      if (ªU === ªtype(this.fovy)) {
        this.fovy = 0.785398163;
      } else if (ªN !== ªtype(this.fovy)) {
        throw TypeError(M + "Optional `config.fovy` is " + (ªtype(this.fovy)) + " not number");
      } else if (0 >= this.fovy) {
        throw RangeError(M + "Optional `config.fovy` is " + this.fovy + " not greater than zero");
      }
      this.aspect = config.aspect;
      if (ªU === ªtype(this.aspect)) {
        this.aspect = this.main.$main.width / this.main.$main.height;
      } else if (ªN !== ªtype(this.aspect)) {
        throw TypeError(M + "Optional `config.aspect` is " + (ªtype(this.aspect)) + " not number");
      } else if (0 >= this.aspect) {
        throw RangeError(M + "Optional `config.aspect` is " + this.aspect + " not greater than zero");
      }
      this.matProjection = mat4.perspective(this.fovy, this.aspect, 1, 100);
      this.matCamera = null;
      this.matTransform[14] = -4;
      this.tZ = -4;
      this.updateCamera();
    }

    Camera.prototype.updateCamera = function() {
      return this.matCamera = new Float32Array(mat4.multiply(this.matProjection, this.matTransform));
    };

    Camera.prototype.xx = function() {};

    return Camera;

  })(Item);

  Item.Mesh = (function(superClass) {
    extend(Mesh, superClass);

    Mesh.prototype.C = "/src/item/class-item-mesh.litcoffee:Item.Mesh";

    Mesh.prototype.toString = function() {
      return "[object Item.Mesh]";
    };

    function Mesh(main, index, config) {
      var M;
      if (config == null) {
        config = {};
      }
      M = this.C + ":constructor()\n  ";
      Mesh.__super__.constructor.call(this, main, index, config);
      Mesh.__super__.constructor.call(this, main, index, config);
      this.color = pick.indexToColor(this.index);
      this.positionBuffer = this.main.positionBuffers[config.positionI || 0];
      if (!this.positionBuffer) {
        throw Error(M + "`config.positionI` " + config.positionI + " does not exist");
      }
      this.colorBuffer = this.main.colorBuffers[config.colorI || 0];
      if (!this.colorBuffer) {
        throw Error(M + "`config.colorI` " + config.colorI + " does not exist");
      }
      if (this.positionBuffer.count !== this.colorBuffer.count) {
        throw Error(M + "`config.positionI` mismatches config.colorI");
      }
      this.count = this.positionBuffer.count;
      this.renderMode = config.renderMode || 'TRIANGLES';
      if (!Item.Mesh.validRenderMode[this.renderMode]) {
        throw Error(M + "`config.renderMode` " + this.renderMode + " is not recognised by WebGL");
      }
      if (!config.blend) {
        this.sBlend = null;
        this.dBlend = null;
      } else if (ªA !== ªtype(config.blend)) {
        throw Error(M + "If set, `config.blend` must be array not " + (ªtype(config.blend)));
      } else {
        if (!Item.Mesh.validBlend[config.blend[0]]) {
          throw Error(M + "`config.blend[0]` is not recognised by WebGL");
        }
        if (!Item.Mesh.validBlend[config.blend[1]]) {
          throw Error(M + "`config.blend[1]` is not recognised by WebGL");
        }
        this.sBlend = this.main.gl[config.blend[0]];
        this.dBlend = this.main.gl[config.blend[1]];
      }
    }

    Mesh.prototype.xx = function(xx) {};

    return Mesh;

  })(Item);

  Item.Mesh.validRenderMode = {
    'POINTS': 1,
    'LINES': 1,
    'LINE_STRIP': 1,
    'LINE_LOOP': 1,
    'TRIANGLES': 1,
    'TRIANGLE_STRIP': 1,
    'TRIANGLE_FAN': 1
  };

  Item.Mesh.validBlend = {
    'ZERO': 1,
    'ONE': 1,
    'SRC_COLOR': 1,
    'ONE_MINUS_SRC_COLOR': 1,
    'DST_COLOR': 1,
    'ONE_MINUS_DST_COLOR': 1,
    'SRC_ALPHA': 1,
    'ONE_MINUS_SRC_ALPHA': 1,
    'DST_ALPHA': 1,
    'ONE_MINUS_DST_ALPHA': 1,
    'SRC_ALPHA_SATURATE': 1
  };

  Program = (function() {
    Program.prototype.C = 'Program';

    Program.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function Program(main1, config) {
      var gl;
      this.main = main1;
      if (config == null) {
        config = {};
      }
      if (ªO !== ªtype(config)) {
        throw TypeError("`config` must be object not " + (ªtype(config)));
      }
      if (ªO !== ªtype(this.main)) {
        throw TypeError("`main` must be object not " + (ªtype(this.main)));
      }
      if ('[object Oo3d]' !== '' + this.main) {
        throw TypeError("`main` must be [object Oo3d] not " + this.main);
      }
      gl = this.main.gl;
      this.vertexShader = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(this.vertexShader, this.vertexSource());
      gl.compileShader(this.vertexShader);
      if (!gl.getShaderParameter(this.vertexShader, gl.COMPILE_STATUS)) {
        this.cleanUp();
        throw Error(this.C + ".vertexShader failed to compile");
      }
      this.fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(this.fragmentShader, this.fragmentSource());
      gl.compileShader(this.fragmentShader);
      if (!gl.getShaderParameter(this.fragmentShader, gl.COMPILE_STATUS)) {
        this.cleanUp();
        throw Error(this.C + ".fragmentShader failed to compile");
      }
      this.program = gl.createProgram();
      gl.attachShader(this.program, this.vertexShader);
      gl.attachShader(this.program, this.fragmentShader);
      gl.linkProgram(this.program);
      if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
        this.cleanUp();
        throw Error(this.C + ".program failed to link");
      }
    }

    Program.prototype.cleanUp = function() {
      if (this.vertexShader) {
        this.main.gl.deleteShader(this.vertexShader);
      }
      if (this.fragmentShader) {
        this.main.gl.deleteShader(this.fragmentShader);
      }
      if (this.program) {
        return this.main.gl.deleteProgram(this.program);
      }
    };

    Program.prototype.vertexSource = function() {
      return "void main() {\n}";
    };

    Program.prototype.fragmentSource = function() {
      return "void main() {\n}";
    };

    return Program;

  })();

  Program.Flat = (function(superClass) {
    extend(Flat, superClass);

    Flat.prototype.C = 'Program.Flat';

    Flat.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function Flat(main, config) {
      var gl;
      if (config == null) {
        config = {};
      }
      Flat.__super__.constructor.call(this, main, config);
      gl = this.main.gl;
      gl.useProgram(this.program);
      this.aVtxPositionLoc = gl.getAttribLocation(this.program, 'aVtxPosition');
      gl.enableVertexAttribArray(this.aVtxPositionLoc);
      this.aVtxColorLoc = gl.getAttribLocation(this.program, 'aVtxColor');
      this.uMatTransformLoc = gl.getUniformLocation(this.program, 'uMatTransform');
      this.uMatCameraLoc = gl.getUniformLocation(this.program, 'uMatCamera');
    }

    Flat.prototype.vertexSource = function() {
      return "attribute vec3 aVtxPosition;\nattribute vec4 aVtxColor;\n\nuniform mat4 uMatTransform;\nuniform mat4 uMatCamera;\n\nvarying vec4 vColor; // declare `vColor`\n\nvoid main() {\n\n  //// Increase the size of gl.POINT from 1px to 4px. \n  gl_PointSize = 4.0;\n\n  //// Apply the Camera and Mesh transforms to each vertex position. \n  //// Note that the order of these three is important. \n  gl_Position = uMatCamera * uMatTransform * vec4(aVtxPosition, 1);\n\n  //// Pass the vertex-color attribute unchanged to the fragment-shader. \n  vColor = aVtxColor;\n}";
    };

    Flat.prototype.fragmentSource = function() {
      return "precision mediump float; // boilerplate for mobile-friendly shaders\n\nvarying vec4 vColor; // linear-interpolated input from fragment-shader\n\nvoid main(void) {\n  gl_FragColor = vColor;\n}";
    };

    return Flat;

  })(Program);

  Program.FlatItem = (function(superClass) {
    extend(FlatItem, superClass);

    FlatItem.prototype.C = 'Program.FlatItem';

    FlatItem.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function FlatItem(main, config) {
      var gl;
      if (config == null) {
        config = {};
      }
      FlatItem.__super__.constructor.call(this, main, config);
      gl = this.main.gl;
      gl.useProgram(this.program);
      this.aVtxPositionLoc = gl.getAttribLocation(this.program, 'aVtxPosition');
      gl.enableVertexAttribArray(this.aVtxPositionLoc);
      this.uMatTransformLoc = gl.getUniformLocation(this.program, 'uMatTransform');
      this.uMatCameraLoc = gl.getUniformLocation(this.program, 'uMatCamera');
      this.uMeshColorLoc = gl.getUniformLocation(this.program, 'uMeshColor');
    }

    FlatItem.prototype.vertexSource = function() {
      return "attribute vec3 aVtxPosition;\n\nuniform mat4 uMatTransform;\nuniform mat4 uMatCamera;\n\nuniform vec4 uMeshColor; // the mesh renders as a single flat color\n\n\nvarying vec4 vColor; // declare `vColor`\n\nvoid main() {\n\n  //// Multiply the position by the camera transformation and matrices. \n  //// Note that the order of these three is important. \n  gl_Position = uMatCamera * uMatTransform * vec4(aVtxPosition, 1);\n\n  //// Pass the vertex-color attribute unchanged to the fragment-shader. \n  vColor = uMeshColor;\n\n}";
    };

    FlatItem.prototype.fragmentSource = function() {
      return "precision mediump float; // boilerplate for mobile-friendly shaders\n\nvarying vec4 vColor; // linear-interpolated input from fragment-shader\n\nvoid main() {\n  gl_FragColor = vColor;\n}";
    };

    return FlatItem;

  })(Program);

  Program.Flatwhite = (function(superClass) {
    extend(Flatwhite, superClass);

    Flatwhite.prototype.C = 'Program.Flatwhite';

    Flatwhite.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function Flatwhite(main, config) {
      var gl;
      if (config == null) {
        config = {};
      }
      Flatwhite.__super__.constructor.call(this, main, config);
      gl = this.main.gl;
      gl.useProgram(this.program);
      this.aVtxPositionLoc = gl.getAttribLocation(this.program, 'aVtxPosition');
      gl.enableVertexAttribArray(this.aVtxPositionLoc);
      this.uMatTransformLoc = gl.getUniformLocation(this.program, 'uMatTransform');
      this.uMatCameraLoc = gl.getUniformLocation(this.program, 'uMatCamera');
    }

    Flatwhite.prototype.vertexSource = function() {
      return "attribute vec3 aVtxPosition;\n\nuniform mat4 uMatTransform;\nuniform mat4 uMatCamera;\n\nvoid main() {\n\n  //// Multiply the position by the camera transformation and matrices. \n  //// Note that the order of these three is important. \n  gl_Position = uMatCamera * uMatTransform * vec4(aVtxPosition, 1);\n\n}";
    };

    Flatwhite.prototype.fragmentSource = function() {
      return "precision mediump float; // boilerplate for mobile-friendly shaders\n\nvec4 white = vec4(1.0,1.0,1.0,1.0);\n\nvoid main() {\n  gl_FragColor = white;\n}";
    };

    return Flatwhite;

  })(Program);

  Renderer = (function() {
    var RendererTypeError;

    Renderer.prototype.C = 'Renderer';

    Renderer.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function Renderer(main1, config) {
      var i;
      this.main = main1;
      if (config == null) {
        config = {};
      }
      if (ªO !== ªtype(config)) {
        throw TypeError("`config` must be object not " + (ªtype(config)));
      }
      if (ªO !== ªtype(this.main)) {
        throw TypeError("`main` must be object not " + (ªtype(this.main)));
      }
      if ('[object Oo3d]' !== '' + this.main) {
        throw TypeError("`main` must be [object Oo3d] not " + this.main);
      }
      if (ªN !== ªtype(config.programI)) {
        throw TypeError("config.programI must be number not " + (ªtype(config.programI)));
      }
      this.program = this.main.programs[config.programI] || (function() {
        throw RangeError("No such index " + config.programI + " in main.programs");
      })();
      if (ªN !== ªtype(config.cameraI)) {
        throw TypeError("config.cameraI must be number not " + (ªtype(config.cameraI)));
      }
      this.camera = this.main.cameras[config.cameraI] || (function() {
        throw RangeError("No such index " + config.cameraI + " in main.cameras");
      })();
      this.uMatCameraLoc = this.main.gl.getUniformLocation(this.program.program, 'uMatCamera');
      if (!config.meshIs) {
        this.meshes = [];
      } else if ('uint16array' !== ªtype(config.meshIs)) {
        throw TypeError("If set, config.meshIs must be Uint16Array not " + (ªtype(config.meshIs)));
      } else {
        this.meshes = (function() {
          var j, len, ref, results;
          ref = config.meshIs;
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            i = ref[j];
            results.push(this.main.meshes[i] || (function() {
              throw RangeError("No such index " + i + " in main.meshes");
            })());
          }
          return results;
        }).call(this);
      }
    }

    Renderer.prototype.render = function() {
      var $main, aVtxColorLoc, aVtxPositionLoc, gl, index, main, mesh, mode, uMatTransformLoc, uMeshColorLoc;
      main = this.main;
      $main = main.$main;
      gl = main.gl;
      aVtxPositionLoc = this.program.aVtxPositionLoc;
      aVtxColorLoc = this.program.aVtxColorLoc || false;
      uMatTransformLoc = this.program.uMatTransformLoc;
      uMeshColorLoc = this.program.uMeshColorLoc;
      if (!gl) {
        throw Error("The WebGL rendering context is " + (ªtype(gl)));
      }
      gl.useProgram(this.program.program);
      gl.uniformMatrix4fv(this.uMatCameraLoc, false, this.camera.matCamera);
      if (aVtxColorLoc) {
        gl.enableVertexAttribArray(aVtxColorLoc);
      }
      index = this.meshes.length;
      while (index--) {
        mesh = this.meshes[index];
        if (!mesh) {
          continue;
        }
        gl.uniformMatrix4fv(uMatTransformLoc, gl.FALSE, mesh.matTransform);
        if (uMeshColorLoc) {
          gl.uniform4fv(uMeshColorLoc, mesh.color);
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, mesh.positionBuffer);
        gl.vertexAttribPointer(aVtxPositionLoc, 3, gl.FLOAT, false, 0, 0);
        if (aVtxColorLoc) {
          gl.bindBuffer(gl.ARRAY_BUFFER, mesh.colorBuffer);
          gl.vertexAttribPointer(aVtxColorLoc, 4, gl.FLOAT, false, 0, 0);
        }
        if (null !== mesh.sBlend) {
          gl.enable(gl.BLEND);
          gl.blendFunc(mesh.sBlend, mesh.dBlend);
        } else {
          gl.disable(gl.BLEND);
        }
        mode = gl[mesh.renderMode];
        gl.drawArrays(mode, 0, mesh.count);
        gl.flush();
      }
      if (aVtxColorLoc) {
        return gl.disableVertexAttribArray(aVtxColorLoc);
      }
    };

    RendererTypeError = (function(superClass) {
      extend(RendererTypeError, superClass);

      function RendererTypeError(message) {
        this.message = "Renderer " + message;
        this.name = this.constructor.name;
      }

      RendererTypeError.prototype = new Error();

      RendererTypeError.prototype.constructor = RendererTypeError;

      return RendererTypeError;

    })(TypeError);

    return Renderer;

  })();

  Renderer.Wireframe = (function(superClass) {
    extend(Wireframe, superClass);

    Wireframe.prototype.C = 'Renderer.Wireframe';

    function Wireframe(main, config) {
      if (config == null) {
        config = {};
      }
      Wireframe.__super__.constructor.call(this, main, config);
    }

    return Wireframe;

  })(Renderer);

  Tudor = (function() {
    Tudor.prototype.I = 'Tudor';

    Tudor.prototype.toString = function() {
      return "[object " + I + "]";
    };

    Tudor.prototype.articles = [];

    function Tudor(opt) {
      this.opt = opt != null ? opt : {};
      this["do"] = bind(this["do"], this);
      switch (this.opt.format) {
        case 'html':
          this.pageHead = function(summary) {
            return "<style>\n  body     { font-family: sans-serif; }\n  a        { outline: 0; }\n  b        { display: inline-block; width: .7em }\n\n  b.pass              { color: #393 }\n  b.fail              { color: #bbb }\n  article.fail b.pass { color: #bbb }\n  section.fail b.pass { color: #bbb }\n\n  pre      { padding: .5em; margin: .2em 0; border-radius: 4px; }\n  pre.fn   { background-color: #fde }\n  pre.pass { background-color: #cfc }\n  pre.fail { background-color: #d8e0e8 }\n\n  article  { margin-bottom: .5rem }\n  article h2 { padding-left:.5rem; margin:0; font-weight:normal }\n  article.pass { border-left: 5px solid #9c9 }\n  article.fail { border-left: 5px solid #9bf }\n  article.fail h2 { margin-bottom: .5rem }\n  article.pass >div { display: none }\n\n  section  { margin-bottom: .5rem }\n  section h3   { padding-left: .5rem; margin: 0; }\n  section.pass { border-left: 3px solid #9c9 }\n  section.fail { border-left: 3px solid #9bf }\n  section.fail h3 { margin-bottom: .5rem }\n  section.pass >div { display: none }\n\n  article.fail section.pass { border-left-color: #ccc }\n\n  div      { padding-left: .5em; }\n  div.fail { border-left: 3px solid #9bf; font-size: .8rem }\n  div h4   { margin: 0 }\n  div h4 { font: normal .8rem/1.2rem monaco, monospace }\n  div.fail, div.fail h4 { margin: .5rem 0 }\n\n</style>\n<h4><a href=\"#end\" id=\"top\">\u2b07</a>  " + summary + "</h4>";
          };
          this.pageFoot = function(summary) {
            return "<h4><a href=\"#top\" id=\"end\">\u2b06</a>  " + summary + "</h4>\n<script>\n  document.title='" + (summary.replace(/<\/?[^>]+>/g, '')) + "';\n</script>";
          };
          this.articleHead = function(heading, fail) {
            return ("<article class=\"" + (fail ? 'fail' : 'pass') + "\">") + ("<h2>" + (fail ? this.cross : this.tick) + heading + "</h2><div>");
          };
          this.articleFoot = '</div></article>';
          this.sectionHead = function(heading, fail) {
            return ("<section class=\"" + (fail ? 'fail' : 'pass') + "\">") + ("<h3>" + (fail ? this.cross : this.tick) + heading + "</h3><div>");
          };
          this.sectionFoot = '</div></section>';
          this.jobFormat = function(heading, result) {
            return ("<div class=\"" + (result ? 'fail' : 'pass') + "\">") + ("<h4>" + (result ? this.cross : this.tick) + heading + "</h4>") + ("" + (result ? this.formatError(result) : '')) + "</div>";
          };
          this.tick = '<b class="pass">\u2713</b> ';
          this.cross = '<b class="fail">\u2718</b> ';
          break;
        default:
          this.pageHead = function(summary) {
            return "" + summary;
          };
          this.pageFoot = function(summary) {
            return "\n" + summary;
          };
          this.articleHead = function(heading, fail) {
            return "\n" + (fail ? this.cross : this.tick) + " " + heading + "\n===" + (new Array(heading.length).join('=')) + "\n";
          };
          this.articleFoot = '';
          this.sectionHead = function(heading, fail) {
            return "\n" + (fail ? this.cross : this.tick) + " " + heading + "\n---" + (new Array(heading.length).join('-')) + "\n";
          };
          this.sectionFoot = '';
          this.jobFormat = function(heading, result) {
            return ((result ? this.cross : this.tick) + " " + heading) + ("" + (result ? '\n' + this.formatError(result) : ''));
          };
          this.jobFoot = '';
          this.tick = '\u2713';
          this.cross = '\u2718';
      }
    }

    Tudor.prototype.add = function(lines) {
      var article, i, line, runner, section;
      article = {
        sections: []
      };
      runner = null;
      section = null;
      if (ªA !== ªtype(lines)) {
        throw new Error("`lines` isn’t an array");
      }
      if (0 === lines.length) {
        throw new Error("`lines` has no elements");
      }
      if (ªS !== ªtype(lines[0])) {
        throw new Error("`lines[0]` isn’t a string");
      }
      article.heading = lines.shift();
      i = 0;
      while (i < lines.length) {
        line = lines[i];
        switch (ªtype(line)) {
          case ªO:
            if (!line.runner) {
              throw new Error("Errant object");
            }
            runner = line.runner;
            break;
          case ªF:
            section.jobs.push(line);
            break;
          case ªS:
            if (this.isAssertion(lines[i + 1], lines[i + 2])) {
              if (!section) {
                throw new Error("Cannot add an assertion here");
              }
              section.jobs.push([runner, line, lines[++i], lines[++i]]);
            } else {
              section = {
                heading: line,
                jobs: []
              };
              article.sections.push(section);
            }
        }
        i++;
      }
      return this.articles.push(article);
    };

    Tudor.prototype["do"] = function() {
      var actual, art, artFail, artPass, article, e, error, expect, heading, j, job, len, len1, len2, mock, mockFail, o, pge, pgeFail, pgePass, q, ref, ref1, ref2, result, runner, sec, secFail, secPass, section, summary;
      pge = [];
      mock = null;
      pgePass = pgeFail = mockFail = 0;
      ref = this.articles;
      for (j = 0, len = ref.length; j < len; j++) {
        article = ref[j];
        art = [];
        artPass = artFail = 0;
        ref1 = article.sections;
        for (o = 0, len1 = ref1.length; o < len1; o++) {
          section = ref1[o];
          sec = [];
          secPass = secFail = 0;
          ref2 = section.jobs;
          for (q = 0, len2 = ref2.length; q < len2; q++) {
            job = ref2[q];
            switch (ªtype(job)) {
              case ªF:
                try {
                  mock = job.apply(this, mock);
                } catch (_error) {
                  e = _error;
                  error = e.message;
                }
                if (error) {
                  mockFail++;
                  secFail++;
                  sec.push(this.formatMockModifierError(job, error));
                }
                break;
              case ªA:
                runner = job[0], heading = job[1], expect = job[2], actual = job[3];
                result = runner(expect, actual, mock);
                if (!result) {
                  sec.push(this.jobFormat("" + (this.sanitize(heading))));
                  pgePass++;
                  artPass++;
                  secPass++;
                } else {
                  sec.push(this.jobFormat("" + (this.sanitize(heading)), result));
                  pgeFail++;
                  artFail++;
                  secFail++;
                }
            }
          }
          sec.unshift(this.sectionHead("" + (this.sanitize(section.heading)), secFail));
          sec.push(this.sectionFoot);
          art = art.concat(sec);
        }
        art.unshift(this.articleHead("" + (this.sanitize(article.heading)), artFail));
        art.push(this.articleFoot);
        pge = pge.concat(art);
        summary = pgeFail ? this.cross + " FAILED " + pgeFail + "/" + (pgePass + pgeFail) : this.tick + " Passed " + pgePass + "/" + (pgePass + pgeFail);
        if (mockFail) {
          summary = "\n" + this.cross + " (MOCK FAILS)";
        }
      }
      pge.unshift(this.pageHead(summary));
      pge.push(this.pageFoot(summary));
      return pge.join('\n');
    };

    Tudor.prototype.formatError = function(result) {
      switch (result.length + "-" + this.opt.format) {
        case '2-html':
          return result[0] + "\n<pre class=\"fail\">" + (this.sanitize(result[1].message)) + "</pre>";
        case '2-plain':
          return result[0] + "\n" + (this.sanitize(result[1].message));
        case '3-html':
          return "<pre class=\"fail\">" + (this.sanitize(this.reveal(result[0]))) + "</pre>\n..." + result[1] + "...\n<pre class=\"pass\">" + (this.sanitize(this.reveal(result[2]))) + "</pre>";
        case '3-plain':
          return (this.sanitize(this.reveal(result[0]))) + "\n..." + result[1] + "...\n" + (this.sanitize(this.reveal(result[2])));
        case '4-html':
          return "<pre class=\"fail\">" + (this.sanitize(this.reveal(result[0]))) + " (" + (ªtype(result[0])) + ")</pre>\n..." + result[1] + "...\n<pre class=\"pass\">" + (this.sanitize(this.reveal(result[2]))) + " (" + (ªtype(result[2])) + ")</pre>";
        case '4-plain':
          return (this.sanitize(this.reveal(result[0]))) + " (" + (ªtype(result[0])) + ")\n..." + result[1] + "...\n" + (this.sanitize(this.reveal(result[2]))) + " (" + (ªtype(result[2])) + ")";
        default:
          throw new Error("Cannot process '" + result.length + "-" + this.opt.format + "'");
      }
    };

    Tudor.prototype.formatMockModifierError = function(fn, error) {
      switch (this.opt.format) {
        case 'html':
          return "<pre class=\"fn\">" + (this.sanitize(fn + '')) + "</pre>\n...encountered an exception:\n<pre class=\"fail\">" + (this.sanitize(error)) + "</pre>";
        default:
          return (this.sanitize(fn + '')) + "\n...encountered an exception:\n" + (this.sanitize(error));
      }
    };

    Tudor.prototype.reveal = function(value) {
      return value != null ? value.toString().replace(/^\s+|\s+$/g, function(match) {
        return '\u00b7' + (new Array(match.length)).join('\u00b7');
      }) : void 0;
    };

    Tudor.prototype.sanitize = function(value) {
      switch (this.opt.format) {
        case 'html':
          return value != null ? value.toString().replace(/</g, '&lt;') : void 0;
        default:
          return value;
      }
    };

    Tudor.prototype["throw"] = {
      runner: function(expect, actual, mock) {
        var e, error;
        error = false;
        try {
          actual.apply(this, mock);
        } catch (_error) {
          e = _error;
          error = e;
        }
        if (!error) {
          return [
            'No exception thrown, expected', {
              message: expect
            }
          ];
        } else if (expect !== error.message) {
          return [error.message, 'was thrown, but expected', expect];
        }
      }
    };

    Tudor.prototype.equal = {
      runner: function(expect, actual, mock) {
        var e, error, result;
        error = false;
        try {
          result = actual.apply(this, mock);
        } catch (_error) {
          e = _error;
          error = e;
        }
        if (error) {
          return ['Unexpected exception', error];
        } else if (expect !== result) {
          if (result + '' === expect + '') {
            return [result, 'was returned, but expected', expect, true];
          } else {
            return [result, 'was returned, but expected', expect];
          }
        }
      }
    };

    Tudor.prototype.is = {
      runner: function(expect, actual, mock) {
        var e, error, result;
        error = false;
        try {
          result = actual.apply(this, mock);
        } catch (_error) {
          e = _error;
          error = e;
        }
        if (error) {
          return ['Unexpected exception', error];
        } else if (expect !== ªtype(result)) {
          return ["type " + (ªtype(result)), 'was returned, but expected', "type " + expect];
        }
      }
    };

    Tudor.prototype.match = {
      runner: function(expect, actual, mock) {
        var e, error, result;
        error = false;
        try {
          result = actual.apply(this, mock);
        } catch (_error) {
          e = _error;
          error = e;
        }
        if (error) {
          return ['Unexpected exception', error];
        } else if (ªF !== typeof expect.test) {
          return [
            '`test()` is not a function', {
              message: expect
            }
          ];
        } else if (!expect.test('' + result)) {
          return ['' + result, 'failed test', expect];
        }
      }
    };

    Tudor.prototype.isAssertion = function(line1, line2) {
      if (ªF !== ªtype(line2)) {
        return false;
      }
      if ((ªO === ªtype(line1)) && ªF === ªtype(line1.runner)) {
        return false;
      }
      return true;
    };

    return Tudor;

  })();

  tudor = new Tudor({
    format: ªO === typeof window ? 'html' : 'plain'
  });

  Main.runTest = tudor["do"];

  tudor.add([
    "01 Oo3d Constructor", tudor.is, "The class and instance are expected types", "The class is a function", ªF, function() {
      return Main;
    }, "`new` returns an object", ªO, function() {
      return new Main;
    }, "Config exceptions", tudor["throw"], "If set, `config` must be an object", "/src/class-main.litcoffee:Oo3d:constructor()\n  Optional `config` is array not object", function() {
      return new Main([]);
    }, "If set, `config.$main` must be an HTMLCanvasElement", "/src/class-main.litcoffee:Oo3d:constructor()\n  Optional `config.$main` is number not HTMLCanvasElement", function() {
      return new Main({
        $main: 123
      });
    }, "If set, `config.bkgnd` must be a Float32Array", "/src/class-main.litcoffee:Oo3d:constructor()\n  Optional `config.bkgnd` is number not float32array", function() {
      return new Main({
        bkgnd: 456
      });
    }, "`config.bkgnd` must contain four elements", "/src/class-main.litcoffee:Oo3d:constructor()\n  If set `config.bkgnd` must contain four elements", function() {
      return new Main({
        bkgnd: new Float32Array([1, 1, 1])
      });
    }, "`config.bkgnd[0]` must be 0 or greater", "/src/class-main.litcoffee:Oo3d:constructor()\n  `config.bkgnd[0]` (red) is not within range 0-1", function() {
      return new Main({
        bkgnd: new Float32Array([-0.02, 1, 1, 1])
      });
    }, "`config.bkgnd[0]` must be 1 or less", "/src/class-main.litcoffee:Oo3d:constructor()\n  `config.bkgnd[0]` (red) is not within range 0-1", function() {
      return new Main({
        bkgnd: new Float32Array([1.02, 1, 1, 1])
      });
    }, "`config.bkgnd[1]` must be 0 or greater", "/src/class-main.litcoffee:Oo3d:constructor()\n  `config.bkgnd[1]` (green) is not within range 0-1", function() {
      return new Main({
        bkgnd: new Float32Array([0, -0.02, 1, 1])
      });
    }, "`config.bkgnd[1]` must be 1 or less", "/src/class-main.litcoffee:Oo3d:constructor()\n  `config.bkgnd[1]` (green) is not within range 0-1", function() {
      return new Main({
        bkgnd: new Float32Array([0, 1.02, 1, 1])
      });
    }, "`config.bkgnd[2]` must be 0 or greater", "/src/class-main.litcoffee:Oo3d:constructor()\n  `config.bkgnd[2]` (blue) is not within range 0-1", function() {
      return new Main({
        bkgnd: new Float32Array([0, 1, -Infinity, 1])
      });
    }, "`config.bkgnd[2]` must be 1 or less", "/src/class-main.litcoffee:Oo3d:constructor()\n  `config.bkgnd[2]` (blue) is not within range 0-1", function() {
      return new Main({
        bkgnd: new Float32Array([0, 1, Infinity, 1])
      });
    }, "`config.bkgnd[3]` must be 0 or greater", "/src/class-main.litcoffee:Oo3d:constructor()\n  `config.bkgnd[3]` (alpha) is not within range 0-1", function() {
      return new Main({
        bkgnd: new Float32Array([0, 1, 1, -0.000001])
      });
    }, "`config.bkgnd[3]` must be 1 or less", "/src/class-main.litcoffee:Oo3d:constructor()\n  `config.bkgnd[3]` (alpha) is not within range 0-1", function() {
      return new Main({
        bkgnd: new Float32Array([0, 1, 0, 1.00001])
      });
    }, "Config usage", tudor.equal, "`config.bkgnd` can contain four floats 0-1, or NaN", '[object Oo3d]', function() {
      return '' + (new Main({
        bkgnd: new Float32Array([1, 0, NaN, 0.5])
      }));
    }
  ]);

  tudor.add([
    "02 Item Constructor", tudor.is, "(Mock an `Oo3d` instance)", function() {
      var CanvasMock, oo3d;
      CanvasMock = (function() {
        function CanvasMock() {}

        CanvasMock.prototype.width = 2;

        CanvasMock.prototype.height = 1;

        CanvasMock.prototype.toString = function() {
          return '[object HTMLCanvasElement]';
        };

        CanvasMock.prototype.getContext = function() {
          return {
            createBuffer: function() {
              return {};
            },
            bindBuffer: function() {},
            bufferData: function() {},
            clearColor: function() {},
            enable: function() {},
            depthFunc: function() {},
            scissor: function() {},
            clear: function() {},
            TRIANGLES: 4
          };
        };

        return CanvasMock;

      })();
      oo3d = new Main({
        $main: new CanvasMock
      });
      return [oo3d];
    }, "The class and instance are expected types", "The class is a function", ªF, function() {
      return Item;
    }, "`new` returns an object", ªO, function(oo3d) {
      return new Item(oo3d, 0);
    }, "Constructor exceptions", tudor["throw"], "`config.main` must be an object", "/src/item/base-item.litcoffee:Item:constructor()\n  `main` is number not object", function(oo3d) {
      return new Item(123);
    }, "`config.main` must be an Oo3d instance", "/src/item/base-item.litcoffee:Item:constructor()\n  `main` is '[object Object]' not '[object Oo3d]'", function(oo3d) {
      return new Item({});
    }, "`index` must be a number", "/src/item/base-item.litcoffee:Item:constructor()\n  `index` is boolean not number", function(oo3d) {
      return new Item(oo3d, true);
    }, "`index` must be an integer", "/src/item/base-item.litcoffee:Item:constructor()\n  `index` is 3.5 not 0 or a positive integer below 2^53", function(oo3d) {
      return new Item(oo3d, 3.5);
    }, "`index` must be positive", "/src/item/base-item.litcoffee:Item:constructor()\n  `index` is -44 not 0 or a positive integer below 2^53", function(oo3d) {
      return new Item(oo3d, -44);
    }, "`index` must be below 2^53", "/src/item/base-item.litcoffee:Item:constructor()\n  `index` is 9007199254740992 not 0 or a positive integer below 2^53", function(oo3d) {
      return new Item(oo3d, 9007199254740992);
    }, "`config` must be an object", "/src/item/base-item.litcoffee:Item:constructor()\n  Optional `config` is date not object", function(oo3d) {
      return new Item(oo3d, 0, new Date);
    }, "Constructor usage", tudor.equal, "`config` can be an empty object", '[object Item]', function(oo3d) {
      var item;
      item = new Item(oo3d, 0, {});
      return '' + item;
    }, "`item.matTransform` as expected", '1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1', function(oo3d) {
      var item, n;
      item = new Item(oo3d, 0, {});
      return ((function() {
        var j, len, ref, results;
        ref = item.matTransform;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          n = ref[j];
          results.push('' + n);
        }
        return results;
      })()).join(' ');
    }, "`item.rX` `item.rY` `item.rZ` as expected", '0 0 0', function(oo3d) {
      var item;
      item = new Item(oo3d, 0, {});
      return [item.rX, item.rY, item.rZ].join(' ');
    }, "`item.sX` `item.sY` `item.sZ` as expected", '1 1 1', function(oo3d) {
      var item;
      item = new Item(oo3d, 0, {});
      return [item.sX, item.sY, item.sZ].join(' ');
    }, "`item.tX` `item.tY` `item.tZ` as expected", '0 0 0', function(oo3d) {
      var item;
      item = new Item(oo3d, 0, {});
      return [item.tX, item.tY, item.tZ].join(' ');
    }
  ]);

  tudor.add([
    "04 Item.Mesh Constructor", tudor.is, "(Mock an `Oo3d` instance)", function() {
      var CanvasMock, oo3d;
      CanvasMock = (function() {
        function CanvasMock() {}

        CanvasMock.prototype.width = 2;

        CanvasMock.prototype.height = 1;

        CanvasMock.prototype.toString = function() {
          return '[object HTMLCanvasElement]';
        };

        CanvasMock.prototype.getContext = function() {
          return {
            createBuffer: function() {
              return {};
            },
            bindBuffer: function() {},
            bufferData: function() {},
            clearColor: function() {},
            enable: function() {},
            depthFunc: function() {},
            scissor: function() {},
            clear: function() {},
            TRIANGLES: 4
          };
        };

        return CanvasMock;

      })();
      oo3d = new Main({
        $main: new CanvasMock
      });
      return [oo3d];
    }, "The class and instance are expected types", "The class is a function", ªF, function() {
      return Item.Mesh;
    }, "`new` returns an object", ªO, function(oo3d) {
      return new Item.Mesh(oo3d, 0);
    }, "Item Constructor exceptions", tudor["throw"], "`config.main` must be an object", "/src/item/base-item.litcoffee:Item:constructor()\n  `main` is number not object", function(oo3d) {
      return new Item.Mesh(123);
    }, "`config.main` must be an Oo3d instance", "/src/item/base-item.litcoffee:Item:constructor()\n  `main` is '[object Object]' not '[object Oo3d]'", function(oo3d) {
      return new Item.Mesh({});
    }, "`index` must be a number", "/src/item/base-item.litcoffee:Item:constructor()\n  `index` is boolean not number", function(oo3d) {
      return new Item.Mesh(oo3d, true);
    }, "`index` must be an integer", "/src/item/base-item.litcoffee:Item:constructor()\n  `index` is 3.5 not 0 or a positive integer below 2^53", function(oo3d) {
      return new Item.Mesh(oo3d, 3.5);
    }, "`index` must be positive", "/src/item/base-item.litcoffee:Item:constructor()\n  `index` is -44 not 0 or a positive integer below 2^53", function(oo3d) {
      return new Item.Mesh(oo3d, -44);
    }, "`index` must be below 2^53", "/src/item/base-item.litcoffee:Item:constructor()\n  `index` is 9007199254740992 not 0 or a positive integer below 2^53", function(oo3d) {
      return new Item.Mesh(oo3d, 9007199254740992);
    }, "`config` must be an object", "/src/item/base-item.litcoffee:Item:constructor()\n  Optional `config` is date not object", function(oo3d) {
      return new Item.Mesh(oo3d, 0, new Date);
    }, "Item.Mesh Constructor exceptions", "If set, config.positionI must refer to an actual positionBuffer", "/src/item/class-item-mesh.litcoffee:Item.Mesh:constructor()\n  `config.positionI` foo does not exist", function(oo3d) {
      return new Item.Mesh(oo3d, 0, {
        positionI: 'foo'
      });
    }, "If set, config.colorI must refer to an actual colorBuffer", "/src/item/class-item-mesh.litcoffee:Item.Mesh:constructor()\n  `config.colorI` 123 does not exist", function(oo3d) {
      return new Item.Mesh(oo3d, 0, {
        colorI: 123
      });
    }, function(oo3d) {
      oo3d.addPositionBuffer([1, 2, 3]);
      oo3d.addColorBuffer([1, 0, 0, 1, 0, 1, 0, 1]);
      return [oo3d];
    }, "A positionBuffer with one coordinate does not match a colorBuffer with two", "/src/item/class-item-mesh.litcoffee:Item.Mesh:constructor()\n  `config.positionI` mismatches config.colorI", function(oo3d) {
      return new Item.Mesh(oo3d, 0, {
        positionI: 1,
        colorI: 1
      });
    }, "If set, config.renderMode must be a recognised value", "/src/item/class-item-mesh.litcoffee:Item.Mesh:constructor()\n  `config.renderMode` ZERO is not recognised by WebGL", function(oo3d) {
      return new Item.Mesh(oo3d, 0, {
        renderMode: 'ZERO'
      });
    }, "If set, config.blend must be an array", "/src/item/class-item-mesh.litcoffee:Item.Mesh:constructor()\n  If set, `config.blend` must be array not number", function(oo3d) {
      return new Item.Mesh(oo3d, 0, {
        blend: 1
      });
    }, "config.blend[0] (for item.sBlend) must be a recognised value", "/src/item/class-item-mesh.litcoffee:Item.Mesh:constructor()\n  `config.blend[0]` is not recognised by WebGL", function(oo3d) {
      return new Item.Mesh(oo3d, 0, {
        blend: ['TRIANGLES']
      });
    }, "config.blend[1] (for item.dBlend) must be a recognised value", "/src/item/class-item-mesh.litcoffee:Item.Mesh:constructor()\n  `config.blend[1]` is not recognised by WebGL", function(oo3d) {
      return new Item.Mesh(oo3d, 0, {
        blend: ['ZERO']
      });
    }, "Item Constructor usage", tudor.equal, "`config` can be an empty object", '[object Item.Mesh]', function(oo3d) {
      var mesh;
      mesh = new Item.Mesh(oo3d, 0, {});
      return '' + mesh;
    }, "`item.matTransform` as expected", '1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1', function(oo3d) {
      var mesh, n;
      mesh = new Item.Mesh(oo3d, 0, {});
      return ((function() {
        var j, len, ref, results;
        ref = mesh.matTransform;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          n = ref[j];
          results.push('' + n);
        }
        return results;
      })()).join(' ');
    }, "`mesh.rX` `mesh.rY` `mesh.rZ` as expected", '0 0 0', function(oo3d) {
      var mesh;
      mesh = new Item.Mesh(oo3d, 0, {});
      return [mesh.rX, mesh.rY, mesh.rZ].join(' ');
    }, "`mesh.sX` `mesh.sY` `mesh.sZ` as expected", '1 1 1', function(oo3d) {
      var mesh;
      mesh = new Item.Mesh(oo3d, 0, {});
      return [mesh.sX, mesh.sY, mesh.sZ].join(' ');
    }, "`mesh.tX` `mesh.tY` `mesh.tZ` as expected", '0 0 0', function(oo3d) {
      var mesh;
      mesh = new Item.Mesh(oo3d, 0, {});
      return [mesh.tX, mesh.tY, mesh.tZ].join(' ');
    }, "Item.Mesh Constructor usage", "Complete set of `config` defaults", 'TRIANGLESnullnull', function(oo3d) {
      var mesh;
      mesh = new Item.Mesh(oo3d, 0, {
        positionI: 0,
        colorI: 0,
        renderMode: null,
        blend: null
      });
      return mesh.renderMode + (ªtype(mesh.sBlend)) + (ªtype(mesh.dBlend));
    }
  ]);

  tudor.add([
    "06 Item.Camera Constructor", tudor.is, "(Mock an `Oo3d` instance)", function() {
      var CanvasMock, oo3d;
      CanvasMock = (function() {
        function CanvasMock() {}

        CanvasMock.prototype.width = 2;

        CanvasMock.prototype.height = 1;

        CanvasMock.prototype.toString = function() {
          return '[object HTMLCanvasElement]';
        };

        CanvasMock.prototype.getContext = function() {
          return {
            createBuffer: function() {
              return {};
            },
            bindBuffer: function() {},
            bufferData: function() {},
            clearColor: function() {},
            enable: function() {},
            depthFunc: function() {},
            scissor: function() {},
            clear: function() {},
            TRIANGLES: 4
          };
        };

        return CanvasMock;

      })();
      oo3d = new Main({
        $main: new CanvasMock
      });
      return [oo3d];
    }, "The class and instance are expected types", "The class is a function", ªF, function() {
      return Item.Camera;
    }, "`new` returns an object", ªO, function(oo3d) {
      return new Item.Camera(oo3d, 0);
    }, "Item Constructor exceptions", tudor["throw"], "`config.main` must be an object", "/src/item/base-item.litcoffee:Item:constructor()\n  `main` is number not object", function(oo3d) {
      return new Item.Camera(123);
    }, "`config.main` must be an Oo3d instance", "/src/item/base-item.litcoffee:Item:constructor()\n  `main` is '[object Object]' not '[object Oo3d]'", function(oo3d) {
      return new Item.Camera({});
    }, "`index` must be a number", "/src/item/base-item.litcoffee:Item:constructor()\n  `index` is boolean not number", function(oo3d) {
      return new Item.Camera(oo3d, true);
    }, "`index` must be an integer", "/src/item/base-item.litcoffee:Item:constructor()\n  `index` is 3.5 not 0 or a positive integer below 2^53", function(oo3d) {
      return new Item.Camera(oo3d, 3.5);
    }, "`index` must be positive", "/src/item/base-item.litcoffee:Item:constructor()\n  `index` is -44 not 0 or a positive integer below 2^53", function(oo3d) {
      return new Item.Camera(oo3d, -44);
    }, "`index` must be below 2^53", "/src/item/base-item.litcoffee:Item:constructor()\n  `index` is 9007199254740992 not 0 or a positive integer below 2^53", function(oo3d) {
      return new Item.Camera(oo3d, 9007199254740992);
    }, "`config` must be an object", "/src/item/base-item.litcoffee:Item:constructor()\n  Optional `config` is date not object", function(oo3d) {
      return new Item.Camera(oo3d, 0, new Date);
    }, "Item.Camera Constructor exceptions", "If set, config.fovy must be a number", "/src/item/class-item-camera.litcoffee:Item.Camera:constructor()\n  Optional `config.fovy` is string not number", function(oo3d) {
      return new Item.Camera(oo3d, 0, {
        fovy: 'abc'
      });
    }, "If set, config.fovy must be greater than zero", "/src/item/class-item-camera.litcoffee:Item.Camera:constructor()\n  Optional `config.fovy` is 0 not greater than zero", function(oo3d) {
      return new Item.Camera(oo3d, 0, {
        fovy: 0
      });
    }, "If set, config.aspect must be a number", "/src/item/class-item-camera.litcoffee:Item.Camera:constructor()\n  Optional `config.aspect` is array not number", function(oo3d) {
      return new Item.Camera(oo3d, 0, {
        aspect: []
      });
    }, "If set, config.aspect must be greater than zero", "/src/item/class-item-camera.litcoffee:Item.Camera:constructor()\n  Optional `config.aspect` is -3 not greater than zero", function(oo3d) {
      return new Item.Camera(oo3d, 0, {
        aspect: -3
      });
    }, "Item Constructor usage", tudor.equal, "`config` can be an empty object", '[object Item.Camera]', function(oo3d) {
      var camera;
      camera = new Item.Camera(oo3d, 0, {});
      return '' + camera;
    }, "`item.matTransform` as expected", '1 0 0 0 0 1 0 0 0 0 1 0 0 0 -4 1', function(oo3d) {
      var camera, n;
      camera = new Item.Camera(oo3d, 0, {});
      return ((function() {
        var j, len, ref, results;
        ref = camera.matTransform;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          n = ref[j];
          results.push('' + n);
        }
        return results;
      })()).join(' ');
    }, "`camera.rX` `camera.rY` `camera.rZ` as expected", '0 0 0', function(oo3d) {
      var camera;
      camera = new Item.Camera(oo3d, 0, {});
      return [camera.rX, camera.rY, camera.rZ].join(' ');
    }, "`camera.sX` `camera.sY` `camera.sZ` as expected", '1 1 1', function(oo3d) {
      var camera;
      camera = new Item.Camera(oo3d, 0, {});
      return [camera.sX, camera.sY, camera.sZ].join(' ');
    }, "`camera.tX` `camera.tY` `camera.tZ` as expected", '0 0 -4', function(oo3d) {
      var camera;
      camera = new Item.Camera(oo3d, 0, {});
      return [camera.tX, camera.tY, camera.tZ].join(' ');
    }, "Item.Camera Constructor usage", "Complete set of `config` defaults", '0.785398163 2', function(oo3d) {
      var camera;
      camera = new Item.Camera(oo3d, 0);
      return camera.fovy + ' ' + camera.aspect;
    }
  ]);

}).call(this);
