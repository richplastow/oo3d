// Generated by CoffeeScript 1.9.2

/*! Oo3d 0.0.50 //// MIT Licence //// http://oo3d.richplastow.com/ */

(function() {
  var Item, Layer, Main, Nwang, Program, Renderer, Tudor, mat4, pick, tudor, uri, ª, ªA, ªB, ªC, ªE, ªF, ªMAX, ªMIN, ªN, ªO, ªR, ªS, ªU, ªV, ªW, ªX, ªex, ªhas, ªis, ªisU, ªredefine, ªtype, ªuid,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  ªC = 'Oo3d';

  ªV = '0.0.50';

  ªA = 'array';

  ªB = 'boolean';

  ªE = 'error';

  ªF = 'function';

  ªN = 'number';

  ªO = 'object';

  ªR = 'regexp';

  ªS = 'string';

  ªU = 'undefined';

  ªX = 'null';

  ªMAX = 9007199254740991;

  ªMIN = -9007199254740991;

  ªW = this;

  ª = console.log.bind(console);

  ªex = function(x, a, b) {
    var pos;
    if (-1 === (pos = a.indexOf(x))) {
      return x;
    } else {
      return b.charAt(pos);
    }
  };

  ªis = function(c, t, f) {
    if (t == null) {
      t = true;
    }
    if (f == null) {
      f = false;
    }
    if (c) {
      return t;
    } else {
      return f;
    }
  };

  ªhas = function(h, n, t, f) {
    if (t == null) {
      t = true;
    }
    if (f == null) {
      f = false;
    }
    if (-1 !== h.indexOf(n)) {
      return t;
    } else {
      return f;
    }
  };

  ªtype = function(x) {
    return {}.toString.call(x).match(/\s([a-z0-9]+)/i)[1].toLowerCase();
  };

  ªisU = function(x) {
    return ªU === typeof x;
  };

  ªuid = function(p) {
    return p + '_' + (Math.random() + '1111111111111111').slice(2, 18);
  };

  ªredefine = function(obj, name, value, kind) {
    switch (kind) {
      case 'constant':
        return Object.defineProperty(obj, name, {
          value: value,
          enumerable: true
        });
      case 'private':
        return Object.defineProperty(obj, name, {
          value: value,
          enumerable: false
        });
    }
  };

  Layer = (function() {
    Layer.prototype.C = 'Layer';

    Layer.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function Layer(main1, config) {
      var float, i, j, len, ref;
      this.main = main1;
      if (config == null) {
        config = {};
      }
      if (ªO !== ªtype(config)) {
        throw TypeError("`config` must be object not " + (ªtype(config)));
      }
      if (ªO !== ªtype(this.main)) {
        throw TypeError("`main` must be object not " + (ªtype(this.main)));
      }
      if ('[object Oo3d]' !== '' + this.main) {
        throw TypeError("`main` must be [object Oo3d] not " + this.main);
      }
      if (!config.rendererIs) {
        this.renderers = [];
      } else if ('uint16array' !== ªtype(config.rendererIs)) {
        throw TypeError("If set, config.rendererIs must be Uint16Array not " + (ªtype(config.rendererIs)));
      } else {
        this.renderers = (function() {
          var j, len, ref, results;
          ref = config.rendererIs;
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            i = ref[j];
            results.push(this.main.renderers[i] || (function() {
              throw RangeError("No such index " + i + " in main.renderers");
            })());
          }
          return results;
        }).call(this);
      }
      this.scissor = config.scissor;
      if (!this.scissor) {
        this.scissor = null;
      } else if ('float32array' !== ªtype(this.scissor)) {
        throw TypeError("If set, config.scissor must be Float32Array not " + (ªtype(this.scissor)));
      } else if (4 !== this.scissor.length) {
        throw RangeError("If set, config.scissor.length must be 4 not " + this.scissor.length);
      } else {
        ref = this.scissor;
        for (j = 0, len = ref.length; j < len; j++) {
          float = ref[j];
          if (0 > float || 1 < float) {
            throw RangeError("config.scissor contains out-of-range " + float);
          }
        }
      }
    }

    Layer.prototype.render = function() {
      var j, len, ref, renderer, results;
      if (this.scissor) {
        this.main.gl.scissor(this.scissor[0] * this.main.$main.width, this.scissor[1] * this.main.$main.height, this.scissor[2] * this.main.$main.width, this.scissor[3] * this.main.$main.height);
      }
      ref = this.renderers;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        renderer = ref[j];
        results.push(renderer.render());
      }
      return results;
    };

    return Layer;

  })();

  Main = (function() {
    Main.prototype.C = "/src/class-main.litcoffee:" + ªC;

    Main.prototype.toString = function() {
      return "[object " + ªC + "]";
    };

    function Main(config) {
      var M, k, v;
      if (config == null) {
        config = {};
      }
      M = this.C + ":constructor()\n  ";
      if (ªO !== ªtype(config)) {
        throw TypeError(M + "Optional `config` is " + (ªtype(config)) + " not object");
      }
      for (k in config) {
        v = config[k];
        this[k] = v;
      }
      if (!Nwang) {
        throw Error(M + "Dependency 'Nwang' could not be found");
      }
      this.nwang = new Nwang;
      this.$main = config.$main || null;
      if (this.$main && '[object HTMLCanvasElement]' !== '' + this.$main) {
        throw TypeError(M + "Optional `config.$main` is " + (ªtype(this.$main)) + " not HTMLCanvasElement");
      }
      this.oT = config.oT || 'trs';
      if (!{
        'trs': 1,
        'rts': 1,
        'srt': 1
      }[this.oT]) {
        throw RangeError(M + "Optional `config.oT` is not 'trs|rts|srt'");
      }
      if (!config.bkgnd) {
        this.bkgndR = this.bkgndG = this.bkgndB = 0.25;
        this.bkgndA = 1;
      } else if ('float32array' === ªtype(config.bkgnd)) {
        if (4 !== config.bkgnd.length) {
          throw Error(M + "If set `config.bkgnd` must contain four elements");
        }
        this.bkgndR = config.bkgnd[0] || 0;
        this.bkgndG = config.bkgnd[1] || 0;
        this.bkgndB = config.bkgnd[2] || 0;
        this.bkgndA = config.bkgnd[3] || 0;
        if (0 > this.bkgndR || this.bkgndR > 1) {
          throw RangeError(M + "`config.bkgnd[0]` (red) is not within range 0-1");
        }
        if (0 > this.bkgndG || this.bkgndG > 1) {
          throw RangeError(M + "`config.bkgnd[1]` (green) is not within range 0-1");
        }
        if (0 > this.bkgndB || this.bkgndB > 1) {
          throw RangeError(M + "`config.bkgnd[2]` (blue) is not within range 0-1");
        }
        if (0 > this.bkgndA || this.bkgndA > 1) {
          throw RangeError(M + "`config.bkgnd[3]` (alpha) is not within range 0-1");
        }
      } else {
        throw TypeError(M + "Optional `config.bkgnd` is " + (ªtype(config.bkgnd)) + " not float32array");
      }
      this.gl = null;
      this.cameras = [];
      this.programs = [];
      this.renderers = [];
      this.layers = [];
      this.meshes = [];
      this.positionBuffers = [];
      this.colorBuffers = [];
      if (this.$main) {
        this.initGL();
        if (this.gl) {
          this.initCanvas();
          this.initBuffers();
        }
      }
    }

    Main.prototype.initGL = function() {
      var M, ctx, j, len, ref;
      M = this.C + ":initGL()\n  ";
      try {
        ref = ['webgl', 'experimental-webgl'];
        for (j = 0, len = ref.length; j < len; j++) {
          ctx = ref[j];
          this.gl = this.$main.getContext(ctx, {
            preserveDrawingBuffer: true
          });
          if (this.gl) {
            break;
          }
        }
      } catch (_error) {

      }
      if (!this.gl) {
        throw Error(M + "Unable to initialize WebGL. Your browser may not support it.");
      }
    };

    Main.prototype.initCanvas = function() {
      this.gl.clearColor(this.bkgndR, this.bkgndG, this.bkgndB, this.bkgndA);
      this.gl.enable(this.gl.DEPTH_TEST);
      this.gl.enable(this.gl.SCISSOR_TEST);
      this.gl.depthFunc(this.gl.LEQUAL);
      this.gl.scissor(0, 0, this.$main.width, this.$main.height);
      this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
      return this.gl.enable(this.gl.VERTEX_PROGRAM_POINT_SIZE);
    };

    Main.prototype.initBuffers = function() {
      this.addPositionBuffer([]);
      return this.addColorBuffer([]);
    };

    Main.prototype.cleanUp = function() {};

    Main.prototype.edit = function(target, set, delta) {
      this.meshes[target].edit(set, delta);
      return this;
    };

    Main.prototype.addMesh = function(config) {
      var index;
      index = this.meshes.length;
      if (!config.oT) {
        config.oT = this.oT;
      }
      this.meshes[index] = new Item.Mesh(this, index, config);
      return index;
    };

    Main.prototype.addCamera = function(config) {
      var index;
      index = this.cameras.length;
      this.cameras[index] = new Item.Camera(this, index, config);
      return index;
    };

    Main.prototype.addProgram = function(config) {
      var index;
      if (ªO !== ªtype(config)) {
        throw TypeError("`config` must be object not " + (ªtype(config)));
      }
      if (ªS !== ªtype(config.subclass)) {
        throw TypeError("`config.subclass` must be string not " + (ªtype(config.subclass)));
      }
      if (!Program[config.subclass]) {
        throw RangeError("`Program." + config.subclass + "` does not exist");
      }
      index = this.programs.length;
      this.programs[index] = new Program[config.subclass](this, config);
      return index;
    };

    Main.prototype.addRenderer = function(config) {
      var index;
      index = this.renderers.length;
      this.renderers[index] = new Renderer(this, config);
      return index;
    };

    Main.prototype.addLayer = function(config) {
      var index;
      index = this.layers.length;
      this.layers[index] = new Layer(this, config);
      return index;
    };

    Main.prototype.addPositionBuffer = function(positions) {
      var index;
      index = this.positionBuffers.length;
      if (ªA !== ªtype(positions)) {
        throw Error("`positions` must be an array not " + (ªtype(positions)));
      } else if (positions.length % 3) {
        throw Error("`positions.length` must be divisible by 3");
      }
      this.positionBuffers[index] = this.gl.createBuffer();
      this.positionBuffers[index].count = positions.length / 3;
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffers[index]);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(positions), this.gl.STATIC_DRAW);
      return index;
    };

    Main.prototype.addColorBuffer = function(colors) {
      var index;
      index = this.colorBuffers.length;
      if (ªA !== ªtype(colors)) {
        throw Error("`colors` must be an array not " + (ªtype(colors)));
      } else if (colors.length % 4) {
        throw Error("`colors.length` must be divisible by 4");
      }
      this.colorBuffers[index] = this.gl.createBuffer();
      this.colorBuffers[index].count = colors.length / 4;
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffers[index]);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(colors), this.gl.STATIC_DRAW);
      return index;
    };

    Main.prototype.rotate = function(x, y, z, targetIndex) {
      var c, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, mat, s, target, x0, y0, z0;
      target = this.meshes[targetIndex] || this.cameras[0];
      mat = target.mT;
      x0 = 0 === x;
      y0 = 0 === y;
      z0 = 0 === z;
      if (x0 && y0 && z0) {
        return this;
      } else if (y0 && z0) {
        s = Math.sin(x);
        c = Math.cos(x);
        m10 = mat[4];
        m11 = mat[5];
        m12 = mat[6];
        m13 = mat[7];
        m20 = mat[8];
        m21 = mat[9];
        m22 = mat[10];
        m23 = mat[11];
        mat[4] = m10 * c + m20 * s;
        mat[5] = m11 * c + m21 * s;
        mat[6] = m12 * c + m22 * s;
        mat[7] = m13 * c + m23 * s;
        mat[8] = m20 * c - m10 * s;
        mat[9] = m21 * c - m11 * s;
        mat[10] = m22 * c - m12 * s;
        mat[11] = m23 * c - m13 * s;
        target.rX += x;
      } else if (x0 && z0) {
        s = Math.sin(y);
        c = Math.cos(y);
        m00 = mat[0];
        m01 = mat[1];
        m02 = mat[2];
        m03 = mat[3];
        m20 = mat[8];
        m21 = mat[9];
        m22 = mat[10];
        m23 = mat[11];
        mat[0] = m00 * c - m20 * s;
        mat[1] = m01 * c - m21 * s;
        mat[2] = m02 * c - m22 * s;
        mat[3] = m03 * c - m23 * s;
        mat[8] = m00 * s + m20 * c;
        mat[9] = m01 * s + m21 * c;
        mat[10] = m02 * s + m22 * c;
        mat[11] = m03 * s + m23 * c;
        target.rY += y;
      } else if (x0 && y0) {
        s = Math.sin(z);
        c = Math.cos(z);
        m00 = mat[0];
        m01 = mat[1];
        m02 = mat[2];
        m03 = mat[3];
        m10 = mat[4];
        m11 = mat[5];
        m12 = mat[6];
        m13 = mat[7];
        mat[0] = m00 * c + m10 * s;
        mat[1] = m01 * c + m11 * s;
        mat[2] = m02 * c + m12 * s;
        mat[3] = m03 * c + m13 * s;
        mat[4] = m10 * c - m00 * s;
        mat[5] = m11 * c - m01 * s;
        mat[6] = m12 * c - m02 * s;
        mat[7] = m13 * c - m03 * s;
        target.rZ += z;
      } else {
        this.rotate(x, 0, 0, targetIndex);
        this.rotate(0, y, 0, targetIndex);
        this.rotate(0, 0, z, targetIndex);
      }
      if (target === this.cameras[0]) {
        this.cameras[0].updateCamera();
      }
      return this;
    };

    Main.prototype.scale = function(x, y, z, targetIndex) {
      var mat, target, x1, y1, z1;
      target = this.meshes[targetIndex] || this.cameras[0];
      mat = target.mT;
      x1 = 1 === x;
      y1 = 1 === y;
      z1 = 1 === z;
      if (!x1) {
        mat[0] *= x;
        mat[1] *= x;
        mat[2] *= x;
        mat[3] *= x;
        target.sX *= x;
      }
      if (!y1) {
        mat[4] *= y;
        mat[5] *= y;
        mat[6] *= y;
        mat[7] *= y;
        target.sY *= y;
      }
      if (!z1) {
        mat[8] *= z;
        mat[9] *= z;
        mat[10] *= z;
        mat[11] *= z;
        target.sZ *= z;
      }
      if (target === this.cameras[0]) {
        this.cameras[0].updateCamera();
      }
      return this;
    };

    Main.prototype.translate = function(x, y, z, targetIndex) {
      var mat, target, x0, y0, z0;
      target = this.meshes[targetIndex] || this.cameras[0];
      mat = target.mT;
      x0 = 0 === x;
      y0 = 0 === y;
      z0 = 0 === z;
      if (x0 && y0 && z0) {
        return this;
      } else if (y0 && z0) {
        mat[12] += mat[0] * x;
        mat[13] += mat[1] * x;
        mat[14] += mat[2] * x;
        mat[15] += mat[3] * x;
        target.tX += x;
      } else if (x0 && z0) {
        mat[12] += mat[4] * y;
        mat[13] += mat[5] * y;
        mat[14] += mat[6] * y;
        mat[15] += mat[7] * y;
        target.tY += y;
      } else if (x0 && y0) {
        mat[12] += mat[8] * z;
        mat[13] += mat[9] * z;
        mat[14] += mat[10] * z;
        mat[15] += mat[11] * z;
        target.tZ += z;
      } else {
        mat[12] += mat[0] * x + mat[4] * y + mat[8] * z;
        mat[13] += mat[1] * x + mat[5] * y + mat[9] * z;
        mat[14] += mat[2] * x + mat[6] * y + mat[10] * z;
        mat[15] += mat[3] * x + mat[7] * y + mat[11] * z;
        target.tX += x;
        target.tY += y;
        target.tZ += z;
      }
      if (target === this.cameras[0]) {
        this.cameras[0].updateCamera();
      }
      return this;
    };

    Main.prototype.resetTransform = function(targetIndex) {
      var mat, target;
      target = this.meshes[targetIndex] || this.cameras[0];
      mat = target.mT;
      target.rX = target.rY = target.rZ = 0;
      target.sX = target.sY = target.sZ = 1;
      target.tX = target.tY = target.tZ = 0;
      target.mT = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
      if (target === this.cameras[0]) {
        this.cameras[0].tZ = -4;
        this.cameras[0].mT[14] = -4;
        this.cameras[0].updateCamera();
      }
      return this;
    };

    Main.prototype.setRenderMode = function(renderMode, targetIndex) {
      if (!this.meshes[targetIndex]) {
        return;
      }
      this.meshes[targetIndex].renderMode = renderMode;
      return this;
    };

    Main.prototype.getColorAt = function(x, y) {
      var pixels;
      pixels = new Uint8Array(4);
      this.gl.readPixels(x, y, 1, 1, this.gl.RGBA, this.gl.UNSIGNED_BYTE, pixels);
      return pixels;
    };

    Main.prototype.getMeshIByColor = function(color) {
      return pick.colorToIndex(color);
    };

    Main.prototype.getCameraSnapshot = function(cameraI) {
      var camera, mat;
      camera = this.cameras[cameraI];
      mat = new Float32Array(16);
      mat.set(camera.mT);
      return {
        mat: mat,
        rX: camera.rX,
        rY: camera.rY,
        rZ: camera.rZ,
        sX: camera.sX,
        sY: camera.sY,
        sZ: camera.sZ,
        tX: camera.tX,
        tY: camera.tY,
        tZ: camera.tZ
      };
    };

    Main.prototype.getMeshSnapshot = function(meshI) {
      var item, mat;
      item = this.meshes[meshI];
      mat = new Float32Array(16);
      mat.set(item.mT);
      return {
        mat: mat,
        rX: item.rX,
        rY: item.rY,
        rZ: item.rZ,
        sX: item.sX,
        sY: item.sY,
        sZ: item.sZ,
        tX: item.tX,
        tY: item.tY,
        tZ: item.tZ
      };
    };

    Main.prototype.setCameraSnapshot = function(snapshot, cameraI) {
      var camera;
      camera = this.cameras[cameraI];
      camera.mT = new Float32Array(16);
      camera.mT.set(snapshot.mat);
      camera.rX = snapshot.rX;
      camera.rY = snapshot.rY;
      camera.rZ = snapshot.rZ;
      camera.sX = snapshot.sX;
      camera.sY = snapshot.sY;
      camera.sZ = snapshot.sZ;
      camera.tX = snapshot.tX;
      camera.tY = snapshot.tY;
      camera.tZ = snapshot.tZ;
      return this;
    };

    Main.prototype.setMeshSnapshot = function(snapshot, meshI) {
      var item;
      item = this.meshes[meshI];
      item.mT = new Float32Array(16);
      item.mT.set(snapshot.mat);
      item.rX = snapshot.rX;
      item.rY = snapshot.rY;
      item.rZ = snapshot.rZ;
      item.sX = snapshot.sX;
      item.sY = snapshot.sY;
      item.sZ = snapshot.sZ;
      item.tX = snapshot.tX;
      item.tY = snapshot.tY;
      item.tZ = snapshot.tZ;
      return this;
    };

    Main.prototype.render = function() {
      var j, layer, len, ref;
      if (!this.gl) {
        throw Error("The WebGL rendering context is " + (ªtype(this.gl)));
      }
      this.gl.clearColor(this.bkgndR, this.bkgndG, this.bkgndB, this.bkgndA);
      this.gl.scissor(0, 0, this.$main.width, this.$main.height);
      this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
      ref = this.layers;
      for (j = 0, len = ref.length; j < len; j++) {
        layer = ref[j];
        layer.render();
      }
      return this;
    };

    return Main;

  })();

  if (ªF === typeof define && define.amd) {
    define(function() {
      return Main;
    });
  } else if (ªO === typeof module && module && module.exports) {
    module.exports = Main;
  } else {
    ªW[ªC] = Main;
  }

  if (ªF === typeof define && define.amd) {

  } else if (ªO === typeof module && module && module.exports) {
    Nwang = require('nwang');
  } else {
    Nwang = window.Nwang;
  }

  mat4 = {};

  mat4.multiply = function(a, b) {
    var a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23, a30, a31, a32, a33, b0, b1, b2, b3, out;
    out = new Float32Array(16);
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    a30 = a[12];
    a31 = a[13];
    a32 = a[14];
    a33 = a[15];
    b0 = b[0];
    b1 = b[1];
    b2 = b[2];
    b3 = b[3];
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return out;
  };

  mat4.perspective = function(fovy, aspect, near, far) {
    var f, nf, out;
    f = 1.0 / Math.tan(fovy / 2);
    nf = 1 / (near - far);
    out = new Float32Array(16);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (2 * far * near) * nf;
    out[15] = 0;
    return out;
  };

  mat4.rotateX = function(a, rad) {
    var a10, a11, a12, a13, a20, a21, a22, a23, c, s;
    s = Math.sin(rad);
    c = Math.cos(rad);
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    a[4] = a10 * c + a20 * s;
    a[5] = a11 * c + a21 * s;
    a[6] = a12 * c + a22 * s;
    a[7] = a13 * c + a23 * s;
    a[8] = a20 * c - a10 * s;
    a[9] = a21 * c - a11 * s;
    a[10] = a22 * c - a12 * s;
    a[11] = a23 * c - a13 * s;
    return a;
  };

  mat4.rotateY = function(a, rad) {
    var a00, a01, a02, a03, a20, a21, a22, a23, c, s;
    s = Math.sin(rad);
    c = Math.cos(rad);
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    a[0] = a00 * c - a20 * s;
    a[1] = a01 * c - a21 * s;
    a[2] = a02 * c - a22 * s;
    a[3] = a03 * c - a23 * s;
    a[8] = a00 * s + a20 * c;
    a[9] = a01 * s + a21 * c;
    a[10] = a02 * s + a22 * c;
    a[11] = a03 * s + a23 * c;
    return a;
  };

  mat4.rotateZ = function(a, rad) {
    var a00, a01, a02, a03, a10, a11, a12, a13, c, s;
    s = Math.sin(rad);
    c = Math.cos(rad);
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a[0] = a00 * c + a10 * s;
    a[1] = a01 * c + a11 * s;
    a[2] = a02 * c + a12 * s;
    a[3] = a03 * c + a13 * s;
    a[4] = a10 * c - a00 * s;
    a[5] = a11 * c - a01 * s;
    a[6] = a12 * c - a02 * s;
    a[7] = a13 * c - a03 * s;
    return a;
  };

  mat4.translate = function(a, x, y, z) {
    a[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    a[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    a[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    a[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    return a;
  };

  mat4.ortho = function(left, right, bottom, top, near, far) {
    var bt, lr, nf, out;
    lr = 1 / (left - right);
    bt = 1 / (bottom - top);
    nf = 1 / (near - far);
    out = new Float32Array(16);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
  };

  mat4.makeTranslation = function(tx, ty, tz) {
    return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, tz, 1]);
  };

  mat4.makeXRotation = function(angleInRadians) {
    var c, s;
    c = Math.cos(angleInRadians);
    s = Math.sin(angleInRadians);
    return new Float32Array([1, 0, 0, 0, 0, c, s, 0, 0, -s, c, 0, 0, 0, 0, 1]);
  };

  mat4.makeYRotation = function(angleInRadians) {
    var c, s;
    c = Math.cos(angleInRadians);
    s = Math.sin(angleInRadians);
    return new Float32Array([c, 0, -s, 0, 0, 1, 0, 0, s, 0, c, 0, 0, 0, 0, 1]);
  };

  mat4.makeZRotation = function(angleInRadians) {
    var c, s;
    c = Math.cos(angleInRadians);
    s = Math.sin(angleInRadians);
    return new Float32Array([c, s, 0, 0, -s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
  };

  mat4.makeScale = function(sx, sy, sz) {
    return new Float32Array([sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1]);
  };

  mat4.makeProjection = function(width, height, depth) {
    return new Float32Array([2 / width, 0, 0, 0, 0, -2 / height, 0, 0, 0, 0, 2 / depth, 0, -1, 1, 0, 1]);
  };

  pick = {};

  pick.indexToColor = function(index) {
    var b, g, i, r;
    i = ('00000000000000000000000' + index.toString(2)).slice(-24).split('');
    r = "" + i[23] + i[20] + i[17] + i[14] + i[11] + i[8] + i[5] + i[2];
    g = "" + i[22] + i[19] + i[16] + i[13] + i[10] + i[7] + i[4] + i[1];
    b = "" + i[21] + i[18] + i[15] + i[12] + i[9] + i[6] + i[3] + i[0];
    return new Float32Array([parseInt(r, 2) / 255, parseInt(g, 2) / 255, parseInt(b, 2) / 255, 1.0]);
  };

  pick.colorToIndex = function(color) {
    var b, g, i, r;
    if (0 === (0x1f & color[0]) + (0x1f & color[1]) + (0x1f & color[2])) {
      return pick.qikColorToIndex(color);
    }
    r = ('0000000' + color[0].toString(2)).slice(-8).split('');
    g = ('0000000' + color[1].toString(2)).slice(-8).split('');
    b = ('0000000' + color[2].toString(2)).slice(-8).split('');
    i = ("" + b[7] + g[7] + r[7]) + ("" + b[6] + g[6] + r[6]) + ("" + b[5] + g[5] + r[5]) + ("" + b[4] + g[4] + r[4]) + ("" + b[3] + g[3] + r[3]) + ("" + b[2] + g[2] + r[2]) + ("" + b[1] + g[1] + r[1]) + ("" + b[0] + g[0] + r[0]);
    return parseInt(i, 2);
  };

  pick.qikColorToIndex = function(color) {
    var b, g, i, r;
    r = (color[0].toString(2)).split('');
    g = (color[1].toString(2)).split('');
    b = (color[2].toString(2)).split('');
    i = ("" + (b[2] || 0) + (g[2] || 0) + (r[2] || 0)) + ("" + (b[1] || 0) + (g[1] || 0) + (r[1] || 0)) + ("" + b[0] + g[0] + r[0]);
    return parseInt(i, 2);
  };

  uri = {};

  uri.r2Tenmin = function(r) {
    return Math.round(r * uri.RESOLUTION_R);
  };

  uri.tenmin2r = function(r) {
    return r / uri.RESOLUTION_R;
  };

  uri.r2uri = function(radians) {
    var PI2, c1, c1i, c2, c2i, tenmin;
    PI2 = Math.PI * 2;
    radians = radians % PI2;
    if (0 > radians) {
      radians += PI2;
    }
    tenmin = uri.r2Tenmin(radians);
    c1 = uri.USUAL_R2URI[tenmin];
    if (c1) {
      return c1;
    }
    c1i = tenmin % 36;
    c2i = (tenmin - c1i) / 36;
    c1 = "0123456789abcdefghijklmnopqrstuvwxyz"[c1i];
    c2 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWX"[c2i];
    return '' + c1 + c2;
  };

  uri.s2uri = function(s) {
    var c1, c2, c3, m, n, nM64, neg;
    if (0 > s) {
      neg = true;
      s = Math.abs(s);
    }
    if (0.0001 > s) {
      return 'A';
    }
    if (0.001 > s) {
      m = neg ? 'a' : 'p';
      n = s * 10000000;
    } else if (0.01 > s) {
      m = neg ? 'b' : 'o';
      n = s * 1000000;
    } else if (0.1 > s) {
      m = neg ? 'c' : 'n';
      n = s * 100000;
    } else if (1 > s) {
      m = neg ? 'd' : 'm';
      n = s * 10000;
    } else if (10 > s) {
      m = neg ? 'e' : 'l';
      n = s * 1000;
    } else if (100 > s) {
      m = neg ? 'f' : 'k';
      n = s * 100;
    } else if (1000 > s) {
      m = neg ? 'g' : 'j';
      n = s * 10;
    } else if (10000 > s) {
      m = neg ? 'h' : 'i';
      n = s;
    } else {
      return 'Z';
    }
    n = n / 4;
    n = Math.floor(n);
    c1 = uri.USUAL_S2URI[m + n];
    if (c1) {
      return c1;
    }
    nM64 = n % 64;
    c1 = m;
    c2 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-"[nM64];
    c3 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-"[(n - nM64) / 64];
    if (ªU === typeof c1 || ªU === typeof c2 || ªU === typeof c3) {
      ª('UNDEFINED RESULT s2uri(' + s + ')', n, nM64, (n - nM64) / 64, '' + c1 + c2 + c3);
    }
    return c1 + c2 + c3;
  };

  uri.t2uri = function(t) {
    var c1, c2, c3, m, n, nM64, neg;
    if (0 > t) {
      neg = true;
      t = Math.abs(t);
    }
    if (0.0001 > t) {
      return 'A';
    }
    if (0.001 > t) {
      m = neg ? 'a' : 'p';
      n = t * 10000000;
    } else if (0.01 > t) {
      m = neg ? 'b' : 'o';
      n = t * 1000000;
    } else if (0.1 > t) {
      m = neg ? 'c' : 'n';
      n = t * 100000;
    } else if (1 > t) {
      m = neg ? 'd' : 'm';
      n = t * 10000;
    } else if (10 > t) {
      m = neg ? 'e' : 'l';
      n = t * 1000;
    } else if (100 > t) {
      m = neg ? 'f' : 'k';
      n = t * 100;
    } else if (1000 > t) {
      m = neg ? 'g' : 'j';
      n = t * 10;
    } else if (10000 > t) {
      m = neg ? 'h' : 'i';
      n = t;
    } else {
      return 'Z';
    }
    n = n / 4;
    n = Math.floor(n);
    c1 = uri.USUAL_T2URI[m + n];
    if (c1) {
      return c1;
    }
    nM64 = n % 64;
    c1 = m;
    c2 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-"[nM64];
    c3 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-"[(n - nM64) / 64];
    if (ªU === typeof c1 || ªU === typeof c2 || ªU === typeof c3) {
      ª('UNDEFINED RESULT t2uri(' + t + ')', n, nM64, (n - nM64) / 64, '' + c1 + c2 + c3);
    }
    return c1 + c2 + c3;
  };

  uri.uri2r = function(str) {
    var c1, c2, usual;
    usual = uri.USUAL_URI2R[str];
    if (ªN === typeof usual) {
      return uri.tenmin2r(usual);
    }
    c1 = uri.B64DECODE[str[0]];
    c2 = uri.B64DECODE[str[1]];
    return uri.tenmin2r(c1 * 60 + c2);
  };

  uri.uri2s = function(str) {
    var c1, c2, c3, usual;
    usual = uri.USUAL_URI2S[str];
    if (ªN === typeof usual) {
      return usual;
    }
    c1 = uri.MULTIPLIER[str[0]];
    c2 = uri.B64DECODE[str[1]];
    c3 = uri.B64DECODE[str[2]];
    return c1 * (c2 + c3 * 64 * 4);
  };

  uri.uri2t = function(str) {
    var c1, c2, c3, usual;
    usual = uri.USUAL_URI2T[str];
    if (ªN === typeof usual) {
      return usual;
    }
    c1 = uri.MULTIPLIER[str[0]];
    c2 = uri.B64DECODE[str[1]];
    c3 = uri.B64DECODE[str[2]];
    return c1 * (c2 + c3 * 64 * 4);
  };

  uri.RESOLUTION_R = 1 / (Math.PI * 2 / 36 / 60);

  uri.USUAL_R2URI = (function() {
    var PI, out;
    PI = Math.PI;
    out = {};
    out[0] = 'A';
    out[uri.r2Tenmin(PI / 6.0)] = 'B';
    out[uri.r2Tenmin(PI / 4.0)] = 'C';
    out[uri.r2Tenmin(PI / 3.0)] = 'D';
    out[uri.r2Tenmin(PI * 0.5)] = 'E';
    out[uri.r2Tenmin(PI / 1.5)] = 'F';
    out[uri.r2Tenmin(PI * 0.75)] = 'G';
    out[uri.r2Tenmin(PI / 1.2)] = 'H';
    out[uri.r2Tenmin(PI)] = 'I';
    out[uri.r2Tenmin(PI / 6.0 + PI)] = 'J';
    out[uri.r2Tenmin(PI / 4.0 + PI)] = 'K';
    out[uri.r2Tenmin(PI / 3.0 + PI)] = 'L';
    out[uri.r2Tenmin(PI * 1.5)] = 'M';
    out[uri.r2Tenmin(PI / 1.5 + PI)] = 'N';
    out[uri.r2Tenmin(PI * 1.75)] = 'O';
    out[uri.r2Tenmin(PI / 1.2 + PI)] = 'P';
    out[uri.r2Tenmin(PI * 2.0)] = 'Q';
    return out;
  })();

  uri.USUAL_URI2R = (function() {
    var key, out, ref, val;
    out = {};
    ref = uri.USUAL_R2URI;
    for (key in ref) {
      val = ref[key];
      out[val] = +key;
    }
    return out;
  })();

  uri.USUAL_S2URI = {
    d1250: 'C',
    d2500: 'D',
    d5000: 'E',
    e1000: 'F',
    e2000: 'G',
    e4000: 'H',
    e8000: 'I',
    m1250: 'R',
    m2500: 'S',
    m5000: 'T',
    l1000: 'U',
    l2000: 'V',
    l4000: 'W',
    l8000: 'X'
  };

  uri.USUAL_URI2S = {
    A: 0,
    C: -0.125,
    D: -0.25,
    E: -0.5,
    F: -1,
    G: -2,
    H: -4,
    I: -8,
    R: 0.125,
    S: 0.25,
    T: 0.5,
    U: 1,
    V: 2,
    W: 4,
    X: 8,
    Z: 10000
  };

  uri.USUAL_T2URI = {
    d1250: 'C',
    d2500: 'D',
    d5000: 'E',
    e1000: 'F',
    e2000: 'G',
    e4000: 'H',
    e8000: 'I',
    m1250: 'R',
    m2500: 'S',
    m5000: 'T',
    l1000: 'U',
    l2000: 'V',
    l4000: 'W',
    l8000: 'X'
  };

  uri.USUAL_URI2T = {
    A: 0,
    C: -0.125,
    D: -0.25,
    E: -0.5,
    F: -1,
    G: -2,
    H: -4,
    I: -8,
    R: 0.125,
    S: 0.25,
    T: 0.5,
    U: 1,
    V: 2,
    W: 4,
    X: 8,
    Z: 10000
  };

  uri.MULTIPLIER = {
    a: -1 / 10000000,
    b: -1 / 1000000,
    c: -1 / 100000,
    d: -1 / 10000,
    e: -1 / 1000,
    f: -1 / 100,
    g: -1 / 10,
    h: -1,
    p: 1 / 10000000,
    o: 1 / 1000000,
    n: 1 / 100000,
    m: 1 / 10000,
    l: 1 / 1000,
    k: 1 / 100,
    j: 1 / 10,
    i: 1
  };

  uri.B64DECODE = (function() {
    var b64, i, j, out;
    out = {};
    b64 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-";
    for (i = j = 0; j <= 63; i = ++j) {
      out[b64[i]] = i;
    }
    return out;
  })();

  Item = (function() {
    var xx;

    Item.prototype.C = "/oo3d/src/item/base-item.litcoffee:Item";

    Item.prototype.toString = function() {
      return "[object Item]";
    };

    function Item(main1, index1, config) {
      var M;
      this.main = main1;
      this.index = index1;
      if (config == null) {
        config = {};
      }
      M = "/oo3d/src/item/base-item.litcoffee:Item:constructor()\n  ";
      if (ªO !== ªtype(config)) {
        throw TypeError(M + "Optional `config` is " + (ªtype(config)) + " not object");
      }
      if (ªO !== ªtype(this.main)) {
        throw TypeError(M + "`main` is " + (ªtype(this.main)) + " not object");
      }
      if ('[object Oo3d]' !== '' + this.main) {
        throw TypeError(M + "`main` is '" + this.main + "' not '[object Oo3d]'");
      }
      if (ªN !== ªtype(this.index)) {
        throw TypeError(M + "`index` is " + (ªtype(this.index)) + " not number");
      }
      if (ªMAX < this.index || this.index % 1 || 0 > this.index) {
        throw RangeError(M + "`index` is " + this.index + " not 0 or a positive integer below 2^53");
      }
      this.oT = config.oT || 'trs';
      if (!{
        'trs': 1,
        'rts': 1,
        'srt': 1
      }[this.oT]) {
        throw RangeError(M + "Optional `config.oT` is not 'trs|rts|srt'");
      }
      this.mT = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
      this.rX = 0;
      this.rY = 0;
      this.rZ = 0;
      this.sX = 1;
      this.sY = 1;
      this.sZ = 1;
      this.tX = 0;
      this.tY = 0;
      this.tZ = 0;
    }

    Item.prototype.read = function(format) {
      var M, mT, mTCopy, sf3;
      M = '/oo3d/src/item/base-item.litcoffee:Item:read()\n  ';
      if (ªU === typeof format || 'object' === format) {
        mTCopy = new Float32Array(16);
        mTCopy.set(this.mT);
        return {
          index: this.index,
          mT: mTCopy,
          rX: this.rX,
          rY: this.rY,
          rZ: this.rZ,
          sX: this.sX,
          sY: this.sY,
          sZ: this.sZ,
          tX: this.tX,
          tY: this.tY,
          tZ: this.tZ
        };
      } else if ('log' === format) {
        mT = this.mT;
        return "i " + this.index + " mT " + mT[0] + " " + mT[1] + " " + mT[2] + " " + mT[3] + " " + mT[4] + " " + mT[5] + " " + mT[6] + " " + mT[7] + " " + mT[8] + " " + mT[9] + " " + mT[10] + " " + mT[11] + " " + mT[12] + " " + mT[13] + " " + mT[14] + " " + mT[15] + " r " + this.rX + " " + this.rY + " " + this.rZ + " s " + this.sX + " " + this.sY + " " + this.sZ + " t " + this.tX + " " + this.tY + " " + this.tZ;
      } else if ('nwang' === format) {
        mT = this.mT;
        sf3 = this.main.nwang.sf3;
        return ("" + (sf3(this.index))) + ("" + (sf3(mT[0])) + (sf3(mT[1])) + (sf3(mT[2])) + (sf3(mT[3]))) + ("" + (sf3(mT[4])) + (sf3(mT[5])) + (sf3(mT[6])) + (sf3(mT[7]))) + ("" + (sf3(mT[8])) + (sf3(mT[9])) + (sf3(mT[10])) + (sf3(mT[11]))) + ("" + (sf3(mT[12])) + (sf3(mT[13])) + (sf3(mT[14])) + (sf3(mT[15]))) + ("" + (sf3(this.rX)) + (sf3(this.rY)) + (sf3(this.rZ))) + ("" + (sf3(this.sX)) + (sf3(this.sY)) + (sf3(this.sZ))) + ("" + (sf3(this.tX)) + (sf3(this.tY)) + (sf3(this.tZ)));
      } else if (ªS === typeof format) {
        throw RangeError(M + "Optional `format` is not 'object|log|nwang'");
      } else {
        throw TypeError(M + "Optional `format` is " + (ªtype(format)) + " not string|object");
      }
    };

    Item.prototype.edit = function(set, delta) {
      var M, a, a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23, char, chars, i, j, key, keys, len, len1, len2, len3, len4, o, q, rXc, rXs, rYc, rYs, rZc, rZs, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, sf3, stale, tDelta, tMT, tSet, tVal, tmp, u, val, vals, w;
      M = "/oo3d/src/item/base-item.litcoffee:Item[" + this.index + "]:edit()\n  ";
      tSet = ªtype(set);
      tDelta = ªtype(delta);
      tmp = {};
      stale = false;
      if (ªU === tSet || ªX === tSet) {
        ref = ['rX', 'rY', 'rZ', 'sX', 'sY', 'sZ', 'tX', 'tY', 'tZ'];
        for (j = 0, len = ref.length; j < len; j++) {
          key = ref[j];
          tmp[key] = this[key];
        }
      } else {
        if (ªO === tSet) {
          if (ªU !== typeof set.index && this.index !== set.index) {
            throw RangeError(M + "`this.index` cannot be altered by `set.index`");
          }
          ref1 = ['rX', 'rY', 'rZ', 'sX', 'sY', 'sZ', 'tX', 'tY', 'tZ'];
          for (o = 0, len1 = ref1.length; o < len1; o++) {
            key = ref1[o];
            val = set[key];
            tVal = typeof val;
            if (ªU === tVal) {
              tmp[key] = this[key];
            } else {
              if (ªN !== tVal) {
                throw TypeError(M + "`set." + key + "` is " + (ªtype(val)) + " not number");
              }
              if (isNaN(val)) {
                throw TypeError(M + "`set." + key + "` is NaN");
              }
              tmp[key] = val;
            }
          }
          if (set.mT) {
            tMT = ªtype(set.mT);
            if (ªA !== tMT.slice(-5)) {
              throw TypeError(M + "`set.TtM` is " + tMT + " not array|*Array");
            }
            if (16 !== set.mT.length) {
              throw RangeError(M + "`set.TtM` has " + set.mT.length + " elements not 16");
            }
            tmp.mT = new Float32Array(16);
            tmp.mT.set(set.mT);
          } else {
            stale = true;
          }
        } else if (ªS === tSet && 0xAFE8 < set.charCodeAt(0)) {
          sf3 = this.main.nwang.sf3;
          if (9 === set.length) {
            ref2 = (function() {
              var len2, q, ref2, results;
              ref2 = set.split('');
              results = [];
              for (q = 0, len2 = ref2.length; q < len2; q++) {
                char = ref2[q];
                results.push(+sf3(char));
              }
              return results;
            })(), tmp.rX = ref2[0], tmp.rY = ref2[1], tmp.rZ = ref2[2], tmp.sX = ref2[3], tmp.sY = ref2[4], tmp.sZ = ref2[5], tmp.tX = ref2[6], tmp.tY = ref2[7], tmp.tZ = ref2[8];
            stale = true;
          } else if (26 === set.length) {
            chars = set.split('');
            if (this.index !== +sf3(chars[0])) {
              throw RangeError(M + "`this.index` cannot be altered by passing `set` an 'nwang'");
            }
            tmp.mT = new Float32Array((function() {
              var q, results;
              results = [];
              for (i = q = 1; q <= 16; i = ++q) {
                results.push(+sf3(chars[i]));
              }
              return results;
            })());
            ref3 = (function() {
              var q, results;
              results = [];
              for (i = q = 17; q <= 25; i = ++q) {
                results.push(+sf3(chars[i]));
              }
              return results;
            })(), tmp.rX = ref3[0], tmp.rY = ref3[1], tmp.rZ = ref3[2], tmp.sX = ref3[3], tmp.sY = ref3[4], tmp.sZ = ref3[5], tmp.tX = ref3[6], tmp.tY = ref3[7], tmp.tZ = ref3[8];
          } else {
            throw RangeError(M + "`set` appears to be 'nwang' but is " + set.length + " characters");
          }
        } else if (ªS === tSet) {
          vals = set.split(' ');
          if ('rst' === vals[0] + vals[4] + vals[8]) {
            ref4 = (function() {
              var len2, q, ref4, results;
              ref4 = [1, 2, 3, 5, 6, 7, 9, 10, 11];
              results = [];
              for (q = 0, len2 = ref4.length; q < len2; q++) {
                i = ref4[q];
                val = +vals[i];
                if (!isNaN(val)) {
                  results.push(val);
                } else {
                  throw RangeError(M + "`set` appears to be 9-char 'log' with non-numeric values");
                }
              }
              return results;
            })(), tmp.rX = ref4[0], tmp.rY = ref4[1], tmp.rZ = ref4[2], tmp.sX = ref4[3], tmp.sY = ref4[4], tmp.sZ = ref4[5], tmp.tX = ref4[6], tmp.tY = ref4[7], tmp.tZ = ref4[8];
            stale = true;
          } else if ('imTrst' === vals[0] + vals[2] + vals[19] + vals[23] + vals[27]) {
            if (this.index !== +vals[1]) {
              throw RangeError(M + "`this.index` cannot be altered by passing `set` a 'log'");
            }
            tmp.mT = new Float32Array((function() {
              var q, results;
              results = [];
              for (i = q = 3; q <= 18; i = ++q) {
                results.push(vals[i]);
              }
              return results;
            })());
            ref5 = (function() {
              var len2, q, ref5, results;
              ref5 = [20, 21, 22, 24, 25, 26, 28, 29, 30];
              results = [];
              for (q = 0, len2 = ref5.length; q < len2; q++) {
                i = ref5[q];
                val = +vals[i];
                if (!isNaN(val)) {
                  results.push(val);
                } else {
                  throw RangeError(M + "`set` appears to be 26-char 'log' with non-numeric values");
                }
              }
              return results;
            })(), tmp.rX = ref5[0], tmp.rY = ref5[1], tmp.rZ = ref5[2], tmp.sX = ref5[3], tmp.sY = ref5[4], tmp.sZ = ref5[5], tmp.tX = ref5[6], tmp.tY = ref5[7], tmp.tZ = ref5[8];
          } else {
            throw RangeError(M + "Optional `set` is a string, but not 'log|nwang' format");
          }
        } else {
          throw TypeError(M + "Optional `set` is " + tSet + " not string|object");
        }
      }
      if (ªU !== tDelta) {
        stale = true;
        if (ªO === tDelta) {
          ref6 = ['rX', 'rY', 'rZ', 'sX', 'sY', 'sZ', 'tX', 'tY', 'tZ'];
          for (q = 0, len2 = ref6.length; q < len2; q++) {
            key = ref6[q];
            val = delta[key];
            tVal = typeof val;
            if (ªU !== tVal) {
              if (ªN !== tVal) {
                throw TypeError(M + "`delta." + key + "` is " + (ªtype(val)) + " not number");
              }
              if (isNaN(val)) {
                throw TypeError(M + "`delta." + key + "` is NaN");
              }
              if ('s' === key.charAt(0)) {
                tmp[key] *= val;
              } else {
                tmp[key] += val;
              }
            }
          }
        } else if (ªS === tDelta && 0xAFE8 < delta.charCodeAt(0)) {
          sf3 = this.main.nwang.sf3;
          if (9 === delta.length) {
            ref7 = ['rX', 'rY', 'rZ', 'sX', 'sY', 'sZ', 'tX', 'tY', 'tZ'];
            for (i = u = 0, len3 = ref7.length; u < len3; i = ++u) {
              key = ref7[i];
              val = +sf3(delta.charAt(i));
              if ('s' === key.charAt(0)) {
                tmp[key] *= val;
              } else {
                tmp[key] += val;
              }
            }
          } else {
            throw RangeError(M + "`delta` appears to be 'nwang' but is " + delta.length + " characters");
          }
        } else if (ªS === tDelta) {
          vals = delta.split(' ');
          if ('rst' === vals[0] + vals[4] + vals[8]) {
            keys = ['-', 'rX', 'rY', 'rZ', '-', 'sX', 'sY', 'sZ', '-', 'tX', 'tY', 'tZ'];
            ref8 = [1, 2, 3, 5, 6, 7, 9, 10, 11];
            for (w = 0, len4 = ref8.length; w < len4; w++) {
              i = ref8[w];
              key = keys[i];
              val = +vals[i];
              if (!isNaN(val)) {
                throw RangeError(M + "`delta` appears to be 9-char 'log' with non-numeric values");
              }
              if (5 <= i && 7 >= i) {
                tmp[key] *= val;
              } else {
                tmp[key] += val;
              }
            }
          } else {
            throw RangeError(M + "Optional `delta` is a string, but not 'log|nwang' format");
          }
        } else if (ªX !== tDelta) {
          throw TypeError(M + "Optional `delta` is " + tDelta + " not string|object");
        }
      }
      for (key in tmp) {
        val = tmp[key];
        this[key] = val;
      }
      if (stale) {
        rXc = Math.cos(this.rX);
        rXs = Math.sin(this.rX);
        rYs = Math.sin(this.rY);
        rYc = Math.cos(this.rY);
        rZs = Math.sin(this.rZ);
        rZc = Math.cos(this.rZ);
        if ('trs' === this.oT) {
          this.mT = new Float32Array([rYc * rZc * this.sX, (rXc * rZs + rXs * rYs * rZc) * this.sX, (rXs * rZs - rXc * rYs * rZc) * this.sX, 0, -rYc * rZs * this.sY, (rXc * rZc - rXs * rYs * rZs) * this.sY, (rXs * rZc + rXc * rYs * rZs) * this.sY, 0, rYs * this.sZ, -rXs * rYc * this.sZ, rXc * rYc * this.sZ, 0, this.tX, this.tY, this.tZ, 1]);
        } else if ('srt' === this.oT) {
          this.mT = new Float32Array([rYc * rZc * this.sX, (rXc * rZs + rXs * rYs * rZc) * this.sY, (rXs * rZs - rXc * rYs * rZc) * this.sZ, 0, -rYc * rZs * this.sX, (rXc * rZc - rXs * rYs * rZs) * this.sY, (rXs * rZc + rXc * rYs * rZs) * this.sZ, 0, rYs * this.sX, -rXs * rYc * this.sY, rXc * rYc * this.sZ, 0, 99, 99, 99, 1]);
          this.mT[12] = this.mT[0] * this.tX + this.mT[4] * this.tY + this.mT[8] * this.tZ;
          this.mT[13] = this.mT[1] * this.tX + this.mT[5] * this.tY + this.mT[9] * this.tZ;
          this.mT[14] = this.mT[2] * this.tX + this.mT[6] * this.tY + this.mT[10] * this.tZ;
        } else if ('rts' === this.oT) {
          a = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
          a10 = a[4];
          a11 = a[5];
          a12 = a[6];
          a13 = a[7];
          a20 = a[8];
          a21 = a[9];
          a22 = a[10];
          a23 = a[11];
          a[4] = a10 * rXc + a20 * rXs;
          a[5] = a11 * rXc + a21 * rXs;
          a[6] = a12 * rXc + a22 * rXs;
          a[7] = a13 * rXc + a23 * rXs;
          a[8] = a20 * rXc - a10 * rXs;
          a[9] = a21 * rXc - a11 * rXs;
          a[10] = a22 * rXc - a12 * rXs;
          a[11] = a23 * rXc - a13 * rXs;
          a00 = a[0];
          a01 = a[1];
          a02 = a[2];
          a03 = a[3];
          a20 = a[8];
          a21 = a[9];
          a22 = a[10];
          a23 = a[11];
          a[0] = a00 * rYc - a20 * rYs;
          a[1] = a01 * rYc - a21 * rYs;
          a[2] = a02 * rYc - a22 * rYs;
          a[3] = a03 * rYc - a23 * rYs;
          a[8] = a00 * rYs + a20 * rYc;
          a[9] = a01 * rYs + a21 * rYc;
          a[10] = a02 * rYs + a22 * rYc;
          a[11] = a03 * rYs + a23 * rYc;
          a00 = a[0];
          a01 = a[1];
          a02 = a[2];
          a03 = a[3];
          a10 = a[4];
          a11 = a[5];
          a12 = a[6];
          a13 = a[7];
          a[0] = a00 * rZc + a10 * rZs;
          a[1] = a01 * rZc + a11 * rZs;
          a[2] = a02 * rZc + a12 * rZs;
          a[3] = a03 * rZc + a13 * rZs;
          a[4] = a10 * rZc - a00 * rZs;
          a[5] = a11 * rZc - a01 * rZs;
          a[6] = a12 * rZc - a02 * rZs;
          a[7] = a13 * rZc - a03 * rZs;
          a[12] = a[0] * this.tX + a[4] * this.tY + a[8] * this.tZ + a[12];
          a[13] = a[1] * this.tX + a[5] * this.tY + a[9] * this.tZ + a[13];
          a[14] = a[2] * this.tX + a[6] * this.tY + a[10] * this.tZ + a[14];
          a[15] = a[3] * this.tX + a[7] * this.tY + a[11] * this.tZ + a[15];
          a[0] *= this.sX;
          a[1] *= this.sX;
          a[2] *= this.sX;
          a[3] *= this.sX;
          a[4] *= this.sY;
          a[5] *= this.sY;
          a[6] *= this.sY;
          a[7] *= this.sY;
          a[8] *= this.sZ;
          a[9] *= this.sZ;
          a[10] *= this.sZ;
          a[11] *= this.sZ;
          this.mT = a;
        }
      }
      return this;
    };

    Item.prototype.dump = function(formatOrState) {
      var M, i, mT, mTCopy, ref, ref1, sf3, type, values;
      M = "/oo3d/src/item/base-item.litcoffee:Item:dump()\n  ";
      type = ªtype(formatOrState);
      if (ªU === type || 'object' === formatOrState) {
        mTCopy = new Float32Array(16);
        mTCopy.set(this.mT);
        return {
          index: this.index,
          mT: mTCopy,
          rX: this.rX,
          rY: this.rY,
          rZ: this.rZ,
          sX: this.sX,
          sY: this.sY,
          sZ: this.sZ,
          tX: this.tX,
          tY: this.tY,
          tZ: this.tZ
        };
      } else if (ªO === type) {
        this.mT = new Float32Array(16);
        this.mT.set(formatOrState.mT);
        this.rX = formatOrState.rX;
        this.rY = formatOrState.rY;
        this.rZ = formatOrState.rZ;
        this.sX = formatOrState.sX;
        this.sY = formatOrState.sY;
        this.sZ = formatOrState.sZ;
        this.tX = formatOrState.tX;
        this.tY = formatOrState.tY;
        this.tZ = formatOrState.tZ;
        return this;
      } else if (ªS !== type) {
        throw TypeError(M + "Optional `formatOrState` is " + type + " not string|object");
      } else if ('log' === formatOrState) {
        mT = this.mT;
        return "i " + this.index + " mT " + mT[0] + " " + mT[1] + " " + mT[2] + " " + mT[3] + " " + mT[4] + " " + mT[5] + " " + mT[6] + " " + mT[7] + " " + mT[8] + " " + mT[9] + " " + mT[10] + " " + mT[11] + " " + mT[12] + " " + mT[13] + " " + mT[14] + " " + mT[15] + " r " + this.rX + " " + this.rY + " " + this.rZ + " s " + this.sX + " " + this.sY + " " + this.sZ + " t " + this.tX + " " + this.tY + " " + this.tZ;
      } else if ('nwang' === formatOrState) {
        mT = this.mT;
        sf3 = this.main.nwang.sf3;
        return [sf3(this.index), sf3(mT[0]), sf3(mT[1]), sf3(mT[2]), sf3(mT[3]), sf3(mT[4]), sf3(mT[5]), sf3(mT[6]), sf3(mT[7]), sf3(mT[8]), sf3(mT[9]), sf3(mT[10]), sf3(mT[11]), sf3(mT[12]), sf3(mT[13]), sf3(mT[14]), sf3(mT[15]), sf3(this.rX), sf3(this.rY), sf3(this.rZ), sf3(this.sX), sf3(this.sY), sf3(this.sZ), sf3(this.tX), sf3(this.tY), sf3(this.tZ)].join('');
      } else if ('i ' === formatOrState.slice(0, 2)) {
        values = formatOrState.split(' ');
        if (this.index !== +values[1]) {
          throw TypeError(M + "`index` must not be altered by 'log'");
        }
        this.mT = new Float32Array((function() {
          var j, len, ref, results;
          ref = [3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18];
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            i = ref[j];
            results.push(values[i]);
          }
          return results;
        })());
        ref = (function() {
          var j, len, ref, results;
          ref = [20, 21, 22, 24, 25, 26, 28, 29, 30];
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            i = ref[j];
            results.push(+values[i]);
          }
          return results;
        })(), this.rX = ref[0], this.rY = ref[1], this.rZ = ref[2], this.sX = ref[3], this.sY = ref[4], this.sZ = ref[5], this.tX = ref[6], this.tY = ref[7], this.tZ = ref[8];
        return this;
      } else if (0xAFE8 < formatOrState.charCodeAt(0)) {
        values = formatOrState.split('');
        sf3 = this.main.nwang.sf3;
        if (this.index !== +sf3(values[0])) {
          throw TypeError(M + "`index` must not be altered by 'nwang'");
        }
        this.mT = new Float32Array((function() {
          var j, results;
          results = [];
          for (i = j = 1; j <= 16; i = ++j) {
            results.push(+sf3(values[i]));
          }
          return results;
        })());
        ref1 = (function() {
          var j, results;
          results = [];
          for (i = j = 17; j <= 25; i = ++j) {
            results.push(+sf3(values[i]));
          }
          return results;
        })(), this.rX = ref1[0], this.rY = ref1[1], this.rZ = ref1[2], this.sX = ref1[3], this.sY = ref1[4], this.sZ = ref1[5], this.tX = ref1[6], this.tY = ref1[7], this.tZ = ref1[8];
        return this;
      } else {
        throw RangeError(M + "Optional `formatOrState` is not a valid string or object");
      }
    };

    Item.prototype.getSnapshot = function(format) {
      var M, m, mT, sf3;
      M = "/oo3d/src/item/base-item.litcoffee:Item:getSnapshot()\n  ";
      if (ªU === typeof format || 'object' === format) {
        mT = new Float32Array(16);
        mT.set(this.mT);
        return {
          mT: mT,
          rX: this.rX,
          rY: this.rY,
          rZ: this.rZ,
          sX: this.sX,
          sY: this.sY,
          sZ: this.sZ,
          tX: this.tX,
          tY: this.tY,
          tZ: this.tZ
        };
      } else if ('log' === format) {
        m = this.mT;
        return "m:[" + m[0] + "," + m[1] + "," + m[2] + "," + m[3] + ", " + m[4] + "," + m[5] + "," + m[6] + "," + m[7] + ", " + m[8] + "," + m[9] + "," + m[10] + "," + m[11] + ", " + m[12] + "," + m[13] + "," + m[14] + "," + m[15] + "], rX:" + this.rX + ", rY:" + this.rY + ", rZ:" + this.rZ + ", sX:" + this.sX + ", sY:" + this.sY + ", sZ:" + this.sZ + ", tX:" + this.tX + ", tY:" + this.tY + ", tZ:" + this.tZ;
      } else if ('minimal' === format) {
        m = this.mT;
        return "m:[" + m[0] + "," + m[1] + "," + m[2] + "," + m[3] + ", " + m[4] + "," + m[5] + "," + m[6] + "," + m[7] + ", " + m[8] + "," + m[9] + "," + m[10] + "," + m[11] + ", " + m[12] + "," + m[13] + "," + m[14] + "," + m[15] + "], rX:" + this.rX + ", rY:" + this.rY + ", rZ:" + this.rZ + ", sX:" + this.sX + ", sY:" + this.sY + ", sZ:" + this.sZ + ", tX:" + this.tX + ", tY:" + this.tY + ", tZ:" + this.tZ;
      } else if ('nwang' === format) {
        sf3 = this.main.nwang.sf3;
        return [sf3(this.rX), sf3(this.rY), sf3(this.rZ), sf3(this.sX), sf3(this.sY), sf3(this.sZ), sf3(this.tX), sf3(this.tY), sf3(this.tZ)].join('');
      } else if (ªS !== ªtype(format)) {
        throw TypeError(M + "Optional `format` is " + (ªtype(format)) + " not string");
      } else {
        throw RangeError(M + "Optional `format` is not 'object|log|nwang'");
      }
    };

    Item.prototype.setSnapshot = function(snapshot) {
      var M, captureFn, captureFns, captureI, captureKey, captureKeys, captureLength, captureLengths, ch, chI, format, l, m, match, matches, nwang, ref;
      M = "/oo3d/src/item/base-item.litcoffee:Item:setSnapshot()\n  ";
      format = ªtype(snapshot);
      if (ªS === format) {
        format = 'm:[' === snapshot.slice(0, 3) ? 'log' : 'nwang';
      }
      if ('log' === format) {
        matches = snapshot.match(/^m:\[([-+.\d,\s]+)\],\s*rX:([-+]?\d*\.?\d*),\s*rY:([-+]?\d*\.?\d*),\s*rZ:([-+]?\d*\.?\d*),\s*sX:([-+]?\d*\.?\d*),\s*sY:([-+]?\d*\.?\d*),\s*sZ:([-+]?\d*\.?\d*),\s*tX:([-+]?\d*\.?\d*),\s*tY:([-+]?\d*\.?\d*),\s*tZ:([-+]?\d*\.?\d*)$/);
        if (null === matches) {
          throw Error(M + "`snapshot`, which looks like 'log' format, is malformed");
        }
        ref = (function() {
          var j, len, results;
          results = [];
          for (j = 0, len = matches.length; j < len; j++) {
            match = matches[j];
            results.push(+match);
          }
          return results;
        })(), snapshot = ref[0], m = ref[1], this.rX = ref[2], this.rY = ref[3], this.rZ = ref[4], this.sX = ref[5], this.sY = ref[6], this.sZ = ref[7], this.tX = ref[8], this.tY = ref[9], this.tZ = ref[10];
        this.mat = new Float32Array(matches[1].split(','));
      } else if ('nwang' === format) {
        nwang = this.main.nwang;
        captureKeys = ['rX', 'rY', 'rZ', 'sX', 'sY', 'sZ', 'tX', 'tY', 'tZ'];
        captureLengths = [1, 1, 1, 1, 1, 1, 1, 1, 1];
        captureFns = [nwang.sf3, nwang.sf3, nwang.sf3, nwang.sf3, nwang.sf3, nwang.sf3, nwang.sf3, nwang.sf3, nwang.sf3];
        chI = 0;
        l = snapshot.length;
        captureI = 0;
        while (chI < l) {
          captureKey = captureKeys[captureI];
          captureLength = captureLengths[captureI];
          captureFn = captureFns[captureI];
          ch = snapshot[chI];
          chI++;
          this[captureKey] = captureFn(ch);
          captureI++;
        }
        this.mT = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
        this.main.rotate(this.rX, this.rY, this.rZ, this.index);
        this.main.scale(this.sX, this.sY, this.sZ, this.index);
        this.main.translate(this.tX, this.tY, this.tZ, this.index);
      }
      return this;
    };

    xx = function() {};

    return Item;

  })();

  Item.Camera = (function(superClass) {
    extend(Camera, superClass);

    Camera.prototype.C = "/src/item/class-item-camera.litcoffee:Item.Camera";

    Camera.prototype.toString = function() {
      return "[object Item.Camera]";
    };

    function Camera(main, index, config) {
      var M;
      if (config == null) {
        config = {};
      }
      M = this.C + ":constructor()\n  ";
      Camera.__super__.constructor.call(this, main, index, config);
      this.fovy = config.fovy;
      if (ªU === ªtype(this.fovy)) {
        this.fovy = 0.785398163;
      } else if (ªN !== ªtype(this.fovy)) {
        throw TypeError(M + "Optional `config.fovy` is " + (ªtype(this.fovy)) + " not number");
      } else if (0 >= this.fovy) {
        throw RangeError(M + "Optional `config.fovy` is " + this.fovy + " not greater than zero");
      }
      this.aspect = config.aspect;
      if (ªU === ªtype(this.aspect)) {
        this.aspect = this.main.$main.width / this.main.$main.height;
      } else if (ªN !== ªtype(this.aspect)) {
        throw TypeError(M + "Optional `config.aspect` is " + (ªtype(this.aspect)) + " not number");
      } else if (0 >= this.aspect) {
        throw RangeError(M + "Optional `config.aspect` is " + this.aspect + " not greater than zero");
      }
      this.matProjection = mat4.perspective(this.fovy, this.aspect, 1, 100);
      this.matCamera = null;
      this.mT[14] = -4;
      this.tZ = -4;
      this.updateCamera();
    }

    Camera.prototype.updateCamera = function() {
      return this.matCamera = new Float32Array(mat4.multiply(this.matProjection, this.mT));
    };

    Camera.prototype.xx = function() {};

    return Camera;

  })(Item);

  Item.Mesh = (function(superClass) {
    extend(Mesh, superClass);

    Mesh.prototype.C = "/src/item/class-item-mesh.litcoffee:Item.Mesh";

    Mesh.prototype.toString = function() {
      return "[object Item.Mesh]";
    };

    function Mesh(main, index, config) {
      var M;
      if (config == null) {
        config = {};
      }
      M = this.C + ":constructor()\n  ";
      Mesh.__super__.constructor.call(this, main, index, config);
      Mesh.__super__.constructor.call(this, main, index, config);
      this.color = pick.indexToColor(this.index);
      this.positionBuffer = this.main.positionBuffers[config.positionI || 0];
      if (!this.positionBuffer) {
        throw Error(M + "`config.positionI` " + config.positionI + " does not exist");
      }
      this.colorBuffer = this.main.colorBuffers[config.colorI || 0];
      if (!this.colorBuffer) {
        throw Error(M + "`config.colorI` " + config.colorI + " does not exist");
      }
      if (this.positionBuffer.count !== this.colorBuffer.count) {
        throw Error(M + "`config.positionI` mismatches config.colorI");
      }
      this.count = this.positionBuffer.count;
      this.renderMode = config.renderMode || 'TRIANGLES';
      if (!Item.Mesh.validRenderMode[this.renderMode]) {
        throw Error(M + "`config.renderMode` " + this.renderMode + " is not recognised by WebGL");
      }
      if (!config.blend) {
        this.sBlend = null;
        this.dBlend = null;
      } else if (ªA !== ªtype(config.blend)) {
        throw Error(M + "If set, `config.blend` must be array not " + (ªtype(config.blend)));
      } else {
        if (!Item.Mesh.validBlend[config.blend[0]]) {
          throw Error(M + "`config.blend[0]` is not recognised by WebGL");
        }
        if (!Item.Mesh.validBlend[config.blend[1]]) {
          throw Error(M + "`config.blend[1]` is not recognised by WebGL");
        }
        this.sBlend = this.main.gl[config.blend[0]];
        this.dBlend = this.main.gl[config.blend[1]];
      }
    }

    Mesh.prototype.xx = function(xx) {};

    return Mesh;

  })(Item);

  Item.Mesh.validRenderMode = {
    'POINTS': 1,
    'LINES': 1,
    'LINE_STRIP': 1,
    'LINE_LOOP': 1,
    'TRIANGLES': 1,
    'TRIANGLE_STRIP': 1,
    'TRIANGLE_FAN': 1
  };

  Item.Mesh.validBlend = {
    'ZERO': 1,
    'ONE': 1,
    'SRC_COLOR': 1,
    'ONE_MINUS_SRC_COLOR': 1,
    'DST_COLOR': 1,
    'ONE_MINUS_DST_COLOR': 1,
    'SRC_ALPHA': 1,
    'ONE_MINUS_SRC_ALPHA': 1,
    'DST_ALPHA': 1,
    'ONE_MINUS_DST_ALPHA': 1,
    'SRC_ALPHA_SATURATE': 1
  };

  Program = (function() {
    Program.prototype.C = 'Program';

    Program.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function Program(main1, config) {
      var gl;
      this.main = main1;
      if (config == null) {
        config = {};
      }
      if (ªO !== ªtype(config)) {
        throw TypeError("`config` must be object not " + (ªtype(config)));
      }
      if (ªO !== ªtype(this.main)) {
        throw TypeError("`main` must be object not " + (ªtype(this.main)));
      }
      if ('[object Oo3d]' !== '' + this.main) {
        throw TypeError("`main` must be [object Oo3d] not " + this.main);
      }
      gl = this.main.gl;
      this.vertexShader = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(this.vertexShader, this.vertexSource());
      gl.compileShader(this.vertexShader);
      if (!gl.getShaderParameter(this.vertexShader, gl.COMPILE_STATUS)) {
        this.cleanUp();
        throw Error(this.C + ".vertexShader failed to compile");
      }
      this.fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(this.fragmentShader, this.fragmentSource());
      gl.compileShader(this.fragmentShader);
      if (!gl.getShaderParameter(this.fragmentShader, gl.COMPILE_STATUS)) {
        this.cleanUp();
        throw Error(this.C + ".fragmentShader failed to compile");
      }
      this.program = gl.createProgram();
      gl.attachShader(this.program, this.vertexShader);
      gl.attachShader(this.program, this.fragmentShader);
      gl.linkProgram(this.program);
      if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
        this.cleanUp();
        throw Error(this.C + ".program failed to link");
      }
    }

    Program.prototype.cleanUp = function() {
      if (this.vertexShader) {
        this.main.gl.deleteShader(this.vertexShader);
      }
      if (this.fragmentShader) {
        this.main.gl.deleteShader(this.fragmentShader);
      }
      if (this.program) {
        return this.main.gl.deleteProgram(this.program);
      }
    };

    Program.prototype.vertexSource = function() {
      return "void main() {\n}";
    };

    Program.prototype.fragmentSource = function() {
      return "void main() {\n}";
    };

    return Program;

  })();

  Program.Flat = (function(superClass) {
    extend(Flat, superClass);

    Flat.prototype.C = 'Program.Flat';

    Flat.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function Flat(main, config) {
      var gl;
      if (config == null) {
        config = {};
      }
      Flat.__super__.constructor.call(this, main, config);
      gl = this.main.gl;
      gl.useProgram(this.program);
      this.aVtxPositionLoc = gl.getAttribLocation(this.program, 'aVtxPosition');
      gl.enableVertexAttribArray(this.aVtxPositionLoc);
      this.aVtxColorLoc = gl.getAttribLocation(this.program, 'aVtxColor');
      this.uMatTransformLoc = gl.getUniformLocation(this.program, 'uMatTransform');
      this.uMatCameraLoc = gl.getUniformLocation(this.program, 'uMatCamera');
    }

    Flat.prototype.vertexSource = function() {
      return "attribute vec3 aVtxPosition;\nattribute vec4 aVtxColor;\n\nuniform mat4 uMatTransform;\nuniform mat4 uMatCamera;\n\nvarying vec4 vColor; // declare `vColor`\n\nvoid main() {\n\n  //// Increase the size of gl.POINT from 1px to 4px. \n  gl_PointSize = 4.0;\n\n  //// Apply the Camera and Mesh transforms to each vertex position. \n  //// Note that the order of these three is important. \n  gl_Position = uMatCamera * uMatTransform * vec4(aVtxPosition, 1);\n\n  //// Pass the vertex-color attribute unchanged to the fragment-shader. \n  vColor = aVtxColor;\n}";
    };

    Flat.prototype.fragmentSource = function() {
      return "precision mediump float; // boilerplate for mobile-friendly shaders\n\nvarying vec4 vColor; // linear-interpolated input from fragment-shader\n\nvoid main(void) {\n  gl_FragColor = vColor;\n}";
    };

    return Flat;

  })(Program);

  Program.FlatItem = (function(superClass) {
    extend(FlatItem, superClass);

    FlatItem.prototype.C = 'Program.FlatItem';

    FlatItem.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function FlatItem(main, config) {
      var gl;
      if (config == null) {
        config = {};
      }
      FlatItem.__super__.constructor.call(this, main, config);
      gl = this.main.gl;
      gl.useProgram(this.program);
      this.aVtxPositionLoc = gl.getAttribLocation(this.program, 'aVtxPosition');
      gl.enableVertexAttribArray(this.aVtxPositionLoc);
      this.uMatTransformLoc = gl.getUniformLocation(this.program, 'uMatTransform');
      this.uMatCameraLoc = gl.getUniformLocation(this.program, 'uMatCamera');
      this.uMeshColorLoc = gl.getUniformLocation(this.program, 'uMeshColor');
    }

    FlatItem.prototype.vertexSource = function() {
      return "attribute vec3 aVtxPosition;\n\nuniform mat4 uMatTransform;\nuniform mat4 uMatCamera;\n\nuniform vec4 uMeshColor; // the mesh renders as a single flat color\n\n\nvarying vec4 vColor; // declare `vColor`\n\nvoid main() {\n\n  //// Multiply the position by the camera transformation and matrices. \n  //// Note that the order of these three is important. \n  gl_Position = uMatCamera * uMatTransform * vec4(aVtxPosition, 1);\n\n  //// Pass the vertex-color attribute unchanged to the fragment-shader. \n  vColor = uMeshColor;\n\n}";
    };

    FlatItem.prototype.fragmentSource = function() {
      return "precision mediump float; // boilerplate for mobile-friendly shaders\n\nvarying vec4 vColor; // linear-interpolated input from fragment-shader\n\nvoid main() {\n  gl_FragColor = vColor;\n}";
    };

    return FlatItem;

  })(Program);

  Program.Flatwhite = (function(superClass) {
    extend(Flatwhite, superClass);

    Flatwhite.prototype.C = 'Program.Flatwhite';

    Flatwhite.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function Flatwhite(main, config) {
      var gl;
      if (config == null) {
        config = {};
      }
      Flatwhite.__super__.constructor.call(this, main, config);
      gl = this.main.gl;
      gl.useProgram(this.program);
      this.aVtxPositionLoc = gl.getAttribLocation(this.program, 'aVtxPosition');
      gl.enableVertexAttribArray(this.aVtxPositionLoc);
      this.uMatTransformLoc = gl.getUniformLocation(this.program, 'uMatTransform');
      this.uMatCameraLoc = gl.getUniformLocation(this.program, 'uMatCamera');
    }

    Flatwhite.prototype.vertexSource = function() {
      return "attribute vec3 aVtxPosition;\n\nuniform mat4 uMatTransform;\nuniform mat4 uMatCamera;\n\nvoid main() {\n\n  //// Multiply the position by the camera transformation and matrices. \n  //// Note that the order of these three is important. \n  gl_Position = uMatCamera * uMatTransform * vec4(aVtxPosition, 1);\n\n}";
    };

    Flatwhite.prototype.fragmentSource = function() {
      return "precision mediump float; // boilerplate for mobile-friendly shaders\n\nvec4 white = vec4(1.0,1.0,1.0,1.0);\n\nvoid main() {\n  gl_FragColor = white;\n}";
    };

    return Flatwhite;

  })(Program);

  Renderer = (function() {
    var RendererTypeError;

    Renderer.prototype.C = 'Renderer';

    Renderer.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function Renderer(main1, config) {
      var i;
      this.main = main1;
      if (config == null) {
        config = {};
      }
      if (ªO !== ªtype(config)) {
        throw TypeError("`config` must be object not " + (ªtype(config)));
      }
      if (ªO !== ªtype(this.main)) {
        throw TypeError("`main` must be object not " + (ªtype(this.main)));
      }
      if ('[object Oo3d]' !== '' + this.main) {
        throw TypeError("`main` must be [object Oo3d] not " + this.main);
      }
      if (ªN !== ªtype(config.programI)) {
        throw TypeError("config.programI must be number not " + (ªtype(config.programI)));
      }
      this.program = this.main.programs[config.programI] || (function() {
        throw RangeError("No such index " + config.programI + " in main.programs");
      })();
      if (ªN !== ªtype(config.cameraI)) {
        throw TypeError("config.cameraI must be number not " + (ªtype(config.cameraI)));
      }
      this.camera = this.main.cameras[config.cameraI] || (function() {
        throw RangeError("No such index " + config.cameraI + " in main.cameras");
      })();
      this.uMatCameraLoc = this.main.gl.getUniformLocation(this.program.program, 'uMatCamera');
      if (!config.meshIs) {
        this.meshes = [];
      } else if ('uint16array' !== ªtype(config.meshIs)) {
        throw TypeError("If set, config.meshIs must be Uint16Array not " + (ªtype(config.meshIs)));
      } else {
        this.meshes = (function() {
          var j, len, ref, results;
          ref = config.meshIs;
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            i = ref[j];
            results.push(this.main.meshes[i] || (function() {
              throw RangeError("No such index " + i + " in main.meshes");
            })());
          }
          return results;
        }).call(this);
      }
    }

    Renderer.prototype.render = function() {
      var $main, aVtxColorLoc, aVtxPositionLoc, gl, index, main, mesh, mode, uMatTransformLoc, uMeshColorLoc;
      main = this.main;
      $main = main.$main;
      gl = main.gl;
      aVtxPositionLoc = this.program.aVtxPositionLoc;
      aVtxColorLoc = this.program.aVtxColorLoc || false;
      uMatTransformLoc = this.program.uMatTransformLoc;
      uMeshColorLoc = this.program.uMeshColorLoc;
      if (!gl) {
        throw Error("The WebGL rendering context is " + (ªtype(gl)));
      }
      gl.useProgram(this.program.program);
      gl.uniformMatrix4fv(this.uMatCameraLoc, false, this.camera.matCamera);
      if (aVtxColorLoc) {
        gl.enableVertexAttribArray(aVtxColorLoc);
      }
      index = this.meshes.length;
      while (index--) {
        mesh = this.meshes[index];
        if (!mesh) {
          continue;
        }
        gl.uniformMatrix4fv(uMatTransformLoc, gl.FALSE, mesh.mT);
        if (uMeshColorLoc) {
          gl.uniform4fv(uMeshColorLoc, mesh.color);
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, mesh.positionBuffer);
        gl.vertexAttribPointer(aVtxPositionLoc, 3, gl.FLOAT, false, 0, 0);
        if (aVtxColorLoc) {
          gl.bindBuffer(gl.ARRAY_BUFFER, mesh.colorBuffer);
          gl.vertexAttribPointer(aVtxColorLoc, 4, gl.FLOAT, false, 0, 0);
        }
        if (null !== mesh.sBlend) {
          gl.enable(gl.BLEND);
          gl.blendFunc(mesh.sBlend, mesh.dBlend);
        } else {
          gl.disable(gl.BLEND);
        }
        mode = gl[mesh.renderMode];
        gl.drawArrays(mode, 0, mesh.count);
        gl.flush();
      }
      if (aVtxColorLoc) {
        return gl.disableVertexAttribArray(aVtxColorLoc);
      }
    };

    RendererTypeError = (function(superClass) {
      extend(RendererTypeError, superClass);

      function RendererTypeError(message) {
        this.message = "Renderer " + message;
        this.name = this.constructor.name;
      }

      RendererTypeError.prototype = new Error();

      RendererTypeError.prototype.constructor = RendererTypeError;

      return RendererTypeError;

    })(TypeError);

    return Renderer;

  })();

  Renderer.Wireframe = (function(superClass) {
    extend(Wireframe, superClass);

    Wireframe.prototype.C = 'Renderer.Wireframe';

    function Wireframe(main, config) {
      if (config == null) {
        config = {};
      }
      Wireframe.__super__.constructor.call(this, main, config);
    }

    return Wireframe;

  })(Renderer);

  Tudor = (function() {
    Tudor.prototype.I = 'Tudor';

    Tudor.prototype.toString = function() {
      return "[object " + I + "]";
    };

    Tudor.prototype.articles = [];

    function Tudor(opt) {
      this.opt = opt != null ? opt : {};
      this["do"] = bind(this["do"], this);
      switch (this.opt.format) {
        case 'html':
          this.pageHead = function(summary) {
            return "<style>\n  body     { font-family: sans-serif; }\n  a        { outline: 0; }\n  b        { display: inline-block; width: .7em }\n\n  b.pass              { color: #393 }\n  b.fail              { color: #bbb }\n  article.fail b.pass { color: #bbb }\n  section.fail b.pass { color: #bbb }\n\n  pre      { padding: .5em; margin: .2em 0; border-radius: 4px; }\n  pre.fn   { background-color: #fde }\n  pre.pass { background-color: #cfc }\n  pre.fail { background-color: #d8e0e8 }\n\n  article  { margin-bottom: .5rem }\n  article h2 { padding-left:.5rem; margin:0; font-weight:normal }\n  article.pass { border-left: 5px solid #9c9 }\n  article.fail { border-left: 5px solid #9bf }\n  article.fail h2 { margin-bottom: .5rem }\n  article.pass >div { display: none }\n\n  section  { margin-bottom: .5rem }\n  section h3   { padding-left: .5rem; margin: 0; }\n  section.pass { border-left: 3px solid #9c9 }\n  section.fail { border-left: 3px solid #9bf }\n  section.fail h3 { margin-bottom: .5rem }\n  section.pass >div { display: none }\n\n  article.fail section.pass { border-left-color: #ccc }\n\n  div      { padding-left: .5em; }\n  div.fail { border-left: 3px solid #9bf; font-size: .8rem }\n  div h4   { margin: 0 }\n  div h4 { font: normal .8rem/1.2rem monaco, monospace }\n  div.fail, div.fail h4 { margin: .5rem 0 }\n\n</style>\n<h4><a href=\"#end\" id=\"top\">\u2b07</a>  " + summary + "</h4>";
          };
          this.pageFoot = function(summary) {
            return "<h4><a href=\"#top\" id=\"end\">\u2b06</a>  " + summary + "</h4>\n<script>\n  document.title='" + (summary.replace(/<\/?[^>]+>/g, '')) + "';\n</script>";
          };
          this.articleHead = function(heading, fail) {
            return ("<article class=\"" + (fail ? 'fail' : 'pass') + "\">") + ("<h2>" + (fail ? this.cross : this.tick) + heading + "</h2><div>");
          };
          this.articleFoot = '</div></article>';
          this.sectionHead = function(heading, fail) {
            return ("<section class=\"" + (fail ? 'fail' : 'pass') + "\">") + ("<h3>" + (fail ? this.cross : this.tick) + heading + "</h3><div>");
          };
          this.sectionFoot = '</div></section>';
          this.jobFormat = function(heading, result) {
            return ("<div class=\"" + (result ? 'fail' : 'pass') + "\">") + ("<h4>" + (result ? this.cross : this.tick) + heading + "</h4>") + ("" + (result ? this.formatError(result) : '')) + "</div>";
          };
          this.tick = '<b class="pass">\u2713</b> ';
          this.cross = '<b class="fail">\u2718</b> ';
          break;
        default:
          this.pageHead = function(summary) {
            return "" + summary;
          };
          this.pageFoot = function(summary) {
            return "\n" + summary;
          };
          this.articleHead = function(heading, fail) {
            return "\n" + (fail ? this.cross : this.tick) + " " + heading + "\n===" + (new Array(heading.length).join('=')) + "\n";
          };
          this.articleFoot = '';
          this.sectionHead = function(heading, fail) {
            return "\n" + (fail ? this.cross : this.tick) + " " + heading + "\n---" + (new Array(heading.length).join('-')) + "\n";
          };
          this.sectionFoot = '';
          this.jobFormat = function(heading, result) {
            return ((result ? this.cross : this.tick) + " " + heading) + ("" + (result ? '\n' + this.formatError(result) : ''));
          };
          this.jobFoot = '';
          this.tick = '\u2713';
          this.cross = '\u2718';
      }
    }

    Tudor.prototype.add = function(lines) {
      var article, i, line, runner, section;
      article = {
        sections: []
      };
      runner = null;
      section = null;
      if (ªA !== ªtype(lines)) {
        throw new Error("`lines` isn’t an array");
      }
      if (0 === lines.length) {
        throw new Error("`lines` has no elements");
      }
      if (ªS !== ªtype(lines[0])) {
        throw new Error("`lines[0]` isn’t a string");
      }
      article.heading = lines.shift();
      i = 0;
      while (i < lines.length) {
        line = lines[i];
        switch (ªtype(line)) {
          case ªO:
            if (!line.runner) {
              throw new Error("Errant object");
            }
            runner = line.runner;
            break;
          case ªF:
            section.jobs.push(line);
            break;
          case ªS:
            if (this.isAssertion(lines[i + 1], lines[i + 2])) {
              if (!section) {
                throw new Error("Cannot add an assertion here");
              }
              section.jobs.push([runner, line, lines[++i], lines[++i]]);
            } else {
              section = {
                heading: line,
                jobs: []
              };
              article.sections.push(section);
            }
        }
        i++;
      }
      return this.articles.push(article);
    };

    Tudor.prototype["do"] = function() {
      var actual, art, artFail, artPass, article, e, error, expect, heading, j, job, len, len1, len2, mock, mockFail, o, pge, pgeFail, pgePass, q, ref, ref1, ref2, result, runner, sec, secFail, secPass, section, summary;
      pge = [];
      mock = null;
      pgePass = pgeFail = mockFail = 0;
      ref = this.articles;
      for (j = 0, len = ref.length; j < len; j++) {
        article = ref[j];
        art = [];
        artPass = artFail = 0;
        ref1 = article.sections;
        for (o = 0, len1 = ref1.length; o < len1; o++) {
          section = ref1[o];
          sec = [];
          secPass = secFail = 0;
          ref2 = section.jobs;
          for (q = 0, len2 = ref2.length; q < len2; q++) {
            job = ref2[q];
            switch (ªtype(job)) {
              case ªF:
                try {
                  mock = job.apply(this, mock);
                } catch (_error) {
                  e = _error;
                  error = e.message;
                }
                if (error) {
                  mockFail++;
                  secFail++;
                  sec.push(this.formatMockModifierError(job, error));
                }
                break;
              case ªA:
                runner = job[0], heading = job[1], expect = job[2], actual = job[3];
                result = runner(expect, actual, mock);
                if (!result) {
                  sec.push(this.jobFormat("" + (this.sanitize(heading))));
                  pgePass++;
                  artPass++;
                  secPass++;
                } else {
                  sec.push(this.jobFormat("" + (this.sanitize(heading)), result));
                  pgeFail++;
                  artFail++;
                  secFail++;
                }
            }
          }
          sec.unshift(this.sectionHead("" + (this.sanitize(section.heading)), secFail));
          sec.push(this.sectionFoot);
          art = art.concat(sec);
        }
        art.unshift(this.articleHead("" + (this.sanitize(article.heading)), artFail));
        art.push(this.articleFoot);
        pge = pge.concat(art);
        summary = pgeFail ? this.cross + " FAILED " + pgeFail + "/" + (pgePass + pgeFail) : this.tick + " Passed " + pgePass + "/" + (pgePass + pgeFail);
        if (mockFail) {
          summary = "\n" + this.cross + " (MOCK FAILS)";
        }
      }
      pge.unshift(this.pageHead(summary));
      pge.push(this.pageFoot(summary));
      return pge.join('\n');
    };

    Tudor.prototype.formatError = function(result) {
      switch (result.length + "-" + this.opt.format) {
        case '2-html':
          return result[0] + "\n<pre class=\"fail\">" + (this.sanitize(result[1].message)) + "</pre>";
        case '2-plain':
          return result[0] + "\n" + (this.sanitize(result[1].message));
        case '3-html':
          return "<pre class=\"fail\">" + (this.sanitize(this.reveal(result[0]))) + "</pre>\n..." + result[1] + "...\n<pre class=\"pass\">" + (this.sanitize(this.reveal(result[2]))) + "</pre>";
        case '3-plain':
          return (this.sanitize(this.reveal(result[0]))) + "\n..." + result[1] + "...\n" + (this.sanitize(this.reveal(result[2])));
        case '4-html':
          return "<pre class=\"fail\">" + (this.sanitize(this.reveal(result[0]))) + " (" + (ªtype(result[0])) + ")</pre>\n..." + result[1] + "...\n<pre class=\"pass\">" + (this.sanitize(this.reveal(result[2]))) + " (" + (ªtype(result[2])) + ")</pre>";
        case '4-plain':
          return (this.sanitize(this.reveal(result[0]))) + " (" + (ªtype(result[0])) + ")\n..." + result[1] + "...\n" + (this.sanitize(this.reveal(result[2]))) + " (" + (ªtype(result[2])) + ")";
        default:
          throw new Error("Cannot process '" + result.length + "-" + this.opt.format + "'");
      }
    };

    Tudor.prototype.formatMockModifierError = function(fn, error) {
      switch (this.opt.format) {
        case 'html':
          return "<pre class=\"fn\">" + (this.sanitize(fn + '')) + "</pre>\n...encountered an exception:\n<pre class=\"fail\">" + (this.sanitize(error)) + "</pre>";
        default:
          return (this.sanitize(fn + '')) + "\n...encountered an exception:\n" + (this.sanitize(error));
      }
    };

    Tudor.prototype.reveal = function(value) {
      return value != null ? value.toString().replace(/^\s+|\s+$/g, function(match) {
        return '\u00b7' + (new Array(match.length)).join('\u00b7');
      }) : void 0;
    };

    Tudor.prototype.sanitize = function(value) {
      switch (this.opt.format) {
        case 'html':
          return value != null ? value.toString().replace(/</g, '&lt;') : void 0;
        default:
          return value;
      }
    };

    Tudor.prototype["throw"] = {
      runner: function(expect, actual, mock) {
        var e, error;
        error = false;
        try {
          actual.apply(this, mock);
        } catch (_error) {
          e = _error;
          error = e;
        }
        if (!error) {
          return [
            'No exception thrown, expected', {
              message: expect
            }
          ];
        } else if (expect !== error.message) {
          return [error.message, 'was thrown, but expected', expect];
        }
      }
    };

    Tudor.prototype.equal = {
      runner: function(expect, actual, mock) {
        var e, error, result;
        error = false;
        try {
          result = actual.apply(this, mock);
        } catch (_error) {
          e = _error;
          error = e;
        }
        if (error) {
          return ['Unexpected exception', error];
        } else if (expect !== result) {
          if (result + '' === expect + '') {
            return [result, 'was returned, but expected', expect, true];
          } else {
            return [result, 'was returned, but expected', expect];
          }
        }
      }
    };

    Tudor.prototype.is = {
      runner: function(expect, actual, mock) {
        var e, error, result;
        error = false;
        try {
          result = actual.apply(this, mock);
        } catch (_error) {
          e = _error;
          error = e;
        }
        if (error) {
          return ['Unexpected exception', error];
        } else if (expect !== ªtype(result)) {
          return ["type " + (ªtype(result)), 'was returned, but expected', "type " + expect];
        }
      }
    };

    Tudor.prototype.match = {
      runner: function(expect, actual, mock) {
        var e, error, result;
        error = false;
        try {
          result = actual.apply(this, mock);
        } catch (_error) {
          e = _error;
          error = e;
        }
        if (error) {
          return ['Unexpected exception', error];
        } else if (ªF !== typeof expect.test) {
          return [
            '`test()` is not a function', {
              message: expect
            }
          ];
        } else if (!expect.test('' + result)) {
          return ['' + result, 'failed test', expect];
        }
      }
    };

    Tudor.prototype.isAssertion = function(line1, line2) {
      if (ªF !== ªtype(line2)) {
        return false;
      }
      if ((ªO === ªtype(line1)) && ªF === ªtype(line1.runner)) {
        return false;
      }
      return true;
    };

    return Tudor;

  })();

  tudor = new Tudor({
    format: ªO === typeof window ? 'html' : 'plain'
  });

  Main.runTest = tudor["do"];

  tudor.add([
    "01 Oo3d Constructor", tudor.is, "The class and instance are expected types", "The class is a function", ªF, function() {
      return Main;
    }, "`new` returns an object", ªO, function() {
      return new Main;
    }, "Config exceptions", tudor["throw"], "If set, `config` must be an object", "/src/class-main.litcoffee:Oo3d:constructor()\n  Optional `config` is array not object", function() {
      return new Main([]);
    }, "If set, `config.$main` must be an HTMLCanvasElement", "/src/class-main.litcoffee:Oo3d:constructor()\n  Optional `config.$main` is number not HTMLCanvasElement", function() {
      return new Main({
        $main: 123
      });
    }, "If set, `config.bkgnd` must be a Float32Array", "/src/class-main.litcoffee:Oo3d:constructor()\n  Optional `config.bkgnd` is number not float32array", function() {
      return new Main({
        bkgnd: 456
      });
    }, "`config.bkgnd` must contain four elements", "/src/class-main.litcoffee:Oo3d:constructor()\n  If set `config.bkgnd` must contain four elements", function() {
      return new Main({
        bkgnd: new Float32Array([1, 1, 1])
      });
    }, "`config.bkgnd[0]` must be 0 or greater", "/src/class-main.litcoffee:Oo3d:constructor()\n  `config.bkgnd[0]` (red) is not within range 0-1", function() {
      return new Main({
        bkgnd: new Float32Array([-0.02, 1, 1, 1])
      });
    }, "`config.bkgnd[0]` must be 1 or less", "/src/class-main.litcoffee:Oo3d:constructor()\n  `config.bkgnd[0]` (red) is not within range 0-1", function() {
      return new Main({
        bkgnd: new Float32Array([1.02, 1, 1, 1])
      });
    }, "`config.bkgnd[1]` must be 0 or greater", "/src/class-main.litcoffee:Oo3d:constructor()\n  `config.bkgnd[1]` (green) is not within range 0-1", function() {
      return new Main({
        bkgnd: new Float32Array([0, -0.02, 1, 1])
      });
    }, "`config.bkgnd[1]` must be 1 or less", "/src/class-main.litcoffee:Oo3d:constructor()\n  `config.bkgnd[1]` (green) is not within range 0-1", function() {
      return new Main({
        bkgnd: new Float32Array([0, 1.02, 1, 1])
      });
    }, "`config.bkgnd[2]` must be 0 or greater", "/src/class-main.litcoffee:Oo3d:constructor()\n  `config.bkgnd[2]` (blue) is not within range 0-1", function() {
      return new Main({
        bkgnd: new Float32Array([0, 1, -Infinity, 1])
      });
    }, "`config.bkgnd[2]` must be 1 or less", "/src/class-main.litcoffee:Oo3d:constructor()\n  `config.bkgnd[2]` (blue) is not within range 0-1", function() {
      return new Main({
        bkgnd: new Float32Array([0, 1, Infinity, 1])
      });
    }, "`config.bkgnd[3]` must be 0 or greater", "/src/class-main.litcoffee:Oo3d:constructor()\n  `config.bkgnd[3]` (alpha) is not within range 0-1", function() {
      return new Main({
        bkgnd: new Float32Array([0, 1, 1, -0.000001])
      });
    }, "`config.bkgnd[3]` must be 1 or less", "/src/class-main.litcoffee:Oo3d:constructor()\n  `config.bkgnd[3]` (alpha) is not within range 0-1", function() {
      return new Main({
        bkgnd: new Float32Array([0, 1, 0, 1.00001])
      });
    }, "Config usage", tudor.equal, "`config.bkgnd` can contain four floats 0-1, or NaN", '[object Oo3d]', function() {
      return '' + (new Main({
        bkgnd: new Float32Array([1, 0, NaN, 0.5])
      }));
    }
  ]);

  tudor.add([
    "02 Item Constructor", tudor.is, "(Mock an `Oo3d` instance)", function() {
      var CanvasMock, oo3d;
      CanvasMock = (function() {
        function CanvasMock() {}

        CanvasMock.prototype.width = 2;

        CanvasMock.prototype.height = 1;

        CanvasMock.prototype.toString = function() {
          return '[object HTMLCanvasElement]';
        };

        CanvasMock.prototype.getContext = function() {
          return {
            createBuffer: function() {
              return {};
            },
            bindBuffer: function() {},
            bufferData: function() {},
            clearColor: function() {},
            enable: function() {},
            depthFunc: function() {},
            scissor: function() {},
            clear: function() {},
            TRIANGLES: 4
          };
        };

        return CanvasMock;

      })();
      oo3d = new Main({
        $main: new CanvasMock
      });
      return [oo3d];
    }, "The class and instance are expected types", "The class is a function", ªF, function() {
      return Item;
    }, "`new` returns an object", ªO, function(oo3d) {
      return new Item(oo3d, 0);
    }, "Constructor exceptions", tudor["throw"], "`config.main` must be an object", "/oo3d/src/item/base-item.litcoffee:Item:constructor()\n  `main` is number not object", function(oo3d) {
      return new Item(123);
    }, "`config.main` must be an Oo3d instance", "/oo3d/src/item/base-item.litcoffee:Item:constructor()\n  `main` is '[object Object]' not '[object Oo3d]'", function(oo3d) {
      return new Item({});
    }, "`index` must be a number", "/oo3d/src/item/base-item.litcoffee:Item:constructor()\n  `index` is boolean not number", function(oo3d) {
      return new Item(oo3d, true);
    }, "`index` must be an integer", "/oo3d/src/item/base-item.litcoffee:Item:constructor()\n  `index` is 3.5 not 0 or a positive integer below 2^53", function(oo3d) {
      return new Item(oo3d, 3.5);
    }, "`index` must be positive", "/oo3d/src/item/base-item.litcoffee:Item:constructor()\n  `index` is -44 not 0 or a positive integer below 2^53", function(oo3d) {
      return new Item(oo3d, -44);
    }, "`index` must be below 2^53", "/oo3d/src/item/base-item.litcoffee:Item:constructor()\n  `index` is 9007199254740992 not 0 or a positive integer below 2^53", function(oo3d) {
      return new Item(oo3d, 9007199254740992);
    }, "`config` must be an object", "/oo3d/src/item/base-item.litcoffee:Item:constructor()\n  Optional `config` is date not object", function(oo3d) {
      return new Item(oo3d, 0, new Date);
    }, "Constructor usage", tudor.equal, "`config` can be an empty object", '[object Item]', function(oo3d) {
      var item;
      item = new Item(oo3d, 0, {});
      return '' + item;
    }, "`item.mT` as expected", '1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1', function(oo3d) {
      var item, n;
      item = new Item(oo3d, 0, {});
      return ((function() {
        var j, len, ref, results;
        ref = item.mT;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          n = ref[j];
          results.push('' + n);
        }
        return results;
      })()).join(' ');
    }, "`item.rX` `item.rY` `item.rZ` as expected", '0 0 0', function(oo3d) {
      var item;
      item = new Item(oo3d, 0, {});
      return [item.rX, item.rY, item.rZ].join(' ');
    }, "`item.sX` `item.sY` `item.sZ` as expected", '1 1 1', function(oo3d) {
      var item;
      item = new Item(oo3d, 0, {});
      return [item.sX, item.sY, item.sZ].join(' ');
    }, "`item.tX` `item.tY` `item.tZ` as expected", '0 0 0', function(oo3d) {
      var item;
      item = new Item(oo3d, 0, {});
      return [item.tX, item.tY, item.tZ].join(' ');
    }
  ]);

  tudor.add([
    "03 `item.read()`", tudor.is, "(Mock an `Oo3d` instance)", function() {
      var CanvasMock, item, itemI, oo3d;
      CanvasMock = (function() {
        function CanvasMock() {}

        CanvasMock.prototype.width = 2;

        CanvasMock.prototype.height = 1;

        CanvasMock.prototype.toString = function() {
          return '[object HTMLCanvasElement]';
        };

        CanvasMock.prototype.getContext = function() {
          return {
            createBuffer: function() {
              return {};
            },
            bindBuffer: function() {},
            bufferData: function() {},
            clearColor: function() {},
            enable: function() {},
            depthFunc: function() {},
            scissor: function() {},
            clear: function() {},
            TRIANGLES: 4
          };
        };

        return CanvasMock;

      })();
      oo3d = new Main({
        $main: new CanvasMock
      });
      itemI = oo3d.addMesh({
        positionI: 0,
        colorI: 0,
        renderMode: null,
        blend: null
      });
      item = oo3d.meshes[itemI];
      return [oo3d, item];
    }, "The method is a function and returns expected types", "`item.read()` is a function", ªF, function(oo3d, item) {
      return item.read;
    }, "`item.read()` returns an object", ªO, function(oo3d, item) {
      return item.read();
    }, "`item.read('object')` returns an object", ªO, function(oo3d, item) {
      return item.read('object');
    }, "`item.read('log')` returns a string", ªS, function(oo3d, item) {
      return item.read('log');
    }, "`item.read('nwang')` returns a string", ªS, function(oo3d, item) {
      return item.read('nwang');
    }, "`item.read()` exceptions", tudor["throw"], "`format` must not be boolean", "/oo3d/src/item/base-item.litcoffee:Item:read()\n  Optional `format` is boolean not string|object", function(oo3d, item) {
      return item.read(false);
    }, "`format` must not be null", "/oo3d/src/item/base-item.litcoffee:Item:read()\n  Optional `format` is null not string|object", function(oo3d, item) {
      return item.read(null);
    }, "`format` 'NOPE!' is not recognized", "/oo3d/src/item/base-item.litcoffee:Item:read()\n  Optional `format` is not 'object|log|nwang'", function(oo3d, item) {
      return item.read('NOPE!');
    }, "`item.read()` usage", tudor.equal, "Object from a default Item contains expected keys and values", "i 0 mT 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 r 0 0 0 s 1 1 1 t 0 0 0", function(oo3d, item) {
      var obj;
      obj = item.read();
      return "i " + obj.index + " mT " + obj.mT[0] + " " + obj.mT[1] + " " + obj.mT[2] + " " + obj.mT[3] + " " + obj.mT[4] + " " + obj.mT[5] + " " + obj.mT[6] + " " + obj.mT[7] + " " + obj.mT[8] + " " + obj.mT[9] + " " + obj.mT[10] + " " + obj.mT[11] + " " + obj.mT[12] + " " + obj.mT[13] + " " + obj.mT[14] + " " + obj.mT[15] + " r " + obj.rX + " " + obj.rY + " " + obj.rZ + " s " + obj.sX + " " + obj.sY + " " + obj.sZ + " t " + obj.tX + " " + obj.tY + " " + obj.tZ;
    }, "Object from a default Item contains no unexpected keys", "index mT rX rY rZ sX sY sZ tX tY tZ", function(oo3d, item) {
      var k, obj, v;
      obj = item.read();
      return ((function() {
        var results;
        results = [];
        for (k in obj) {
          v = obj[k];
          results.push(k);
        }
        return results;
      })()).sort().join(' ');
    }, "Dumped 'log' from a default Item as expected", "i 0 mT 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 r 0 0 0 s 1 1 1 t 0 0 0", function(oo3d, item) {
      return item.read('log');
    }, "Dumped 'nwang' from a default Item as expected", "셼죨셼셼셼셼죨셼셼셼셼죨셼셼셼셼죨셼셼셼죨죨죨셼셼셼", function(oo3d, item) {
      return item.read('nwang');
    }, function(oo3d, item) {
      oo3d.rotate(0.001, (Math.PI * -2 / 2306) + 0.0001, (Math.PI / 6) + (Math.PI * 10), 0);
      oo3d.scale(0.001, -0.5000001, 12, 0);
      oo3d.translate(0.001, -0.5000001, 12, 0);
      return [oo3d, item];
    }, "Dumped 'log' from a transformed Item as expected", "i 0 mT 0.0008660224266350269 0.0004999975208193064 0.0000027730632154998602 0 0.24999918043613434 -0.4330132305622101 0.0002231643011327833 0 -0.031496502459049225 -0.011999955400824547 11.99995231628418 0 -0.5029568076133728 0.07250769436359406 143.9993133544922 1 r 0.001 -0.0026247117550648683 31.93952531149623 s 0.001 -0.5000001 12 t 0.001 -0.5000001 12", function(oo3d, item) {
      return item.read('log');
    }, "Dumped 'nwang' from a transformed Item as expected", '셼솅솁셼셼엺뱇셾셼쁁섄첀셼밁쑑퀜죨솆셢쵇솆밄첀솆밄첀', function(oo3d, item) {
      return item.read('nwang');
    }
  ]);

  tudor.add([
    "04 `item.edit()`", tudor.is, "(Mock an `Oo3d` instance)", function() {
      var CanvasMock, item, itemI, oo3d;
      CanvasMock = (function() {
        function CanvasMock() {}

        CanvasMock.prototype.width = 2;

        CanvasMock.prototype.height = 1;

        CanvasMock.prototype.toString = function() {
          return '[object HTMLCanvasElement]';
        };

        CanvasMock.prototype.getContext = function() {
          return {
            createBuffer: function() {
              return {};
            },
            bindBuffer: function() {},
            bufferData: function() {},
            clearColor: function() {},
            enable: function() {},
            depthFunc: function() {},
            scissor: function() {},
            clear: function() {},
            TRIANGLES: 4
          };
        };

        return CanvasMock;

      })();
      oo3d = new Main({
        $main: new CanvasMock
      });
      itemI = oo3d.addMesh({
        positionI: 0,
        colorI: 0,
        renderMode: null,
        blend: null
      });
      item = oo3d.meshes[itemI];
      return [oo3d, item];
    }, "The method is a function and returns an object", "`item.edit()` is a function", ªF, function(oo3d, item) {
      return item.edit;
    }, "`item.edit()` returns an object", ªO, function(oo3d, item) {
      return item.edit();
    }, "`item.edit('i 0 mT 1 0 0 0 ... t 0 0 0')` returns an object", ªO, function(oo3d, item) {
      return item.edit("i 0 mT 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 r 0 0 0 s 1 1 1 t 0 0 0");
    }, "`item.rX` is a number", ªN, function(oo3d, item) {
      return item.rX;
    }, "`item.rY` is a number", ªN, function(oo3d, item) {
      return item.rY;
    }, "`item.rZ` is a number", ªN, function(oo3d, item) {
      return item.rZ;
    }, "`item.sX` is a number", ªN, function(oo3d, item) {
      return item.sX;
    }, "`item.sY` is a number", ªN, function(oo3d, item) {
      return item.sY;
    }, "`item.sZ` is a number", ªN, function(oo3d, item) {
      return item.sZ;
    }, "`item.tX` is a number", ªN, function(oo3d, item) {
      return item.tX;
    }, "`item.tY` is a number", ªN, function(oo3d, item) {
      return item.tY;
    }, "`item.tZ` is a number", ªN, function(oo3d, item) {
      return item.tZ;
    }, "Ensure private functions cannot be accessed", tudor.equal, "`xx()` cannot be accessed", ªU, function(oo3d, item) {
      return typeof xx;
    }, "`set` argument exceptions", tudor["throw"], "`set` cannot be a Date object", "/oo3d/src/item/base-item.litcoffee:Item[0]:edit()\n  Optional `set` is date not string|object", function(oo3d, item) {
      return item.edit(new Date);
    }, "`set` cannot be the string 'NOPE!'", "/oo3d/src/item/base-item.litcoffee:Item[0]:edit()\n  Optional `set` is a string, but not 'log|nwang' format", function(oo3d, item) {
      return item.edit('NOPE!');
    }, "`set` cannot be an empty string", "/oo3d/src/item/base-item.litcoffee:Item[0]:edit()\n  Optional `set` is a string, but not 'log|nwang' format", function(oo3d, item) {
      return item.edit('');
    }, "An object passed to the `set` argument must not must not change `item.index` to a boolean", "/oo3d/src/item/base-item.litcoffee:Item[0]:edit()\n  `this.index` cannot be altered by `set.index`", function(oo3d, item) {
      return item.edit({
        index: true
      });
    }, "An object passed to the `set` argument must not must not change `item.index` to a number", "/oo3d/src/item/base-item.litcoffee:Item[0]:edit()\n  `this.index` cannot be altered by `set.index`", function(oo3d, item) {
      return item.edit({
        index: 1234
      });
    }, "An `sY` property passed to the `set` argument must be a number", "/oo3d/src/item/base-item.litcoffee:Item[0]:edit()\n  `set.sY` is array not number", function(oo3d, item) {
      return item.edit({
        rX: 1,
        sY: ['NOPE!'],
        tZ: 3
      });
    }, "A `tX` property passed to the `set` argument must not be NaN", "/oo3d/src/item/base-item.litcoffee:Item[0]:edit()\n  `set.tX` is NaN", function(oo3d, item) {
      return item.edit({
        rX: 1,
        tX: NaN,
        tZ: 3
      });
    }, "An `mT` property passed to the `set` argument must be Float32Array|array", "/oo3d/src/item/base-item.litcoffee:Item[0]:edit()\n  `set.TtM` is object not array|*Array", function(oo3d, item) {
      return item.edit({
        mT: {}
      });
    }, "An `mT` property passed to the `set` argument must contain 16 values", "/oo3d/src/item/base-item.litcoffee:Item[0]:edit()\n  `set.TtM` has 17 elements not 16", function(oo3d, item) {
      return item.edit({
        mT: [1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7]
      });
    }, "An 'nwang' string passed to the `set` argument must not be 8 characters", "/oo3d/src/item/base-item.litcoffee:Item[0]:edit()\n  `set` appears to be 'nwang' but is 8 characters", function(oo3d, item) {
      return item.edit('솆셢쵇솆밄첀솆밄');
    }, "An 'nwang' string passed to the `set` argument must not be 10 characters", "/oo3d/src/item/base-item.litcoffee:Item[0]:edit()\n  `set` appears to be 'nwang' but is 10 characters", function(oo3d, item) {
      return item.edit('솆셢쵇솆밄첀솆밄첀첀');
    }, "An 'nwang' string passed to the `set` argument must be valid nwang", "/nwang/src/class-main.litcoffee:Main:sf3()\n  `x` codepoint 102 < 44032", function(oo3d, item) {
      return item.edit('솆셢쵇솆밄foo첀');
    }, "An 'nwang' string passed to the `set` argument must not change `item.index`", "/oo3d/src/item/base-item.litcoffee:Item[0]:edit()\n  `this.index` cannot be altered by passing `set` an 'nwang'", function(oo3d, item) {
      return item.edit('솆솅솁셼셼엺뱇셾셼쁁섄첀셼밁쑑퀜죨솆셢쵇솆밄첀솆밄첀');
    }, "A 9-value 'log' string passed to the `set` argument must only contain numbers", "/oo3d/src/item/base-item.litcoffee:Item[0]:edit()\n  `set` appears to be 9-char 'log' with non-numeric values", function(oo3d, item) {
      return item.edit('r A B C s foo bar baz t 7 8 9');
    }, "A 16-value 'log' string passed to the `set` argument must only contain numbers", "/oo3d/src/item/base-item.litcoffee:Item[0]:edit()\n  `set` appears to be 26-char 'log' with non-numeric values", function(oo3d, item) {
      return item.edit('i 0 mT 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 r A B C s foo bar baz t 7 8 9');
    }, "A 'log' string passed to the `set` argument must not change `item.index`", "/oo3d/src/item/base-item.litcoffee:Item[0]:edit()\n  `this.index` cannot be altered by passing `set` a 'log'", function(oo3d, item) {
      return item.edit('i 12345 mT 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 r 1 2 3 s 4 5 6 t 7 8 9');
    }, "`delta` argument exceptions", tudor["throw"], "`delta` cannot be the Math object", "/oo3d/src/item/base-item.litcoffee:Item[0]:edit()\n  Optional `delta` is math not string|object", function(oo3d, item) {
      return item.edit(null, Math);
    }, "`delta` cannot be the string 'NOPE!'", "/oo3d/src/item/base-item.litcoffee:Item[0]:edit()\n  Optional `delta` is a string, but not 'log|nwang' format", function(oo3d, item) {
      return item.edit(null, 'NOPE!');
    }, "`delta` cannot be an empty string", "/oo3d/src/item/base-item.litcoffee:Item[0]:edit()\n  Optional `delta` is a string, but not 'log|nwang' format", function(oo3d, item) {
      return item.edit(null, '');
    }, "An `rX` property passed to the `delta` argument must be a number", "/oo3d/src/item/base-item.litcoffee:Item[0]:edit()\n  `delta.rX` is string not number", function(oo3d, item) {
      return item.edit(null, {
        rX: '22'
      });
    }, "A `tZ` property passed to the `set` argument must not be NaN", "/oo3d/src/item/base-item.litcoffee:Item[0]:edit()\n  `delta.tZ` is NaN", function(oo3d, item) {
      return item.edit(null, {
        rX: Math.PI,
        tX: -44.3,
        tZ: NaN
      });
    }, "An 'nwang' string passed to the `delta` argument must not be 8 characters", "/oo3d/src/item/base-item.litcoffee:Item[0]:edit()\n  `delta` appears to be 'nwang' but is 8 characters", function(oo3d, item) {
      return item.edit(null, '솆셢쵇솆밄첀솆밄');
    }, "An 'nwang' string passed to the `delta` argument must not be 26 characters", "/oo3d/src/item/base-item.litcoffee:Item[0]:edit()\n  `delta` appears to be 'nwang' but is 26 characters", function(oo3d, item) {
      return item.edit(null, '솆솅솁셼셼엺뱇셾셼쁁섄첀셼밁쑑퀜죨솆셢쵇솆밄첀솆밄첀');
    }, "An 'nwang' string passed to the `delta` argument must be valid nwang", "/nwang/src/class-main.litcoffee:Main:sf3()\n  `x` codepoint 102 < 44032", function(oo3d, item) {
      return item.edit(null, '셼셼셼죨죨foo셼');
    }, "A 'log' string passed to the `delta` argument must only contain numbers", "/oo3d/src/item/base-item.litcoffee:Item[0]:edit()\n  `delta` appears to be 9-char 'log' with non-numeric values", function(oo3d, item) {
      return item.edit(null, 'r 88 77 66 s foo bar baz t A Z 9');
    }, "Noop ways of calling `item.edit()`", tudor.equal, "No arguments", 'i 0 mT 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 r 0 0 0 s 1 1 1 t 0 0 0', function(oo3d, item) {
      item.edit();
      return item.read('log');
    }, "Pass null to the `set` and `delta` arguments", 'i 0 mT 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 r 0 0 0 s 1 1 1 t 0 0 0', function(oo3d, item) {
      item.edit(null, null);
      return item.read('log');
    }, "Pass undefined to the `set` and `delta` arguments", 'i 0 mT 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 r 0 0 0 s 1 1 1 t 0 0 0', function(oo3d, item) {
      item.edit(void 0, void 0);
      return item.read('log');
    }, "Pass empty object to the `set` argument", 'i 0 mT 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 r 0 0 0 s 1 1 1 t 0 0 0', function(oo3d, item) {
      item.edit({});
      return item.read('log');
    }, "Pass empty object to the `delta` argument", 'i 0 mT 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 r 0 0 0 s 1 1 1 t 0 0 0', function(oo3d, item) {
      item.edit(void 0, {});
      return item.read('log');
    }, "Pass empty objects to the `set` and `delta` arguments", 'i 0 mT 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 r 0 0 0 s 1 1 1 t 0 0 0', function(oo3d, item) {
      item.edit({}, {});
      return item.read('log');
    }, "Pass an object to the `set` argument", "Pass a complete object to the `set` argument", 'i 0 mT 1 2 2 2 2 1 3 3 3 3 1 4 4 4 4 1 r 1 2 3 s 4 5 6 t 7 8 9', function(oo3d, item) {
      item.edit({
        index: 0,
        mT: [1, 2, 2, 2, 2, 1, 3, 3, 3, 3, 1, 4, 4, 4, 4, 1],
        rX: 1,
        rY: 2,
        rZ: 3,
        sX: 4,
        sY: 5,
        sZ: 6,
        tX: 7,
        tY: 8,
        tZ: 9
      });
      return item.read('log');
    }, "Pass a partial object to the `set` argument, which includes `mT`", 'i 0 mT 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 r 1 2 3 s 4 5 6 t 44 8 9', function(oo3d, item) {
      item.edit({
        mT: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        tX: 44
      });
      return item.read('log');
    }, "Pass a partial object to the `set` argument, which does not include `mT`", 'i 0 mT 1.6479289531707764 -2.724970817565918 2.420509099960327 0 0.29363322257995605 -3.2143642902374268 -3.818591594696045 0 5.455784797668457 2.10105299949646 -1.3490705490112305 0 44 55 66 1 r 1 2 3 s 4 5 6 t 44 55 66', function(oo3d, item) {
      item.edit({
        tY: 55,
        tZ: 66
      });
      return item.read('log');
    }, "Random properties are ignored", 'i 0 mT 1.6479289531707764 -2.724970817565918 2.420509099960327 0 0.29363322257995605 -3.2143642902374268 -3.818591594696045 0 5.455784797668457 2.10105299949646 -1.3490705490112305 0 44 55 100 1 r 1 2 3 s 4 5 6 t 44 55 100', function(oo3d, item) {
      item.edit({
        foo: 'IGNORED!',
        bar: 'IGNORED!',
        tZ: 100
      });
      return item.read('log');
    }, "An `mT` property passed to the `set` argument can contain non-numeric values (will become NaN)", "i 0 mT 1 2 3 4 5 6 7 8 9 NaN 1 2 3 4 5 6 r 1 2 3 s 4 5 6 t 44 55 100", function(oo3d, item) {
      item.edit({
        mT: [1, 2, 3, 4, 5, 6, 7, 8, 9, 'ten', 1, 2, 3, 4, 5, 6]
      });
      return item.read('log');
    }, "An `mT` property passed to the `set` argument can be UInt8Array", "i 0 mT 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 r 1 2 3 s 4 5 6 t 44 55 100", function(oo3d, item) {
      item.edit({
        mT: new Uint8Array([8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8])
      });
      return item.read('log');
    }, "Pass an 'nwang' string to the `set` argument", "Pass a 26-value 'nwang' string to the `set` argument", "i 0 mT 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 r 0.001 -0.0026 31.9 s 0.001 -0.5 12 t 0.001 -0.5 12", function(oo3d, item) {
      item.edit('셼죨셼셼셼셼죨셼셼셼셼죨셼셼셼셼죨솆셢쵇솆밄첀솆밄첀');
      return item.read('log');
    }, "Pass a 9-value 'nwang' string to the `set` argument", 'i 0 mT 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 r 0 0 0 s 1 1 1 t 0 0 0', function(oo3d, item) {
      item.edit('셼셼셼죨죨죨셼셼셼');
      return item.read('log');
    }, "Pass a 'log' string to the `set` argument", "Pass a 26-value 'log' string to the `set` argument, which resets the Item", 'i 0 mT 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 r 0 0 0 s 1 1 1 t 0 0 0', function(oo3d, item) {
      item.edit('i 0 mT 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 r 0 0 0 s 1 1 1 t 0 0 0');
      return item.read('log');
    }, "Note that an inconsistent 26-value 'log' should be accepted without complaint!", 'i 0 mT 1 2 3 4 5 6 7 8 9 0 1 0 0 0 0 1 r 0 0 0 s 1 1 1 t 0 0 0', function(oo3d, item) {
      item.edit('i 0 mT 1 2 3 4 5 6 7 8 9 0 1 0 0 0 0 1 r 0 0 0 s 1 1 1 t 0 0 0');
      return item.read('log');
    }, "Pass a 9-value 'log' string to the `set` argument", 'i 0 mT -0.6581568121910095 -1.7472580671310425 5.7020978927612305 0 0.4779578745365143 -4.773890972137451 -1.4076658487319946 0 3.957432985305786 0.23985300958156586 0.5302779078483582 0 3 2 1 1 r 9 8 7 s 6 5 4 t 3 2 1', function(oo3d, item) {
      item.edit('r 9 8 7 s 6 5 4 t 3 2 1');
      return item.read('log');
    }, "Pass an object to the `delta` argument", "Pass a 'unity' 9-value object to the `delta` argument", 'i 0 mT -0.6581568121910095 -1.7472580671310425 5.7020978927612305 0 0.4779578745365143 -4.773890972137451 -1.4076658487319946 0 3.957432985305786 0.23985300958156586 0.5302779078483582 0 3 2 1 1 r 9 8 7 s 6 5 4 t 3 2 1', function(oo3d, item) {
      item.edit(null, {
        rX: 0,
        rY: 0,
        rZ: 0,
        sX: 1,
        sY: 1,
        sZ: 1,
        tX: 0,
        tY: 0,
        tZ: 0
      });
      return item.read('log');
    }, "Pass a transforming 9-value object to the `delta` argument", 'i 0 mT 25.574983596801758 22.437387466430664 -33.85976791381836 0 -29.616554260253906 9.995354652404785 -15.746511459350586 0 -0.2124314159154892 20.078948974609375 13.144987106323242 0 21 22 23 1 r 21 22 23 s 48 35 24 t 21 22 23', function(oo3d, item) {
      item.edit(null, {
        rX: 12,
        rY: 14,
        rZ: 16,
        sX: 8,
        sY: 7,
        sZ: 6,
        tX: 18,
        tY: 20,
        tZ: 22
      });
      return item.read('log');
    }, "Pass a transforming 2-value object to the `delta` argument", 'i 0 mT 25.574983596801758 -3.992623805999756 40.422508239746094 0 74.0413818359375 3.6715314388275146 -46.48271942138672 0 -0.2124314159154892 -23.895618438720703 -2.2258212566375732 0 21 22 23 1 r -479 22 23 s 48 -87.5 24 t 21 22 23', function(oo3d, item) {
      item.edit(null, {
        rX: -500,
        sY: -2.5
      });
      return item.read('log');
    }, "Pass an 'nwang' string to the `delta` argument", "Pass a 'unity' 9-value 'nwang' string to the `delta` argument", 'i 0 mT 25.574983596801758 -3.992623805999756 40.422508239746094 0 74.0413818359375 3.6715314388275146 -46.48271942138672 0 -0.2124314159154892 -23.895618438720703 -2.2258212566375732 0 21 22 23 1 r -479 22 23 s 48 -87.5 24 t 21 22 23', function(oo3d, item) {
      item.edit(null, '셼셼셼죨죨죨셼셼셼');
      return item.read('log');
    }, "Pass a transforming 9-value 'nwang' string to the `delta` argument", 'i 0 mT 0 0 0 0 -18.84529685974121 -2.4989914894104004 39.695213317871094 0 0.00007556568016298115 -0.023954685777425766 -0.0014721800107508898 0 165 23 23.000999450683594 1 r -479.0315 21.988 35 s 0 44.0125 0.024 t 165 23 23.001', function(oo3d, item) {
      item.edit(null, '쁁섄첀셼밁솆퀜죨솆');
      return item.read('log');
    }
  ]);

  tudor.add([
    "04 Item.Mesh Constructor", tudor.is, "(Mock an `Oo3d` instance)", function() {
      var CanvasMock, oo3d;
      CanvasMock = (function() {
        function CanvasMock() {}

        CanvasMock.prototype.width = 2;

        CanvasMock.prototype.height = 1;

        CanvasMock.prototype.toString = function() {
          return '[object HTMLCanvasElement]';
        };

        CanvasMock.prototype.getContext = function() {
          return {
            createBuffer: function() {
              return {};
            },
            bindBuffer: function() {},
            bufferData: function() {},
            clearColor: function() {},
            enable: function() {},
            depthFunc: function() {},
            scissor: function() {},
            clear: function() {},
            TRIANGLES: 4
          };
        };

        return CanvasMock;

      })();
      oo3d = new Main({
        $main: new CanvasMock
      });
      return [oo3d];
    }, "The class and instance are expected types", "The class is a function", ªF, function() {
      return Item.Mesh;
    }, "`new` returns an object", ªO, function(oo3d) {
      return new Item.Mesh(oo3d, 0);
    }, "Item Constructor exceptions", tudor["throw"], "`config.main` must be an object", "/oo3d/src/item/base-item.litcoffee:Item:constructor()\n  `main` is number not object", function(oo3d) {
      return new Item.Mesh(123);
    }, "`config.main` must be an Oo3d instance", "/oo3d/src/item/base-item.litcoffee:Item:constructor()\n  `main` is '[object Object]' not '[object Oo3d]'", function(oo3d) {
      return new Item.Mesh({});
    }, "`index` must be a number", "/oo3d/src/item/base-item.litcoffee:Item:constructor()\n  `index` is boolean not number", function(oo3d) {
      return new Item.Mesh(oo3d, true);
    }, "`index` must be an integer", "/oo3d/src/item/base-item.litcoffee:Item:constructor()\n  `index` is 3.5 not 0 or a positive integer below 2^53", function(oo3d) {
      return new Item.Mesh(oo3d, 3.5);
    }, "`index` must be positive", "/oo3d/src/item/base-item.litcoffee:Item:constructor()\n  `index` is -44 not 0 or a positive integer below 2^53", function(oo3d) {
      return new Item.Mesh(oo3d, -44);
    }, "`index` must be below 2^53", "/oo3d/src/item/base-item.litcoffee:Item:constructor()\n  `index` is 9007199254740992 not 0 or a positive integer below 2^53", function(oo3d) {
      return new Item.Mesh(oo3d, 9007199254740992);
    }, "`config` must be an object", "/oo3d/src/item/base-item.litcoffee:Item:constructor()\n  Optional `config` is date not object", function(oo3d) {
      return new Item.Mesh(oo3d, 0, new Date);
    }, "Item.Mesh Constructor exceptions", "If set, config.positionI must refer to an actual positionBuffer", "/src/item/class-item-mesh.litcoffee:Item.Mesh:constructor()\n  `config.positionI` foo does not exist", function(oo3d) {
      return new Item.Mesh(oo3d, 0, {
        positionI: 'foo'
      });
    }, "If set, config.colorI must refer to an actual colorBuffer", "/src/item/class-item-mesh.litcoffee:Item.Mesh:constructor()\n  `config.colorI` 123 does not exist", function(oo3d) {
      return new Item.Mesh(oo3d, 0, {
        colorI: 123
      });
    }, function(oo3d) {
      oo3d.addPositionBuffer([1, 2, 3]);
      oo3d.addColorBuffer([1, 0, 0, 1, 0, 1, 0, 1]);
      return [oo3d];
    }, "A positionBuffer with one coordinate does not match a colorBuffer with two", "/src/item/class-item-mesh.litcoffee:Item.Mesh:constructor()\n  `config.positionI` mismatches config.colorI", function(oo3d) {
      return new Item.Mesh(oo3d, 0, {
        positionI: 1,
        colorI: 1
      });
    }, "If set, config.renderMode must be a recognised value", "/src/item/class-item-mesh.litcoffee:Item.Mesh:constructor()\n  `config.renderMode` ZERO is not recognised by WebGL", function(oo3d) {
      return new Item.Mesh(oo3d, 0, {
        renderMode: 'ZERO'
      });
    }, "If set, config.blend must be an array", "/src/item/class-item-mesh.litcoffee:Item.Mesh:constructor()\n  If set, `config.blend` must be array not number", function(oo3d) {
      return new Item.Mesh(oo3d, 0, {
        blend: 1
      });
    }, "config.blend[0] (for item.sBlend) must be a recognised value", "/src/item/class-item-mesh.litcoffee:Item.Mesh:constructor()\n  `config.blend[0]` is not recognised by WebGL", function(oo3d) {
      return new Item.Mesh(oo3d, 0, {
        blend: ['TRIANGLES']
      });
    }, "config.blend[1] (for item.dBlend) must be a recognised value", "/src/item/class-item-mesh.litcoffee:Item.Mesh:constructor()\n  `config.blend[1]` is not recognised by WebGL", function(oo3d) {
      return new Item.Mesh(oo3d, 0, {
        blend: ['ZERO']
      });
    }, "Item Constructor usage", tudor.equal, "`config` can be an empty object", '[object Item.Mesh]', function(oo3d) {
      var mesh;
      mesh = new Item.Mesh(oo3d, 0, {});
      return '' + mesh;
    }, "`item.mT` as expected", '1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1', function(oo3d) {
      var mesh, n;
      mesh = new Item.Mesh(oo3d, 0, {});
      return ((function() {
        var j, len, ref, results;
        ref = mesh.mT;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          n = ref[j];
          results.push('' + n);
        }
        return results;
      })()).join(' ');
    }, "`mesh.rX` `mesh.rY` `mesh.rZ` as expected", '0 0 0', function(oo3d) {
      var mesh;
      mesh = new Item.Mesh(oo3d, 0, {});
      return [mesh.rX, mesh.rY, mesh.rZ].join(' ');
    }, "`mesh.sX` `mesh.sY` `mesh.sZ` as expected", '1 1 1', function(oo3d) {
      var mesh;
      mesh = new Item.Mesh(oo3d, 0, {});
      return [mesh.sX, mesh.sY, mesh.sZ].join(' ');
    }, "`mesh.tX` `mesh.tY` `mesh.tZ` as expected", '0 0 0', function(oo3d) {
      var mesh;
      mesh = new Item.Mesh(oo3d, 0, {});
      return [mesh.tX, mesh.tY, mesh.tZ].join(' ');
    }, "Item.Mesh Constructor usage", "Complete set of `config` defaults", 'TRIANGLESnullnull', function(oo3d) {
      var mesh;
      mesh = new Item.Mesh(oo3d, 0, {
        positionI: 0,
        colorI: 0,
        renderMode: null,
        blend: null
      });
      return mesh.renderMode + (ªtype(mesh.sBlend)) + (ªtype(mesh.dBlend));
    }
  ]);

  tudor.add([
    "06 Item.Camera Constructor", tudor.is, "(Mock an `Oo3d` instance)", function() {
      var CanvasMock, oo3d;
      CanvasMock = (function() {
        function CanvasMock() {}

        CanvasMock.prototype.width = 2;

        CanvasMock.prototype.height = 1;

        CanvasMock.prototype.toString = function() {
          return '[object HTMLCanvasElement]';
        };

        CanvasMock.prototype.getContext = function() {
          return {
            createBuffer: function() {
              return {};
            },
            bindBuffer: function() {},
            bufferData: function() {},
            clearColor: function() {},
            enable: function() {},
            depthFunc: function() {},
            scissor: function() {},
            clear: function() {},
            TRIANGLES: 4
          };
        };

        return CanvasMock;

      })();
      oo3d = new Main({
        $main: new CanvasMock
      });
      return [oo3d];
    }, "The class and instance are expected types", "The class is a function", ªF, function() {
      return Item.Camera;
    }, "`new` returns an object", ªO, function(oo3d) {
      return new Item.Camera(oo3d, 0);
    }, "Item Constructor exceptions", tudor["throw"], "`config.main` must be an object", "/oo3d/src/item/base-item.litcoffee:Item:constructor()\n  `main` is number not object", function(oo3d) {
      return new Item.Camera(123);
    }, "`config.main` must be an Oo3d instance", "/oo3d/src/item/base-item.litcoffee:Item:constructor()\n  `main` is '[object Object]' not '[object Oo3d]'", function(oo3d) {
      return new Item.Camera({});
    }, "`index` must be a number", "/oo3d/src/item/base-item.litcoffee:Item:constructor()\n  `index` is boolean not number", function(oo3d) {
      return new Item.Camera(oo3d, true);
    }, "`index` must be an integer", "/oo3d/src/item/base-item.litcoffee:Item:constructor()\n  `index` is 3.5 not 0 or a positive integer below 2^53", function(oo3d) {
      return new Item.Camera(oo3d, 3.5);
    }, "`index` must be positive", "/oo3d/src/item/base-item.litcoffee:Item:constructor()\n  `index` is -44 not 0 or a positive integer below 2^53", function(oo3d) {
      return new Item.Camera(oo3d, -44);
    }, "`index` must be below 2^53", "/oo3d/src/item/base-item.litcoffee:Item:constructor()\n  `index` is 9007199254740992 not 0 or a positive integer below 2^53", function(oo3d) {
      return new Item.Camera(oo3d, 9007199254740992);
    }, "`config` must be an object", "/oo3d/src/item/base-item.litcoffee:Item:constructor()\n  Optional `config` is date not object", function(oo3d) {
      return new Item.Camera(oo3d, 0, new Date);
    }, "Item.Camera Constructor exceptions", "If set, config.fovy must be a number", "/src/item/class-item-camera.litcoffee:Item.Camera:constructor()\n  Optional `config.fovy` is string not number", function(oo3d) {
      return new Item.Camera(oo3d, 0, {
        fovy: 'abc'
      });
    }, "If set, config.fovy must be greater than zero", "/src/item/class-item-camera.litcoffee:Item.Camera:constructor()\n  Optional `config.fovy` is 0 not greater than zero", function(oo3d) {
      return new Item.Camera(oo3d, 0, {
        fovy: 0
      });
    }, "If set, config.aspect must be a number", "/src/item/class-item-camera.litcoffee:Item.Camera:constructor()\n  Optional `config.aspect` is array not number", function(oo3d) {
      return new Item.Camera(oo3d, 0, {
        aspect: []
      });
    }, "If set, config.aspect must be greater than zero", "/src/item/class-item-camera.litcoffee:Item.Camera:constructor()\n  Optional `config.aspect` is -3 not greater than zero", function(oo3d) {
      return new Item.Camera(oo3d, 0, {
        aspect: -3
      });
    }, "Item Constructor usage", tudor.equal, "`config` can be an empty object", '[object Item.Camera]', function(oo3d) {
      var camera;
      camera = new Item.Camera(oo3d, 0, {});
      return '' + camera;
    }, "`item.mT` as expected", '1 0 0 0 0 1 0 0 0 0 1 0 0 0 -4 1', function(oo3d) {
      var camera, n;
      camera = new Item.Camera(oo3d, 0, {});
      return ((function() {
        var j, len, ref, results;
        ref = camera.mT;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          n = ref[j];
          results.push('' + n);
        }
        return results;
      })()).join(' ');
    }, "`camera.rX` `camera.rY` `camera.rZ` as expected", '0 0 0', function(oo3d) {
      var camera;
      camera = new Item.Camera(oo3d, 0, {});
      return [camera.rX, camera.rY, camera.rZ].join(' ');
    }, "`camera.sX` `camera.sY` `camera.sZ` as expected", '1 1 1', function(oo3d) {
      var camera;
      camera = new Item.Camera(oo3d, 0, {});
      return [camera.sX, camera.sY, camera.sZ].join(' ');
    }, "`camera.tX` `camera.tY` `camera.tZ` as expected", '0 0 -4', function(oo3d) {
      var camera;
      camera = new Item.Camera(oo3d, 0, {});
      return [camera.tX, camera.tY, camera.tZ].join(' ');
    }, "Item.Camera Constructor usage", "Complete set of `config` defaults", '0.785398163 2', function(oo3d) {
      var camera;
      camera = new Item.Camera(oo3d, 0);
      return camera.fovy + ' ' + camera.aspect;
    }
  ]);

}).call(this);
