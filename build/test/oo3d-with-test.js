// Generated by CoffeeScript 1.9.2

/*! Oo3d 0.0.52 //// MIT Licence //// http://oo3d.richplastow.com/ */

(function() {
  var Buffer, Item, Layer, Main, Nwang, Program, Renderer, Tudor, mat4, mockOo3d, pick, tudor, uri, ª, ªA, ªB, ªC, ªE, ªF, ªMAX, ªMIN, ªN, ªO, ªR, ªS, ªU, ªV, ªW, ªX, ªex, ªhas, ªis, ªisU, ªredefine, ªtype, ªuid,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  ªC = 'Oo3d';

  ªV = '0.0.52';

  ªA = 'array';

  ªB = 'boolean';

  ªE = 'error';

  ªF = 'function';

  ªN = 'number';

  ªO = 'object';

  ªR = 'regexp';

  ªS = 'string';

  ªU = 'undefined';

  ªX = 'null';

  ªMAX = 9007199254740991;

  ªMIN = -9007199254740991;

  ªW = this;

  ª = console.log.bind(console);

  ªex = function(x, a, b) {
    var pos;
    if (-1 === (pos = a.indexOf(x))) {
      return x;
    } else {
      return b.charAt(pos);
    }
  };

  ªis = function(c, t, f) {
    if (t == null) {
      t = true;
    }
    if (f == null) {
      f = false;
    }
    if (c) {
      return t;
    } else {
      return f;
    }
  };

  ªhas = function(h, n, t, f) {
    if (t == null) {
      t = true;
    }
    if (f == null) {
      f = false;
    }
    if (-1 !== h.indexOf(n)) {
      return t;
    } else {
      return f;
    }
  };

  ªtype = function(x) {
    return {}.toString.call(x).match(/\s([a-z0-9]+)/i)[1].toLowerCase();
  };

  ªisU = function(x) {
    return ªU === typeof x;
  };

  ªuid = function(p) {
    return p + '_' + (Math.random() + '1111111111111111').slice(2, 18);
  };

  ªredefine = function(obj, name, value, kind) {
    switch (kind) {
      case 'constant':
        return Object.defineProperty(obj, name, {
          value: value,
          enumerable: true
        });
      case 'private':
        return Object.defineProperty(obj, name, {
          value: value,
          enumerable: false
        });
    }
  };

  Main = (function() {
    Main.prototype.C = 'Oo3d';

    Main.prototype.toString = function() {
      return "[object Oo3d]";
    };

    function Main(config) {
      var M, k, v;
      if (config == null) {
        config = {};
      }
      M = "/oo3d/src/class-main.litcoffee Oo3d()\n  ";
      if (ªO !== ªtype(config)) {
        throw TypeError(M + "Optional `config` is " + (ªtype(config)) + " not object");
      }
      for (k in config) {
        v = config[k];
        this[k] = v;
      }
      if (!Nwang) {
        throw Error(M + "Dependency 'Nwang' could not be found");
      }
      this.nwang = new Nwang;
      this.$main = config.$main || null;
      if (this.$main && '[object HTMLCanvasElement]' !== '' + this.$main) {
        throw TypeError(M + "Optional `config.$main` is " + (ªtype(this.$main)) + " not HTMLCanvasElement");
      }
      this.oT = config.oT || 'trs';
      if (!{
        'trs': 1,
        'rts': 1,
        'srt': 1
      }[this.oT]) {
        throw RangeError(M + "Optional `config.oT` is not 'trs|rts|srt'");
      }
      if (!config.bkgnd) {
        this.bkgndR = this.bkgndG = this.bkgndB = 0.25;
        this.bkgndA = 1;
      } else if ('float32array' === ªtype(config.bkgnd)) {
        if (4 !== config.bkgnd.length) {
          throw Error(M + "If set `config.bkgnd` must contain four elements");
        }
        this.bkgndR = config.bkgnd[0] || 0;
        this.bkgndG = config.bkgnd[1] || 0;
        this.bkgndB = config.bkgnd[2] || 0;
        this.bkgndA = config.bkgnd[3] || 0;
        if (0 > this.bkgndR || this.bkgndR > 1) {
          throw RangeError(M + "`config.bkgnd[0]` (red) is not within range 0-1");
        }
        if (0 > this.bkgndG || this.bkgndG > 1) {
          throw RangeError(M + "`config.bkgnd[1]` (green) is not within range 0-1");
        }
        if (0 > this.bkgndB || this.bkgndB > 1) {
          throw RangeError(M + "`config.bkgnd[2]` (blue) is not within range 0-1");
        }
        if (0 > this.bkgndA || this.bkgndA > 1) {
          throw RangeError(M + "`config.bkgnd[3]` (alpha) is not within range 0-1");
        }
      } else {
        throw TypeError(M + "Optional `config.bkgnd` is " + (ªtype(config.bkgnd)) + " not float32array");
      }
      this.gl = null;
      this._all = [];
      this.layers = [];
      if (this.$main) {
        this.initGL();
        if (this.gl) {
          this.initCanvas();
          this.initBuffers();
        }
      }
    }

    Main.prototype.initGL = function() {
      var M, ctx, j, len, ref;
      M = this.C + ":initGL()\n  ";
      try {
        ref = ['webgl', 'experimental-webgl'];
        for (j = 0, len = ref.length; j < len; j++) {
          ctx = ref[j];
          this.gl = this.$main.getContext(ctx, {
            preserveDrawingBuffer: true
          });
          if (this.gl) {
            break;
          }
        }
      } catch (_error) {

      }
      if (!this.gl) {
        throw Error(M + "Unable to initialize WebGL. Your browser may not support it.");
      }
    };

    Main.prototype.initCanvas = function() {
      this.gl.clearColor(this.bkgndR, this.bkgndG, this.bkgndB, this.bkgndA);
      this.gl.enable(this.gl.DEPTH_TEST);
      this.gl.enable(this.gl.SCISSOR_TEST);
      this.gl.depthFunc(this.gl.LEQUAL);
      this.gl.scissor(0, 0, this.$main.width, this.$main.height);
      this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
      return this.gl.enable(this.gl.VERTEX_PROGRAM_POINT_SIZE);
    };

    Main.prototype.initBuffers = function() {
      this.add('Buffer.Position', {
        data: []
      });
      return this.add('Buffer.Color', {
        data: []
      });
    };

    Main.prototype.cleanUp = function() {};

    Main.prototype.browse = function(search) {
      var M;
      M = "/oo3d/src/class-main.litcoffee Main:browse()\n  ";
      return [];
    };

    Main.prototype.read = function(target, format) {
      var M;
      M = "/oo3d/src/class-main.litcoffee Main:read()\n  ";
      return this._all[target].read(format);
    };

    Main.prototype.edit = function(target, set, delta) {
      var M;
      M = "/oo3d/src/class-main.litcoffee Main:edit()\n  ";
      this._all[target].edit(set, delta);
      return this;
    };

    Main.prototype.add = function(className, config) {
      var M, base, child, index, k, lut, parts;
      M = "/oo3d/src/class-main.litcoffee Main:add()\n  ";
      index = this._all.length;
      if (ªS !== typeof className) {
        throw TypeError(M + "`className` is " + (ªtype(className)) + " not string");
      }
      parts = className.split('.');
      if (2 !== parts.length) {
        throw RangeError(M + "`className` must be in 2 parts, not " + parts.length);
      }
      lut = {
        'Buffer': Buffer,
        'Item': Item,
        'Layer': Layer,
        'Program': Program,
        'Renderer': Renderer
      };
      base = lut[parts[0]];
      if (!base) {
        throw RangeError(M + "`className` base must be '" + (((function() {
          var results;
          results = [];
          for (k in lut) {
            results.push(k);
          }
          return results;
        })()).join('|')) + "'");
      }
      child = base[parts[1]];
      if (!child) {
        throw RangeError(M + "For `className` '" + parts[0] + "' use '" + (((function() {
          var results;
          results = [];
          for (k in base) {
            results.push(k);
          }
          return results;
        })()).join('|')) + "'");
      }
      this._all[index] = new child(this, index, config);
      if ('Layer' === parts[0]) {
        this.layers.push(this._all[index]);
      }
      return index;
    };

    Main.prototype["delete"] = function(target) {
      var M;
      M = "/oo3d/src/class-main.litcoffee Main:delete()\n  ";
      ª(M + "@todo");
      return this;
    };

    Main.prototype.rotate = function(x, y, z, targetIndex) {
      var c, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, mat, s, target, x0, y0, z0;
      target = this.meshes[targetIndex] || this.cameras[0];
      mat = target.mT;
      x0 = 0 === x;
      y0 = 0 === y;
      z0 = 0 === z;
      if (x0 && y0 && z0) {
        return this;
      } else if (y0 && z0) {
        s = Math.sin(x);
        c = Math.cos(x);
        m10 = mat[4];
        m11 = mat[5];
        m12 = mat[6];
        m13 = mat[7];
        m20 = mat[8];
        m21 = mat[9];
        m22 = mat[10];
        m23 = mat[11];
        mat[4] = m10 * c + m20 * s;
        mat[5] = m11 * c + m21 * s;
        mat[6] = m12 * c + m22 * s;
        mat[7] = m13 * c + m23 * s;
        mat[8] = m20 * c - m10 * s;
        mat[9] = m21 * c - m11 * s;
        mat[10] = m22 * c - m12 * s;
        mat[11] = m23 * c - m13 * s;
        target.rX += x;
      } else if (x0 && z0) {
        s = Math.sin(y);
        c = Math.cos(y);
        m00 = mat[0];
        m01 = mat[1];
        m02 = mat[2];
        m03 = mat[3];
        m20 = mat[8];
        m21 = mat[9];
        m22 = mat[10];
        m23 = mat[11];
        mat[0] = m00 * c - m20 * s;
        mat[1] = m01 * c - m21 * s;
        mat[2] = m02 * c - m22 * s;
        mat[3] = m03 * c - m23 * s;
        mat[8] = m00 * s + m20 * c;
        mat[9] = m01 * s + m21 * c;
        mat[10] = m02 * s + m22 * c;
        mat[11] = m03 * s + m23 * c;
        target.rY += y;
      } else if (x0 && y0) {
        s = Math.sin(z);
        c = Math.cos(z);
        m00 = mat[0];
        m01 = mat[1];
        m02 = mat[2];
        m03 = mat[3];
        m10 = mat[4];
        m11 = mat[5];
        m12 = mat[6];
        m13 = mat[7];
        mat[0] = m00 * c + m10 * s;
        mat[1] = m01 * c + m11 * s;
        mat[2] = m02 * c + m12 * s;
        mat[3] = m03 * c + m13 * s;
        mat[4] = m10 * c - m00 * s;
        mat[5] = m11 * c - m01 * s;
        mat[6] = m12 * c - m02 * s;
        mat[7] = m13 * c - m03 * s;
        target.rZ += z;
      } else {
        this.rotate(x, 0, 0, targetIndex);
        this.rotate(0, y, 0, targetIndex);
        this.rotate(0, 0, z, targetIndex);
      }
      if (target === this.cameras[0]) {
        this.cameras[0].updateCamera();
      }
      return this;
    };

    Main.prototype.scale = function(x, y, z, targetIndex) {
      var mat, target, x1, y1, z1;
      target = this.meshes[targetIndex] || this.cameras[0];
      mat = target.mT;
      x1 = 1 === x;
      y1 = 1 === y;
      z1 = 1 === z;
      if (!x1) {
        mat[0] *= x;
        mat[1] *= x;
        mat[2] *= x;
        mat[3] *= x;
        target.sX *= x;
      }
      if (!y1) {
        mat[4] *= y;
        mat[5] *= y;
        mat[6] *= y;
        mat[7] *= y;
        target.sY *= y;
      }
      if (!z1) {
        mat[8] *= z;
        mat[9] *= z;
        mat[10] *= z;
        mat[11] *= z;
        target.sZ *= z;
      }
      if (target === this.cameras[0]) {
        this.cameras[0].updateCamera();
      }
      return this;
    };

    Main.prototype.translate = function(x, y, z, targetIndex) {
      var mat, target, x0, y0, z0;
      target = this.meshes[targetIndex] || this.cameras[0];
      mat = target.mT;
      x0 = 0 === x;
      y0 = 0 === y;
      z0 = 0 === z;
      if (x0 && y0 && z0) {
        return this;
      } else if (y0 && z0) {
        mat[12] += mat[0] * x;
        mat[13] += mat[1] * x;
        mat[14] += mat[2] * x;
        mat[15] += mat[3] * x;
        target.tX += x;
      } else if (x0 && z0) {
        mat[12] += mat[4] * y;
        mat[13] += mat[5] * y;
        mat[14] += mat[6] * y;
        mat[15] += mat[7] * y;
        target.tY += y;
      } else if (x0 && y0) {
        mat[12] += mat[8] * z;
        mat[13] += mat[9] * z;
        mat[14] += mat[10] * z;
        mat[15] += mat[11] * z;
        target.tZ += z;
      } else {
        mat[12] += mat[0] * x + mat[4] * y + mat[8] * z;
        mat[13] += mat[1] * x + mat[5] * y + mat[9] * z;
        mat[14] += mat[2] * x + mat[6] * y + mat[10] * z;
        mat[15] += mat[3] * x + mat[7] * y + mat[11] * z;
        target.tX += x;
        target.tY += y;
        target.tZ += z;
      }
      if (target === this.cameras[0]) {
        this.cameras[0].updateCamera();
      }
      return this;
    };

    Main.prototype.resetTransform = function(targetIndex) {
      var mat, target;
      target = this.meshes[targetIndex] || this.cameras[0];
      mat = target.mT;
      target.rX = target.rY = target.rZ = 0;
      target.sX = target.sY = target.sZ = 1;
      target.tX = target.tY = target.tZ = 0;
      target.mT = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
      if (target === this.cameras[0]) {
        this.cameras[0].tZ = -4;
        this.cameras[0].mT[14] = -4;
        this.cameras[0].updateCamera();
      }
      return this;
    };

    Main.prototype.setRenderMode = function(renderMode, targetIndex) {
      if (!this._all[targetIndex]) {
        return;
      }
      this._all[targetIndex].renderMode = renderMode;
      return this;
    };

    Main.prototype.getColorAt = function(x, y) {
      var pixels;
      pixels = new Uint8Array(4);
      this.gl.readPixels(x, y, 1, 1, this.gl.RGBA, this.gl.UNSIGNED_BYTE, pixels);
      return pixels;
    };

    Main.prototype.getMeshIByColor = function(color) {
      var index;
      index = pick.colorToIndex(color);
      return index;
    };

    Main.prototype.getCameraSnapshot = function(cameraI) {
      var camera, mat;
      camera = this.cameras[cameraI];
      mat = new Float32Array(16);
      mat.set(camera.mT);
      return {
        mat: mat,
        rX: camera.rX,
        rY: camera.rY,
        rZ: camera.rZ,
        sX: camera.sX,
        sY: camera.sY,
        sZ: camera.sZ,
        tX: camera.tX,
        tY: camera.tY,
        tZ: camera.tZ
      };
    };

    Main.prototype.getMeshSnapshot = function(meshI) {
      var item, mat;
      item = this.meshes[meshI];
      mat = new Float32Array(16);
      mat.set(item.mT);
      return {
        mat: mat,
        rX: item.rX,
        rY: item.rY,
        rZ: item.rZ,
        sX: item.sX,
        sY: item.sY,
        sZ: item.sZ,
        tX: item.tX,
        tY: item.tY,
        tZ: item.tZ
      };
    };

    Main.prototype.setCameraSnapshot = function(snapshot, cameraI) {
      var camera;
      camera = this.cameras[cameraI];
      camera.mT = new Float32Array(16);
      camera.mT.set(snapshot.mat);
      camera.rX = snapshot.rX;
      camera.rY = snapshot.rY;
      camera.rZ = snapshot.rZ;
      camera.sX = snapshot.sX;
      camera.sY = snapshot.sY;
      camera.sZ = snapshot.sZ;
      camera.tX = snapshot.tX;
      camera.tY = snapshot.tY;
      camera.tZ = snapshot.tZ;
      return this;
    };

    Main.prototype.setMeshSnapshot = function(snapshot, meshI) {
      var item;
      item = this.meshes[meshI];
      item.mT = new Float32Array(16);
      item.mT.set(snapshot.mat);
      item.rX = snapshot.rX;
      item.rY = snapshot.rY;
      item.rZ = snapshot.rZ;
      item.sX = snapshot.sX;
      item.sY = snapshot.sY;
      item.sZ = snapshot.sZ;
      item.tX = snapshot.tX;
      item.tY = snapshot.tY;
      item.tZ = snapshot.tZ;
      return this;
    };

    Main.prototype.render = function() {
      var j, layer, len, ref;
      if (!this.gl) {
        throw Error("The WebGL rendering context is " + (ªtype(this.gl)));
      }
      this.gl.clearColor(this.bkgndR, this.bkgndG, this.bkgndB, this.bkgndA);
      this.gl.scissor(0, 0, this.$main.width, this.$main.height);
      this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
      ref = this.layers;
      for (j = 0, len = ref.length; j < len; j++) {
        layer = ref[j];
        layer.render();
      }
      return this;
    };

    return Main;

  })();

  if (ªF === typeof define && define.amd) {
    define(function() {
      return Main;
    });
  } else if (ªO === typeof module && module && module.exports) {
    module.exports = Main;
  } else {
    ªW[ªC] = Main;
  }

  if (ªF === typeof define && define.amd) {

  } else if (ªO === typeof module && module && module.exports) {
    Nwang = require('nwang');
  } else {
    Nwang = window.Nwang;
  }

  mat4 = {};

  mat4.multiply = function(a, b) {
    var a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23, a30, a31, a32, a33, b0, b1, b2, b3, out;
    out = new Float32Array(16);
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    a30 = a[12];
    a31 = a[13];
    a32 = a[14];
    a33 = a[15];
    b0 = b[0];
    b1 = b[1];
    b2 = b[2];
    b3 = b[3];
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return out;
  };

  mat4.perspective = function(fovy, aspect, near, far) {
    var f, nf, out;
    f = 1.0 / Math.tan(fovy / 2);
    nf = 1 / (near - far);
    out = new Float32Array(16);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (2 * far * near) * nf;
    out[15] = 0;
    return out;
  };

  mat4.rotateX = function(a, rad) {
    var a10, a11, a12, a13, a20, a21, a22, a23, c, s;
    s = Math.sin(rad);
    c = Math.cos(rad);
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    a[4] = a10 * c + a20 * s;
    a[5] = a11 * c + a21 * s;
    a[6] = a12 * c + a22 * s;
    a[7] = a13 * c + a23 * s;
    a[8] = a20 * c - a10 * s;
    a[9] = a21 * c - a11 * s;
    a[10] = a22 * c - a12 * s;
    a[11] = a23 * c - a13 * s;
    return a;
  };

  mat4.rotateY = function(a, rad) {
    var a00, a01, a02, a03, a20, a21, a22, a23, c, s;
    s = Math.sin(rad);
    c = Math.cos(rad);
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    a[0] = a00 * c - a20 * s;
    a[1] = a01 * c - a21 * s;
    a[2] = a02 * c - a22 * s;
    a[3] = a03 * c - a23 * s;
    a[8] = a00 * s + a20 * c;
    a[9] = a01 * s + a21 * c;
    a[10] = a02 * s + a22 * c;
    a[11] = a03 * s + a23 * c;
    return a;
  };

  mat4.rotateZ = function(a, rad) {
    var a00, a01, a02, a03, a10, a11, a12, a13, c, s;
    s = Math.sin(rad);
    c = Math.cos(rad);
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a[0] = a00 * c + a10 * s;
    a[1] = a01 * c + a11 * s;
    a[2] = a02 * c + a12 * s;
    a[3] = a03 * c + a13 * s;
    a[4] = a10 * c - a00 * s;
    a[5] = a11 * c - a01 * s;
    a[6] = a12 * c - a02 * s;
    a[7] = a13 * c - a03 * s;
    return a;
  };

  mat4.translate = function(a, x, y, z) {
    a[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    a[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    a[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    a[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    return a;
  };

  mat4.ortho = function(left, right, bottom, top, near, far) {
    var bt, lr, nf, out;
    lr = 1 / (left - right);
    bt = 1 / (bottom - top);
    nf = 1 / (near - far);
    out = new Float32Array(16);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
  };

  mat4.makeTranslation = function(tx, ty, tz) {
    return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, tz, 1]);
  };

  mat4.makeXRotation = function(angleInRadians) {
    var c, s;
    c = Math.cos(angleInRadians);
    s = Math.sin(angleInRadians);
    return new Float32Array([1, 0, 0, 0, 0, c, s, 0, 0, -s, c, 0, 0, 0, 0, 1]);
  };

  mat4.makeYRotation = function(angleInRadians) {
    var c, s;
    c = Math.cos(angleInRadians);
    s = Math.sin(angleInRadians);
    return new Float32Array([c, 0, -s, 0, 0, 1, 0, 0, s, 0, c, 0, 0, 0, 0, 1]);
  };

  mat4.makeZRotation = function(angleInRadians) {
    var c, s;
    c = Math.cos(angleInRadians);
    s = Math.sin(angleInRadians);
    return new Float32Array([c, s, 0, 0, -s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
  };

  mat4.makeScale = function(sx, sy, sz) {
    return new Float32Array([sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1]);
  };

  mat4.makeProjection = function(width, height, depth) {
    return new Float32Array([2 / width, 0, 0, 0, 0, -2 / height, 0, 0, 0, 0, 2 / depth, 0, -1, 1, 0, 1]);
  };

  pick = {};

  pick.indexToColor = function(index) {
    var b, g, i, r;
    i = ('00000000000000000000000' + index.toString(2)).slice(-24).split('');
    r = "" + i[23] + i[20] + i[17] + i[14] + i[11] + i[8] + i[5] + i[2];
    g = "" + i[22] + i[19] + i[16] + i[13] + i[10] + i[7] + i[4] + i[1];
    b = "" + i[21] + i[18] + i[15] + i[12] + i[9] + i[6] + i[3] + i[0];
    return new Float32Array([parseInt(r, 2) / 255, parseInt(g, 2) / 255, parseInt(b, 2) / 255, 1.0]);
  };

  pick.colorToIndex = function(color) {
    var b, g, i, r;
    r = ('0000000' + color[0].toString(2)).slice(-8).split('');
    g = ('0000000' + color[1].toString(2)).slice(-8).split('');
    b = ('0000000' + color[2].toString(2)).slice(-8).split('');
    i = ("" + b[7] + g[7] + r[7]) + ("" + b[6] + g[6] + r[6]) + ("" + b[5] + g[5] + r[5]) + ("" + b[4] + g[4] + r[4]) + ("" + b[3] + g[3] + r[3]) + ("" + b[2] + g[2] + r[2]) + ("" + b[1] + g[1] + r[1]) + ("" + b[0] + g[0] + r[0]);
    return parseInt(i, 2);
  };

  pick.qikColorToIndex = function(color) {
    var b, g, i, r;
    r = (color[0].toString(2)).split('');
    g = (color[1].toString(2)).split('');
    b = (color[2].toString(2)).split('');
    i = ("" + (b[2] || 0) + (g[2] || 0) + (r[2] || 0)) + ("" + (b[1] || 0) + (g[1] || 0) + (r[1] || 0)) + ("" + b[0] + g[0] + r[0]);
    return parseInt(i, 2);
  };

  uri = {};

  uri.r2Tenmin = function(r) {
    return Math.round(r * uri.RESOLUTION_R);
  };

  uri.tenmin2r = function(r) {
    return r / uri.RESOLUTION_R;
  };

  uri.r2uri = function(radians) {
    var PI2, c1, c1i, c2, c2i, tenmin;
    PI2 = Math.PI * 2;
    radians = radians % PI2;
    if (0 > radians) {
      radians += PI2;
    }
    tenmin = uri.r2Tenmin(radians);
    c1 = uri.USUAL_R2URI[tenmin];
    if (c1) {
      return c1;
    }
    c1i = tenmin % 36;
    c2i = (tenmin - c1i) / 36;
    c1 = "0123456789abcdefghijklmnopqrstuvwxyz"[c1i];
    c2 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWX"[c2i];
    return '' + c1 + c2;
  };

  uri.s2uri = function(s) {
    var c1, c2, c3, m, n, nM64, neg;
    if (0 > s) {
      neg = true;
      s = Math.abs(s);
    }
    if (0.0001 > s) {
      return 'A';
    }
    if (0.001 > s) {
      m = neg ? 'a' : 'p';
      n = s * 10000000;
    } else if (0.01 > s) {
      m = neg ? 'b' : 'o';
      n = s * 1000000;
    } else if (0.1 > s) {
      m = neg ? 'c' : 'n';
      n = s * 100000;
    } else if (1 > s) {
      m = neg ? 'd' : 'm';
      n = s * 10000;
    } else if (10 > s) {
      m = neg ? 'e' : 'l';
      n = s * 1000;
    } else if (100 > s) {
      m = neg ? 'f' : 'k';
      n = s * 100;
    } else if (1000 > s) {
      m = neg ? 'g' : 'j';
      n = s * 10;
    } else if (10000 > s) {
      m = neg ? 'h' : 'i';
      n = s;
    } else {
      return 'Z';
    }
    n = n / 4;
    n = Math.floor(n);
    c1 = uri.USUAL_S2URI[m + n];
    if (c1) {
      return c1;
    }
    nM64 = n % 64;
    c1 = m;
    c2 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-"[nM64];
    c3 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-"[(n - nM64) / 64];
    if (ªU === typeof c1 || ªU === typeof c2 || ªU === typeof c3) {
      ª('UNDEFINED RESULT s2uri(' + s + ')', n, nM64, (n - nM64) / 64, '' + c1 + c2 + c3);
    }
    return c1 + c2 + c3;
  };

  uri.t2uri = function(t) {
    var c1, c2, c3, m, n, nM64, neg;
    if (0 > t) {
      neg = true;
      t = Math.abs(t);
    }
    if (0.0001 > t) {
      return 'A';
    }
    if (0.001 > t) {
      m = neg ? 'a' : 'p';
      n = t * 10000000;
    } else if (0.01 > t) {
      m = neg ? 'b' : 'o';
      n = t * 1000000;
    } else if (0.1 > t) {
      m = neg ? 'c' : 'n';
      n = t * 100000;
    } else if (1 > t) {
      m = neg ? 'd' : 'm';
      n = t * 10000;
    } else if (10 > t) {
      m = neg ? 'e' : 'l';
      n = t * 1000;
    } else if (100 > t) {
      m = neg ? 'f' : 'k';
      n = t * 100;
    } else if (1000 > t) {
      m = neg ? 'g' : 'j';
      n = t * 10;
    } else if (10000 > t) {
      m = neg ? 'h' : 'i';
      n = t;
    } else {
      return 'Z';
    }
    n = n / 4;
    n = Math.floor(n);
    c1 = uri.USUAL_T2URI[m + n];
    if (c1) {
      return c1;
    }
    nM64 = n % 64;
    c1 = m;
    c2 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-"[nM64];
    c3 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-"[(n - nM64) / 64];
    if (ªU === typeof c1 || ªU === typeof c2 || ªU === typeof c3) {
      ª('UNDEFINED RESULT t2uri(' + t + ')', n, nM64, (n - nM64) / 64, '' + c1 + c2 + c3);
    }
    return c1 + c2 + c3;
  };

  uri.uri2r = function(str) {
    var c1, c2, usual;
    usual = uri.USUAL_URI2R[str];
    if (ªN === typeof usual) {
      return uri.tenmin2r(usual);
    }
    c1 = uri.B64DECODE[str[0]];
    c2 = uri.B64DECODE[str[1]];
    return uri.tenmin2r(c1 * 60 + c2);
  };

  uri.uri2s = function(str) {
    var c1, c2, c3, usual;
    usual = uri.USUAL_URI2S[str];
    if (ªN === typeof usual) {
      return usual;
    }
    c1 = uri.MULTIPLIER[str[0]];
    c2 = uri.B64DECODE[str[1]];
    c3 = uri.B64DECODE[str[2]];
    return c1 * (c2 + c3 * 64 * 4);
  };

  uri.uri2t = function(str) {
    var c1, c2, c3, usual;
    usual = uri.USUAL_URI2T[str];
    if (ªN === typeof usual) {
      return usual;
    }
    c1 = uri.MULTIPLIER[str[0]];
    c2 = uri.B64DECODE[str[1]];
    c3 = uri.B64DECODE[str[2]];
    return c1 * (c2 + c3 * 64 * 4);
  };

  uri.RESOLUTION_R = 1 / (Math.PI * 2 / 36 / 60);

  uri.USUAL_R2URI = (function() {
    var PI, out;
    PI = Math.PI;
    out = {};
    out[0] = 'A';
    out[uri.r2Tenmin(PI / 6.0)] = 'B';
    out[uri.r2Tenmin(PI / 4.0)] = 'C';
    out[uri.r2Tenmin(PI / 3.0)] = 'D';
    out[uri.r2Tenmin(PI * 0.5)] = 'E';
    out[uri.r2Tenmin(PI / 1.5)] = 'F';
    out[uri.r2Tenmin(PI * 0.75)] = 'G';
    out[uri.r2Tenmin(PI / 1.2)] = 'H';
    out[uri.r2Tenmin(PI)] = 'I';
    out[uri.r2Tenmin(PI / 6.0 + PI)] = 'J';
    out[uri.r2Tenmin(PI / 4.0 + PI)] = 'K';
    out[uri.r2Tenmin(PI / 3.0 + PI)] = 'L';
    out[uri.r2Tenmin(PI * 1.5)] = 'M';
    out[uri.r2Tenmin(PI / 1.5 + PI)] = 'N';
    out[uri.r2Tenmin(PI * 1.75)] = 'O';
    out[uri.r2Tenmin(PI / 1.2 + PI)] = 'P';
    out[uri.r2Tenmin(PI * 2.0)] = 'Q';
    return out;
  })();

  uri.USUAL_URI2R = (function() {
    var key, out, ref, val;
    out = {};
    ref = uri.USUAL_R2URI;
    for (key in ref) {
      val = ref[key];
      out[val] = +key;
    }
    return out;
  })();

  uri.USUAL_S2URI = {
    d1250: 'C',
    d2500: 'D',
    d5000: 'E',
    e1000: 'F',
    e2000: 'G',
    e4000: 'H',
    e8000: 'I',
    m1250: 'R',
    m2500: 'S',
    m5000: 'T',
    l1000: 'U',
    l2000: 'V',
    l4000: 'W',
    l8000: 'X'
  };

  uri.USUAL_URI2S = {
    A: 0,
    C: -0.125,
    D: -0.25,
    E: -0.5,
    F: -1,
    G: -2,
    H: -4,
    I: -8,
    R: 0.125,
    S: 0.25,
    T: 0.5,
    U: 1,
    V: 2,
    W: 4,
    X: 8,
    Z: 10000
  };

  uri.USUAL_T2URI = {
    d1250: 'C',
    d2500: 'D',
    d5000: 'E',
    e1000: 'F',
    e2000: 'G',
    e4000: 'H',
    e8000: 'I',
    m1250: 'R',
    m2500: 'S',
    m5000: 'T',
    l1000: 'U',
    l2000: 'V',
    l4000: 'W',
    l8000: 'X'
  };

  uri.USUAL_URI2T = {
    A: 0,
    C: -0.125,
    D: -0.25,
    E: -0.5,
    F: -1,
    G: -2,
    H: -4,
    I: -8,
    R: 0.125,
    S: 0.25,
    T: 0.5,
    U: 1,
    V: 2,
    W: 4,
    X: 8,
    Z: 10000
  };

  uri.MULTIPLIER = {
    a: -1 / 10000000,
    b: -1 / 1000000,
    c: -1 / 100000,
    d: -1 / 10000,
    e: -1 / 1000,
    f: -1 / 100,
    g: -1 / 10,
    h: -1,
    p: 1 / 10000000,
    o: 1 / 1000000,
    n: 1 / 100000,
    m: 1 / 10000,
    l: 1 / 1000,
    k: 1 / 100,
    j: 1 / 10,
    i: 1
  };

  uri.B64DECODE = (function() {
    var b64, i, j, out;
    out = {};
    b64 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-";
    for (i = j = 0; j <= 63; i = ++j) {
      out[b64[i]] = i;
    }
    return out;
  })();

  Buffer = (function() {
    Buffer.prototype.C = 'Buffer';

    Buffer.prototype.toString = function() {
      return '[object Buffer]';
    };

    function Buffer(main1, index1, config) {
      var M, gl, tData;
      this.main = main1;
      this.index = index1;
      if (config == null) {
        config = {};
      }
      M = "/oo3d/src/buffer/base-buffer.litcoffee Buffer#" + (+this.index) + "()\n  ";
      if (ªO !== ªtype(config)) {
        throw TypeError(M + "Optional `config` is " + (ªtype(config)) + " not object");
      }
      if (ªO !== typeof this.main) {
        throw TypeError(M + "`main` is " + (ªtype(this.main)) + " not object");
      }
      if ('[object Oo3d]' !== '' + this.main) {
        throw TypeError(M + "`main` is '" + this.main + "' not '[object Oo3d]'");
      }
      if (ªN !== typeof this.index) {
        throw TypeError(M + "`index` is " + (ªtype(this.index)) + " not number");
      }
      if (ªMAX < this.index || this.index % 1 || 0 > this.index) {
        throw RangeError(M + "`index` is " + this.index + " not 0 or a positive integer below 2^53");
      }
      gl = this.main.gl;
      this.glData = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, this.glData);
      tData = ªtype(config.data);
      if (ªU === tData) {
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([]), gl.STATIC_DRAW);
      } else {
        if (ªA !== tData) {
          throw TypeError(M + "`config.data` is " + tData + " not array");
        }
        if (config.data.some(isNaN)) {
          throw TypeError(M + "`config.data` contains a non-numeric value");
        }
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(config.data), gl.STATIC_DRAW);
      }
    }

    Buffer.prototype.browse = function() {};

    return Buffer;

  })();

  Buffer.Color = (function(superClass) {
    extend(Color, superClass);

    Color.prototype.C = 'Buffer.Color';

    Color.prototype.toString = function() {
      return '[object Buffer.Color]';
    };

    function Color(main, index, config) {
      var M;
      if (config == null) {
        config = {};
      }
      M = "/oo3d/src/buffer/class-buffer-color.litcoffee Buffer.Color#" + (+index) + "()\n  ";
      Color.__super__.constructor.call(this, main, index, config);
      if (ªU === typeof config.data) {
        this.count = 0;
      } else {
        if (config.data.length % 4) {
          throw RangeError(M + "`config.data.length` " + config.data.length + " not divisible by 4");
        }
        this.count = config.data.length / 4;
      }
    }

    Color.prototype.browse = function() {};

    return Color;

  })(Buffer);

  Buffer.Position = (function(superClass) {
    extend(Position, superClass);

    Position.prototype.C = 'Buffer.Position';

    Position.prototype.toString = function() {
      return '[object Buffer.Position]';
    };

    function Position(main, index, config) {
      var M;
      if (config == null) {
        config = {};
      }
      M = "/oo3d/src/buffer/class-buffer-position.litcoffee Buffer.Position#" + (+index) + "()\n  ";
      Position.__super__.constructor.call(this, main, index, config);
      if (ªU === typeof config.data) {
        this.count = 0;
      } else {
        if (config.data.length % 3) {
          throw RangeError(M + "`config.data.length` " + config.data.length + " not divisible by 3");
        }
        this.count = config.data.length / 3;
      }
    }

    Position.prototype.browse = function() {};

    return Position;

  })(Buffer);

  Item = (function() {
    var xx;

    Item.prototype.C = 'Item';

    Item.prototype.toString = function() {
      return '[object Item]';
    };

    function Item(main1, index1, config) {
      var M;
      this.main = main1;
      this.index = index1;
      if (config == null) {
        config = {};
      }
      M = "/oo3d/src/item/base-item.litcoffee Item#" + (+this.index) + "()\n  ";
      if (ªO !== ªtype(config)) {
        throw TypeError(M + "Optional `config` is " + (ªtype(config)) + " not object");
      }
      if (ªO !== typeof this.main) {
        throw TypeError(M + "`main` is " + (ªtype(this.main)) + " not object");
      }
      if ('[object Oo3d]' !== '' + this.main) {
        throw TypeError(M + "`main` is '" + this.main + "' not '[object Oo3d]'");
      }
      if (ªN !== typeof this.index) {
        throw TypeError(M + "`index` is " + (ªtype(this.index)) + " not number");
      }
      if (ªMAX < this.index || this.index % 1 || 0 > this.index) {
        throw RangeError(M + "`index` is " + this.index + " not 0 or a positive integer below 2^53");
      }
      this.oT = config.oT || 'trs';
      if (!{
        'trs': 1,
        'rts': 1,
        'srt': 1
      }[this.oT]) {
        throw RangeError(M + "Optional `config.oT` is not 'trs|rts|srt'");
      }
      this.mT = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
      this.rX = 0;
      this.rY = 0;
      this.rZ = 0;
      this.sX = 1;
      this.sY = 1;
      this.sZ = 1;
      this.tX = 0;
      this.tY = 0;
      this.tZ = 0;
    }

    Item.prototype.browse = function(search) {
      var M;
      M = "/oo3d/src/item/base-item.litcoffee Item#" + this.index + ":browse()\n  ";
      return [];
    };

    Item.prototype.read = function(format) {
      var M, mT, mTCopy, sf3;
      M = "/oo3d/src/item/base-item.litcoffee Item#" + this.index + ":read()\n  ";
      if (ªU === typeof format || 'object' === format) {
        mTCopy = new Float32Array(16);
        mTCopy.set(this.mT);
        return {
          index: this.index,
          mT: mTCopy,
          rX: this.rX,
          rY: this.rY,
          rZ: this.rZ,
          sX: this.sX,
          sY: this.sY,
          sZ: this.sZ,
          tX: this.tX,
          tY: this.tY,
          tZ: this.tZ
        };
      } else if ('log' === format) {
        mT = this.mT;
        return "i " + this.index + " mT " + mT[0] + " " + mT[1] + " " + mT[2] + " " + mT[3] + " " + mT[4] + " " + mT[5] + " " + mT[6] + " " + mT[7] + " " + mT[8] + " " + mT[9] + " " + mT[10] + " " + mT[11] + " " + mT[12] + " " + mT[13] + " " + mT[14] + " " + mT[15] + " r " + this.rX + " " + this.rY + " " + this.rZ + " s " + this.sX + " " + this.sY + " " + this.sZ + " t " + this.tX + " " + this.tY + " " + this.tZ;
      } else if ('nwang' === format) {
        mT = this.mT;
        sf3 = this.main.nwang.sf3;
        return ("" + (sf3(this.index))) + ("" + (sf3(mT[0])) + (sf3(mT[1])) + (sf3(mT[2])) + (sf3(mT[3]))) + ("" + (sf3(mT[4])) + (sf3(mT[5])) + (sf3(mT[6])) + (sf3(mT[7]))) + ("" + (sf3(mT[8])) + (sf3(mT[9])) + (sf3(mT[10])) + (sf3(mT[11]))) + ("" + (sf3(mT[12])) + (sf3(mT[13])) + (sf3(mT[14])) + (sf3(mT[15]))) + ("" + (sf3(this.rX)) + (sf3(this.rY)) + (sf3(this.rZ))) + ("" + (sf3(this.sX)) + (sf3(this.sY)) + (sf3(this.sZ))) + ("" + (sf3(this.tX)) + (sf3(this.tY)) + (sf3(this.tZ)));
      } else if (ªS === typeof format) {
        throw RangeError(M + "Optional `format` is not 'object|log|nwang'");
      } else {
        throw TypeError(M + "Optional `format` is " + (ªtype(format)) + " not string|object");
      }
    };

    Item.prototype.edit = function(set, delta) {
      var M, a, a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23, char, chars, i, j, key, keys, l, len, len1, len2, len3, len4, o, q, rXc, rXs, rYc, rYs, rZc, rZs, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, sf3, stale, tDelta, tMT, tSet, tVal, tmp, u, val, vals;
      M = "/oo3d/src/item/base-item.litcoffee Item#" + this.index + ":edit()\n  ";
      tSet = ªtype(set);
      tDelta = ªtype(delta);
      tmp = {};
      stale = false;
      if (ªU === tSet || ªX === tSet) {
        ref = ['rX', 'rY', 'rZ', 'sX', 'sY', 'sZ', 'tX', 'tY', 'tZ'];
        for (j = 0, len = ref.length; j < len; j++) {
          key = ref[j];
          tmp[key] = this[key];
        }
      } else {
        if (ªO === tSet) {
          if (ªU !== typeof set.index && this.index !== set.index) {
            throw RangeError(M + "`this.index` cannot be altered by `set.index`");
          }
          ref1 = ['rX', 'rY', 'rZ', 'sX', 'sY', 'sZ', 'tX', 'tY', 'tZ'];
          for (l = 0, len1 = ref1.length; l < len1; l++) {
            key = ref1[l];
            val = set[key];
            tVal = typeof val;
            if (ªU === tVal) {
              tmp[key] = this[key];
            } else {
              if (ªN !== tVal) {
                throw TypeError(M + "`set." + key + "` is " + (ªtype(val)) + " not number");
              }
              if (isNaN(val)) {
                throw TypeError(M + "`set." + key + "` is NaN");
              }
              tmp[key] = val;
            }
          }
          if (set.mT) {
            tMT = ªtype(set.mT);
            if (ªA !== tMT.slice(-5)) {
              throw TypeError(M + "`set.TtM` is " + tMT + " not array|*Array");
            }
            if (16 !== set.mT.length) {
              throw RangeError(M + "`set.TtM` has " + set.mT.length + " elements not 16");
            }
            tmp.mT = new Float32Array(16);
            tmp.mT.set(set.mT);
          } else {
            stale = true;
          }
        } else if (ªS !== tSet) {
          throw TypeError(M + "Optional `set` is " + tSet + " not " + ªS + "|object");
        } else if ('reset' === set) {
          this.reset(tmp);
        } else if (0xAFE8 < set.charCodeAt(0)) {
          sf3 = this.main.nwang.sf3;
          if (9 === set.length) {
            ref2 = (function() {
              var len2, o, ref2, results;
              ref2 = set.split('');
              results = [];
              for (o = 0, len2 = ref2.length; o < len2; o++) {
                char = ref2[o];
                results.push(+sf3(char));
              }
              return results;
            })(), tmp.rX = ref2[0], tmp.rY = ref2[1], tmp.rZ = ref2[2], tmp.sX = ref2[3], tmp.sY = ref2[4], tmp.sZ = ref2[5], tmp.tX = ref2[6], tmp.tY = ref2[7], tmp.tZ = ref2[8];
            stale = true;
          } else if (26 === set.length) {
            chars = set.split('');
            if (this.index !== +sf3(chars[0])) {
              throw RangeError(M + "`this.index` cannot be altered by passing `set` an 'nwang'");
            }
            tmp.mT = new Float32Array((function() {
              var o, results;
              results = [];
              for (i = o = 1; o <= 16; i = ++o) {
                results.push(+sf3(chars[i]));
              }
              return results;
            })());
            ref3 = (function() {
              var o, results;
              results = [];
              for (i = o = 17; o <= 25; i = ++o) {
                results.push(+sf3(chars[i]));
              }
              return results;
            })(), tmp.rX = ref3[0], tmp.rY = ref3[1], tmp.rZ = ref3[2], tmp.sX = ref3[3], tmp.sY = ref3[4], tmp.sZ = ref3[5], tmp.tX = ref3[6], tmp.tY = ref3[7], tmp.tZ = ref3[8];
          } else {
            throw RangeError(M + "`set` appears to be 'nwang' but is " + set.length + " characters");
          }
        } else {
          vals = set.split(' ');
          if ('rst' === vals[0] + vals[4] + vals[8]) {
            ref4 = (function() {
              var len2, o, ref4, results;
              ref4 = [1, 2, 3, 5, 6, 7, 9, 10, 11];
              results = [];
              for (o = 0, len2 = ref4.length; o < len2; o++) {
                i = ref4[o];
                val = +vals[i];
                if (!isNaN(val)) {
                  results.push(val);
                } else {
                  throw RangeError(M + "`set` appears to be 9-char 'log' with non-numeric values");
                }
              }
              return results;
            })(), tmp.rX = ref4[0], tmp.rY = ref4[1], tmp.rZ = ref4[2], tmp.sX = ref4[3], tmp.sY = ref4[4], tmp.sZ = ref4[5], tmp.tX = ref4[6], tmp.tY = ref4[7], tmp.tZ = ref4[8];
            stale = true;
          } else if ('imTrst' === vals[0] + vals[2] + vals[19] + vals[23] + vals[27]) {
            if (this.index !== +vals[1]) {
              throw RangeError(M + "`this.index` cannot be altered by passing `set` a 'log'");
            }
            tmp.mT = new Float32Array((function() {
              var o, results;
              results = [];
              for (i = o = 3; o <= 18; i = ++o) {
                results.push(vals[i]);
              }
              return results;
            })());
            ref5 = (function() {
              var len2, o, ref5, results;
              ref5 = [20, 21, 22, 24, 25, 26, 28, 29, 30];
              results = [];
              for (o = 0, len2 = ref5.length; o < len2; o++) {
                i = ref5[o];
                val = +vals[i];
                if (!isNaN(val)) {
                  results.push(val);
                } else {
                  throw RangeError(M + "`set` appears to be 26-char 'log' with non-numeric values");
                }
              }
              return results;
            })(), tmp.rX = ref5[0], tmp.rY = ref5[1], tmp.rZ = ref5[2], tmp.sX = ref5[3], tmp.sY = ref5[4], tmp.sZ = ref5[5], tmp.tX = ref5[6], tmp.tY = ref5[7], tmp.tZ = ref5[8];
          } else {
            throw RangeError(M + "Optional `set` is string but not 'reset' or log|nwang format");
          }
        }
      }
      if (ªU !== tDelta) {
        stale = true;
        if (ªO === tDelta) {
          ref6 = ['rX', 'rY', 'rZ', 'sX', 'sY', 'sZ', 'tX', 'tY', 'tZ'];
          for (o = 0, len2 = ref6.length; o < len2; o++) {
            key = ref6[o];
            val = delta[key];
            tVal = typeof val;
            if (ªU !== tVal) {
              if (ªN !== tVal) {
                throw TypeError(M + "`delta." + key + "` is " + (ªtype(val)) + " not number");
              }
              if (isNaN(val)) {
                throw TypeError(M + "`delta." + key + "` is NaN");
              }
              if ('s' === key.charAt(0)) {
                tmp[key] *= val;
              } else {
                tmp[key] += val;
              }
            }
          }
        } else if (ªS === tDelta && 0xAFE8 < delta.charCodeAt(0)) {
          sf3 = this.main.nwang.sf3;
          if (9 === delta.length) {
            ref7 = ['rX', 'rY', 'rZ', 'sX', 'sY', 'sZ', 'tX', 'tY', 'tZ'];
            for (i = q = 0, len3 = ref7.length; q < len3; i = ++q) {
              key = ref7[i];
              val = +sf3(delta.charAt(i));
              if ('s' === key.charAt(0)) {
                tmp[key] *= val;
              } else {
                tmp[key] += val;
              }
            }
          } else {
            throw RangeError(M + "`delta` appears to be 'nwang' but is " + delta.length + " characters");
          }
        } else if (ªS === tDelta) {
          vals = delta.split(' ');
          if ('rst' === vals[0] + vals[4] + vals[8]) {
            keys = ['-', 'rX', 'rY', 'rZ', '-', 'sX', 'sY', 'sZ', '-', 'tX', 'tY', 'tZ'];
            ref8 = [1, 2, 3, 5, 6, 7, 9, 10, 11];
            for (u = 0, len4 = ref8.length; u < len4; u++) {
              i = ref8[u];
              key = keys[i];
              val = +vals[i];
              if (!isNaN(val)) {
                throw RangeError(M + "`delta` appears to be 9-char 'log' with non-numeric values");
              }
              if (5 <= i && 7 >= i) {
                tmp[key] *= val;
              } else {
                tmp[key] += val;
              }
            }
          } else {
            throw RangeError(M + "Optional `delta` is a string, but not 'log|nwang' format");
          }
        } else if (ªX !== tDelta) {
          throw TypeError(M + "Optional `delta` is " + tDelta + " not string|object");
        }
      }
      for (key in tmp) {
        val = tmp[key];
        this[key] = val;
      }
      if (stale) {
        rXc = Math.cos(this.rX);
        rXs = Math.sin(this.rX);
        rYs = Math.sin(this.rY);
        rYc = Math.cos(this.rY);
        rZs = Math.sin(this.rZ);
        rZc = Math.cos(this.rZ);
        if ('trs' === this.oT) {
          this.mT = new Float32Array([rYc * rZc * this.sX, (rXc * rZs + rXs * rYs * rZc) * this.sX, (rXs * rZs - rXc * rYs * rZc) * this.sX, 0, -rYc * rZs * this.sY, (rXc * rZc - rXs * rYs * rZs) * this.sY, (rXs * rZc + rXc * rYs * rZs) * this.sY, 0, rYs * this.sZ, -rXs * rYc * this.sZ, rXc * rYc * this.sZ, 0, this.tX, this.tY, this.tZ, 1]);
        } else if ('srt' === this.oT) {
          this.mT = new Float32Array([rYc * rZc * this.sX, (rXc * rZs + rXs * rYs * rZc) * this.sY, (rXs * rZs - rXc * rYs * rZc) * this.sZ, 0, -rYc * rZs * this.sX, (rXc * rZc - rXs * rYs * rZs) * this.sY, (rXs * rZc + rXc * rYs * rZs) * this.sZ, 0, rYs * this.sX, -rXs * rYc * this.sY, rXc * rYc * this.sZ, 0, 99, 99, 99, 1]);
          this.mT[12] = this.mT[0] * this.tX + this.mT[4] * this.tY + this.mT[8] * this.tZ;
          this.mT[13] = this.mT[1] * this.tX + this.mT[5] * this.tY + this.mT[9] * this.tZ;
          this.mT[14] = this.mT[2] * this.tX + this.mT[6] * this.tY + this.mT[10] * this.tZ;
        } else if ('rts' === this.oT) {
          a = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
          a10 = a[4];
          a11 = a[5];
          a12 = a[6];
          a13 = a[7];
          a20 = a[8];
          a21 = a[9];
          a22 = a[10];
          a23 = a[11];
          a[4] = a10 * rXc + a20 * rXs;
          a[5] = a11 * rXc + a21 * rXs;
          a[6] = a12 * rXc + a22 * rXs;
          a[7] = a13 * rXc + a23 * rXs;
          a[8] = a20 * rXc - a10 * rXs;
          a[9] = a21 * rXc - a11 * rXs;
          a[10] = a22 * rXc - a12 * rXs;
          a[11] = a23 * rXc - a13 * rXs;
          a00 = a[0];
          a01 = a[1];
          a02 = a[2];
          a03 = a[3];
          a20 = a[8];
          a21 = a[9];
          a22 = a[10];
          a23 = a[11];
          a[0] = a00 * rYc - a20 * rYs;
          a[1] = a01 * rYc - a21 * rYs;
          a[2] = a02 * rYc - a22 * rYs;
          a[3] = a03 * rYc - a23 * rYs;
          a[8] = a00 * rYs + a20 * rYc;
          a[9] = a01 * rYs + a21 * rYc;
          a[10] = a02 * rYs + a22 * rYc;
          a[11] = a03 * rYs + a23 * rYc;
          a00 = a[0];
          a01 = a[1];
          a02 = a[2];
          a03 = a[3];
          a10 = a[4];
          a11 = a[5];
          a12 = a[6];
          a13 = a[7];
          a[0] = a00 * rZc + a10 * rZs;
          a[1] = a01 * rZc + a11 * rZs;
          a[2] = a02 * rZc + a12 * rZs;
          a[3] = a03 * rZc + a13 * rZs;
          a[4] = a10 * rZc - a00 * rZs;
          a[5] = a11 * rZc - a01 * rZs;
          a[6] = a12 * rZc - a02 * rZs;
          a[7] = a13 * rZc - a03 * rZs;
          a[12] = a[0] * this.tX + a[4] * this.tY + a[8] * this.tZ + a[12];
          a[13] = a[1] * this.tX + a[5] * this.tY + a[9] * this.tZ + a[13];
          a[14] = a[2] * this.tX + a[6] * this.tY + a[10] * this.tZ + a[14];
          a[15] = a[3] * this.tX + a[7] * this.tY + a[11] * this.tZ + a[15];
          a[0] *= this.sX;
          a[1] *= this.sX;
          a[2] *= this.sX;
          a[3] *= this.sX;
          a[4] *= this.sY;
          a[5] *= this.sY;
          a[6] *= this.sY;
          a[7] *= this.sY;
          a[8] *= this.sZ;
          a[9] *= this.sZ;
          a[10] *= this.sZ;
          a[11] *= this.sZ;
          this.mT = a;
        }
      }
      return this;
    };

    Item.prototype.reset = function(subject) {
      var M;
      M = "/oo3d/src/item/base-item.litcoffee Item#" + this.index + ":reset()\n  ";
      subject.mT = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
      subject.rX = 0;
      subject.rY = 0;
      subject.rZ = 0;
      subject.sX = 1;
      subject.sY = 1;
      subject.sZ = 1;
      subject.tX = 0;
      subject.tY = 0;
      subject.tZ = 0;
      return subject;
    };

    xx = function() {};

    return Item;

  })();

  Item.Camera = (function(superClass) {
    extend(Camera, superClass);

    Camera.prototype.C = 'Item.Camera';

    Camera.prototype.toString = function() {
      return '[object Item.Camera]';
    };

    function Camera(main, index, config) {
      var M;
      if (config == null) {
        config = {};
      }
      M = "/oo3d/src/item/class-item-camera.litcoffee Item.Camera#" + (+index) + "()\n  ";
      Camera.__super__.constructor.call(this, main, index, config);
      this.fovy = config.fovy;
      if (ªU === ªtype(this.fovy)) {
        this.fovy = 0.785398163;
      } else if (ªN !== ªtype(this.fovy)) {
        throw TypeError(M + "Optional `config.fovy` is " + (ªtype(this.fovy)) + " not number");
      } else if (0 >= this.fovy) {
        throw RangeError(M + "Optional `config.fovy` is " + this.fovy + " not greater than zero");
      }
      this.aspect = config.aspect;
      if (ªU === ªtype(this.aspect)) {
        this.aspect = this.main.$main.width / this.main.$main.height;
      } else if (ªN !== ªtype(this.aspect)) {
        throw TypeError(M + "Optional `config.aspect` is " + (ªtype(this.aspect)) + " not number");
      } else if (0 >= this.aspect) {
        throw RangeError(M + "Optional `config.aspect` is " + this.aspect + " not greater than zero");
      }
      this.matProjection = mat4.perspective(this.fovy, this.aspect, 1, 100);
      this.matCamera = null;
      this.mT[14] = -4;
      this.tZ = -4;
      this.updateCamera();
    }

    Camera.prototype.updateCamera = function() {
      return this.matCamera = new Float32Array(mat4.multiply(this.matProjection, this.mT));
    };

    Camera.prototype.reset = function(subject) {
      var M;
      M = "/oo3d/src/item/class-item-camera.litcoffee Item.Camera#" + this.index + ":reset()\n  ";
      Camera.__super__.reset.call(this, subject);
      subject.mT[14] = -4;
      subject.tZ = -4;
      return subject;
    };

    return Camera;

  })(Item);

  Item.Mesh = (function(superClass) {
    extend(Mesh, superClass);

    Mesh.prototype.C = 'Item.Mesh';

    Mesh.prototype.toString = function() {
      return "[object Item.Mesh]";
    };

    function Mesh(main, index, config) {
      var M;
      if (config == null) {
        config = {};
      }
      M = "/oo3d/src/item/class-item-mesh.litcoffee Item.Mesh#" + (+index) + "()\n  ";
      Mesh.__super__.constructor.call(this, main, index, config);
      this.color = pick.indexToColor(this.index);
      this.positionBuffer = this.main._all[config.positionI || 0];
      if (!this.positionBuffer) {
        throw Error(M + "`config.positionI` " + config.positionI + " does not exist");
      }
      this.colorBuffer = this.main._all[config.colorI || 1];
      if (!this.colorBuffer) {
        throw Error(M + "`config.colorI` " + config.colorI + " does not exist");
      }
      if (this.positionBuffer.count !== this.colorBuffer.count) {
        throw Error(M + "`config.positionI` mismatches config.colorI");
      }
      this.count = this.positionBuffer.count;
      this.renderMode = config.renderMode || 'TRIANGLES';
      if (!Item.Mesh.validRenderMode[this.renderMode]) {
        throw Error(M + "`config.renderMode` " + this.renderMode + " is not recognised by WebGL");
      }
      if (!config.blend) {
        this.sBlend = null;
        this.dBlend = null;
      } else if (ªA !== ªtype(config.blend)) {
        throw Error(M + "If set, `config.blend` must be array not " + (ªtype(config.blend)));
      } else {
        if (!Item.Mesh.validBlend[config.blend[0]]) {
          throw Error(M + "`config.blend[0]` is not recognised by WebGL");
        }
        if (!Item.Mesh.validBlend[config.blend[1]]) {
          throw Error(M + "`config.blend[1]` is not recognised by WebGL");
        }
        this.sBlend = this.main.gl[config.blend[0]];
        this.dBlend = this.main.gl[config.blend[1]];
      }
    }

    Mesh.prototype.xx = function(xx) {};

    return Mesh;

  })(Item);

  Item.Mesh.validRenderMode = {
    'POINTS': 1,
    'LINES': 1,
    'LINE_STRIP': 1,
    'LINE_LOOP': 1,
    'TRIANGLES': 1,
    'TRIANGLE_STRIP': 1,
    'TRIANGLE_FAN': 1
  };

  Item.Mesh.validBlend = {
    'ZERO': 1,
    'ONE': 1,
    'SRC_COLOR': 1,
    'ONE_MINUS_SRC_COLOR': 1,
    'DST_COLOR': 1,
    'ONE_MINUS_DST_COLOR': 1,
    'SRC_ALPHA': 1,
    'ONE_MINUS_SRC_ALPHA': 1,
    'DST_ALPHA': 1,
    'ONE_MINUS_DST_ALPHA': 1,
    'SRC_ALPHA_SATURATE': 1
  };

  Layer = (function() {
    Layer.prototype.C = 'Layer';

    Layer.prototype.toString = function() {
      return '[object Layer]';
    };

    function Layer(main1, index1, config) {
      var M, i, index, j, len, num, rd, ref, tRIs, tSc;
      this.main = main1;
      this.index = index1;
      if (config == null) {
        config = {};
      }
      M = "/oo3d/src/layer/base-layer.litcoffee Layer#" + (+this.index) + "()\n  ";
      if (ªO !== ªtype(config)) {
        throw TypeError(M + "Optional `config` is " + (ªtype(config)) + " not object");
      }
      if (ªO !== typeof this.main) {
        throw TypeError(M + "`main` is " + (ªtype(this.main)) + " not object");
      }
      if ('[object Oo3d]' !== '' + this.main) {
        throw TypeError(M + "`main` is '" + this.main + "' not '[object Oo3d]'");
      }
      if (ªN !== typeof this.index) {
        throw TypeError(M + "`index` is " + (ªtype(this.index)) + " not number");
      }
      if (ªMAX < this.index || this.index % 1 || 0 > this.index) {
        throw RangeError(M + "`index` is " + this.index + " not 0 or a positive integer below 2^53");
      }
      tRIs = ªtype(config.rendererIs);
      if (ªU === tRIs) {
        this.renderers = [];
      } else if (ªA !== tRIs) {
        throw TypeError(M + "`config.rendererIs` is " + tRIs + " not array");
      } else {
        this.renderers = (function() {
          var j, len, ref, results;
          ref = config.rendererIs;
          results = [];
          for (i = j = 0, len = ref.length; j < len; i = ++j) {
            index = ref[i];
            if (ªN !== typeof index) {
              throw TypeError(M + "`config.rendererIs[" + i + "]` is " + (ªtype(index)) + " not number");
            }
            rd = this.main._all[index];
            if (!rd || !(rd instanceof Renderer)) {
              throw TypeError(M + "`config.rendererIs[" + i + "]` refs " + rd.C + " at `main._all[" + index + "]`");
            }
            results.push(rd);
          }
          return results;
        }).call(this);
      }
      tSc = ªtype(config.scissor);
      if (ªU === tSc || ªX === tSc) {
        this.scissor = null;
      } else if (ªA !== tSc) {
        throw TypeError(M + "`config.scissor` is " + tSc + " not array|null");
      } else if (4 !== config.scissor.length) {
        throw RangeError(M + "`config.scissor.length` must be 4 not " + config.scissor.length);
      } else {
        ref = config.scissor;
        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          num = ref[i];
          if (ªN !== typeof num) {
            throw TypeError(M + "`config.scissor[" + i + "]` is " + (ªtype(num)) + " not number");
          }
          if (0 > num || 1 < num) {
            throw RangeError(M + "`config.scissor[" + i + "]` is out-of-range " + num);
          }
        }
      }
      this.scissor = config.scissor;
    }

    Layer.prototype.render = function() {
      var j, len, ref, renderer, results;
      if (this.scissor) {
        this.main.gl.scissor(this.scissor[0] * this.main.$main.width, this.scissor[1] * this.main.$main.height, this.scissor[2] * this.main.$main.width, this.scissor[3] * this.main.$main.height);
      }
      ref = this.renderers;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        renderer = ref[j];
        results.push(renderer.render());
      }
      return results;
    };

    return Layer;

  })();

  Layer.Simple = (function(superClass) {
    extend(Simple, superClass);

    Simple.prototype.C = 'Layer.Simple';

    Simple.prototype.toString = function() {
      return '[object Layer.Simple]';
    };

    function Simple(main, index, config) {
      var M;
      if (config == null) {
        config = {};
      }
      M = "/oo3d/src/layer/class-layer-simple.litcoffee Layer.Simple#" + (+index) + "()\n  ";
      Simple.__super__.constructor.call(this, main, index, config);
    }

    return Simple;

  })(Layer);

  Program = (function() {
    Program.prototype.C = 'Program';

    Program.prototype.toString = function() {
      return "[object Program]";
    };

    function Program(main1, index1, config) {
      var M, gl;
      this.main = main1;
      this.index = index1;
      if (config == null) {
        config = {};
      }
      M = "/oo3d/src/layer/base-layer.litcoffee Program#" + (+this.index) + "()\n  ";
      if (ªO !== ªtype(config)) {
        throw TypeError(M + "Optional `config` is " + (ªtype(config)) + " not object");
      }
      if (ªO !== typeof this.main) {
        throw TypeError(M + "`main` is " + (ªtype(this.main)) + " not object");
      }
      if ('[object Oo3d]' !== '' + this.main) {
        throw TypeError(M + "`main` is '" + this.main + "' not '[object Oo3d]'");
      }
      if (ªN !== typeof this.index) {
        throw TypeError(M + "`index` is " + (ªtype(this.index)) + " not number");
      }
      if (ªMAX < this.index || this.index % 1 || 0 > this.index) {
        throw RangeError(M + "`index` is " + this.index + " not 0 or a positive integer below 2^53");
      }
      gl = this.main.gl;
      this.vertexShader = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(this.vertexShader, this.vertexSource());
      gl.compileShader(this.vertexShader);
      if (!gl.getShaderParameter(this.vertexShader, gl.COMPILE_STATUS)) {
        this.cleanUp();
        throw Error(this.C + ".vertexShader failed to compile");
      }
      this.fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(this.fragmentShader, this.fragmentSource());
      gl.compileShader(this.fragmentShader);
      if (!gl.getShaderParameter(this.fragmentShader, gl.COMPILE_STATUS)) {
        this.cleanUp();
        throw Error(this.C + ".fragmentShader failed to compile");
      }
      this.program = gl.createProgram();
      gl.attachShader(this.program, this.vertexShader);
      gl.attachShader(this.program, this.fragmentShader);
      gl.linkProgram(this.program);
      if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
        this.cleanUp();
        throw Error(this.C + ".program failed to link");
      }
    }

    Program.prototype.cleanUp = function() {
      if (this.vertexShader) {
        this.main.gl.deleteShader(this.vertexShader);
      }
      if (this.fragmentShader) {
        this.main.gl.deleteShader(this.fragmentShader);
      }
      if (this.program) {
        return this.main.gl.deleteProgram(this.program);
      }
    };

    Program.prototype.vertexSource = function() {
      return "void main() {\n}";
    };

    Program.prototype.fragmentSource = function() {
      return "void main() {\n}";
    };

    return Program;

  })();

  Program.Flat = (function(superClass) {
    extend(Flat, superClass);

    Flat.prototype.C = 'Program.Flat';

    Flat.prototype.toString = function() {
      return "[object Program.Flat]";
    };

    function Flat(main, index, config) {
      var M, gl;
      if (config == null) {
        config = {};
      }
      M = "/oo3d/src/program/class-program-flat.litcoffee Program.Flat#" + (+index) + "()\n  ";
      Flat.__super__.constructor.call(this, main, index, config);
      gl = this.main.gl;
      gl.useProgram(this.program);
      this.aVtxPositionLoc = gl.getAttribLocation(this.program, 'aVtxPosition');
      gl.enableVertexAttribArray(this.aVtxPositionLoc);
      this.aVtxColorLoc = gl.getAttribLocation(this.program, 'aVtxColor');
      this.uMatTransformLoc = gl.getUniformLocation(this.program, 'uMatTransform');
      this.uMatCameraLoc = gl.getUniformLocation(this.program, 'uMatCamera');
    }

    Flat.prototype.vertexSource = function() {
      return "attribute vec3 aVtxPosition;\nattribute vec4 aVtxColor;\n\nuniform mat4 uMatTransform;\nuniform mat4 uMatCamera;\n\nvarying vec4 vColor; // declare `vColor`\n\nvoid main() {\n\n  //// Increase the size of gl.POINT from 1px to 4px. \n  gl_PointSize = 4.0;\n\n  //// Apply the Camera and Mesh transforms to each vertex position. \n  //// Note that the order of these three is important. \n  gl_Position = uMatCamera * uMatTransform * vec4(aVtxPosition, 1);\n\n  //// Pass the vertex-color attribute unchanged to the fragment-shader. \n  vColor = aVtxColor;\n}";
    };

    Flat.prototype.fragmentSource = function() {
      return "precision mediump float; // boilerplate for mobile-friendly shaders\n\nvarying vec4 vColor; // linear-interpolated input from fragment-shader\n\nvoid main(void) {\n  gl_FragColor = vColor;\n}";
    };

    return Flat;

  })(Program);

  Program.FlatItem = (function(superClass) {
    extend(FlatItem, superClass);

    FlatItem.prototype.C = 'Program.FlatItem';

    FlatItem.prototype.toString = function() {
      return "[object FlatItem]";
    };

    function FlatItem(main, index, config) {
      var M, gl;
      if (config == null) {
        config = {};
      }
      M = "/oo3d/src/program/class-program-flatitem.litcoffee Program.FlatItem#" + (+index) + "()\n  ";
      FlatItem.__super__.constructor.call(this, main, index, config);
      gl = this.main.gl;
      gl.useProgram(this.program);
      this.aVtxPositionLoc = gl.getAttribLocation(this.program, 'aVtxPosition');
      gl.enableVertexAttribArray(this.aVtxPositionLoc);
      this.uMatTransformLoc = gl.getUniformLocation(this.program, 'uMatTransform');
      this.uMatCameraLoc = gl.getUniformLocation(this.program, 'uMatCamera');
      this.uMeshColorLoc = gl.getUniformLocation(this.program, 'uMeshColor');
    }

    FlatItem.prototype.vertexSource = function() {
      return "attribute vec3 aVtxPosition;\n\nuniform mat4 uMatTransform;\nuniform mat4 uMatCamera;\n\nuniform vec4 uMeshColor; // the mesh renders as a single flat color\n\n\nvarying vec4 vColor; // declare `vColor`\n\nvoid main() {\n\n  //// Multiply the position by the camera transformation and matrices. \n  //// Note that the order of these three is important. \n  gl_Position = uMatCamera * uMatTransform * vec4(aVtxPosition, 1);\n\n  //// Pass the vertex-color attribute unchanged to the fragment-shader. \n  vColor = uMeshColor;\n\n}";
    };

    FlatItem.prototype.fragmentSource = function() {
      return "precision mediump float; // boilerplate for mobile-friendly shaders\n\nvarying vec4 vColor; // linear-interpolated input from fragment-shader\n\nvoid main() {\n  gl_FragColor = vColor;\n}";
    };

    return FlatItem;

  })(Program);

  Program.Flatwhite = (function(superClass) {
    extend(Flatwhite, superClass);

    Flatwhite.prototype.C = 'Program.Flatwhite';

    Flatwhite.prototype.toString = function() {
      return "[object Flatwhite]";
    };

    function Flatwhite(main, index, config) {
      var M, gl;
      if (config == null) {
        config = {};
      }
      M = "/oo3d/src/program/class-program-flatwhite.litcoffee Program.Flatwhite#" + (+index) + "()\n  ";
      Flatwhite.__super__.constructor.call(this, main, index, config);
      gl = this.main.gl;
      gl.useProgram(this.program);
      this.aVtxPositionLoc = gl.getAttribLocation(this.program, 'aVtxPosition');
      gl.enableVertexAttribArray(this.aVtxPositionLoc);
      this.uMatTransformLoc = gl.getUniformLocation(this.program, 'uMatTransform');
      this.uMatCameraLoc = gl.getUniformLocation(this.program, 'uMatCamera');
    }

    Flatwhite.prototype.vertexSource = function() {
      return "attribute vec3 aVtxPosition;\n\nuniform mat4 uMatTransform;\nuniform mat4 uMatCamera;\n\nvoid main() {\n\n  //// Multiply the position by the camera transformation and matrices. \n  //// Note that the order of these three is important. \n  gl_Position = uMatCamera * uMatTransform * vec4(aVtxPosition, 1);\n\n}";
    };

    Flatwhite.prototype.fragmentSource = function() {
      return "precision mediump float; // boilerplate for mobile-friendly shaders\n\nvec4 white = vec4(1.0,1.0,1.0,1.0);\n\nvoid main() {\n  gl_FragColor = white;\n}";
    };

    return Flatwhite;

  })(Program);

  Renderer = (function() {
    var RendererTypeError;

    Renderer.prototype.C = 'Renderer';

    Renderer.prototype.toString = function() {
      return "[object Renderer]";
    };

    function Renderer(main1, index1, config) {
      var M, i, index, mesh, tMIs;
      this.main = main1;
      this.index = index1;
      if (config == null) {
        config = {};
      }
      M = "/oo3d/src/renderer/base-renderer.litcoffee Renderer#" + (+this.index) + "()\n  ";
      if (ªO !== ªtype(config)) {
        throw TypeError(M + "Optional `config` is " + (ªtype(config)) + " not object");
      }
      if (ªO !== typeof this.main) {
        throw TypeError(M + "`main` is " + (ªtype(this.main)) + " not object");
      }
      if ('[object Oo3d]' !== '' + this.main) {
        throw TypeError(M + "`main` is '" + this.main + "' not '[object Oo3d]'");
      }
      if (ªN !== typeof this.index) {
        throw TypeError(M + "`index` is " + (ªtype(this.index)) + " not number");
      }
      if (ªMAX < this.index || this.index % 1 || 0 > this.index) {
        throw RangeError(M + "`index` is " + this.index + " not 0 or a positive integer below 2^53");
      }
      if (ªN !== typeof config.programI) {
        throw TypeError(M + "config.programI is " + (ªtype(config.programI)) + " not number");
      }
      this.program = this.main._all[config.programI] || (function() {
        throw RangeError(M + "No such index " + config.programI + " in main._all");
      })();
      if (ªN !== typeof config.cameraI) {
        throw TypeError(M + "config.cameraI is " + (ªtype(config.cameraI)) + " not number");
      }
      this.camera = this.main._all[config.cameraI] || (function() {
        throw RangeError(M + "No such index " + config.cameraI + " in main._all");
      })();
      this.uMatCameraLoc = this.main.gl.getUniformLocation(this.program.program, 'uMatCamera');
      tMIs = ªtype(config.meshIs);
      if (ªU === tMIs) {
        this.meshes = [];
      } else if (ªA !== tMIs) {
        throw TypeError(M + "`config.meshIs` is " + tMIs + " not array");
      } else {
        this.meshes = (function() {
          var j, len, ref, results;
          ref = config.meshIs;
          results = [];
          for (i = j = 0, len = ref.length; j < len; i = ++j) {
            index = ref[i];
            if (ªN !== typeof index) {
              throw TypeError(M + "`config.meshIs[" + i + "] is " + (ªtype(index)) + " not number");
            }
            mesh = this.main._all[index];
            if (!mesh || !(mesh instanceof Item.Mesh)) {
              throw TypeError(M + "`config.meshIs[" + i + "]` refs " + mesh.C + " at `main._all[" + index + "]`");
            }
            results.push(mesh);
          }
          return results;
        }).call(this);
      }
    }

    Renderer.prototype.render = function() {
      var $main, aVtxColorLoc, aVtxPositionLoc, gl, index, main, mesh, mode, uMatTransformLoc, uMeshColorLoc;
      main = this.main;
      $main = main.$main;
      gl = main.gl;
      aVtxPositionLoc = this.program.aVtxPositionLoc;
      aVtxColorLoc = this.program.aVtxColorLoc || false;
      uMatTransformLoc = this.program.uMatTransformLoc;
      uMeshColorLoc = this.program.uMeshColorLoc;
      if (!gl) {
        throw Error("The WebGL rendering context is " + (ªtype(gl)));
      }
      gl.useProgram(this.program.program);
      gl.uniformMatrix4fv(this.uMatCameraLoc, false, this.camera.matCamera);
      if (aVtxColorLoc) {
        gl.enableVertexAttribArray(aVtxColorLoc);
      }
      index = this.meshes.length;
      while (index--) {
        mesh = this.meshes[index];
        if (!mesh) {
          continue;
        }
        gl.uniformMatrix4fv(uMatTransformLoc, gl.FALSE, mesh.mT);
        if (uMeshColorLoc) {
          gl.uniform4fv(uMeshColorLoc, mesh.color);
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, mesh.positionBuffer.glData);
        gl.vertexAttribPointer(aVtxPositionLoc, 3, gl.FLOAT, false, 0, 0);
        if (aVtxColorLoc) {
          gl.bindBuffer(gl.ARRAY_BUFFER, mesh.colorBuffer.glData);
          gl.vertexAttribPointer(aVtxColorLoc, 4, gl.FLOAT, false, 0, 0);
        }
        if (null !== mesh.sBlend) {
          gl.enable(gl.BLEND);
          gl.blendFunc(mesh.sBlend, mesh.dBlend);
        } else {
          gl.disable(gl.BLEND);
        }
        mode = gl[mesh.renderMode];
        gl.drawArrays(mode, 0, mesh.count);
        gl.flush();
      }
      if (aVtxColorLoc) {
        return gl.disableVertexAttribArray(aVtxColorLoc);
      }
    };

    RendererTypeError = (function(superClass) {
      extend(RendererTypeError, superClass);

      function RendererTypeError(message) {
        this.message = "Renderer " + message;
        this.name = this.constructor.name;
      }

      RendererTypeError.prototype = new Error();

      RendererTypeError.prototype.constructor = RendererTypeError;

      return RendererTypeError;

    })(TypeError);

    return Renderer;

  })();

  Renderer.Wireframe;

  Renderer.Wireframe = (function(superClass) {
    extend(Wireframe, superClass);

    Wireframe.prototype.C = 'Renderer.Wireframe';

    Wireframe.prototype.toString = function() {
      return '[object Renderer.Wireframe]';
    };

    function Wireframe(main, index, config) {
      var M;
      if (config == null) {
        config = {};
      }
      M = "/oo3d/src/renderer/class-renderer-wireframe.litcoffee Renderer.Wireframe#" + (+index) + "()\n  ";
      Wireframe.__super__.constructor.call(this, main, index, config);
    }

    return Wireframe;

  })(Renderer);

  Tudor = (function() {
    Tudor.prototype.I = 'Tudor';

    Tudor.prototype.toString = function() {
      return "[object " + I + "]";
    };

    Tudor.prototype.articles = [];

    function Tudor(opt) {
      this.opt = opt != null ? opt : {};
      this["do"] = bind(this["do"], this);
      switch (this.opt.format) {
        case 'html':
          this.pageHead = function(summary) {
            return "<style>\n  body     { font-family: sans-serif; }\n  a        { outline: 0; }\n  b        { display: inline-block; width: .7em }\n\n  b.pass              { color: #393 }\n  b.fail              { color: #bbb }\n  article.fail b.pass { color: #bbb }\n  section.fail b.pass { color: #bbb }\n\n  pre      { padding: .5em; margin: .2em 0; border-radius: 4px; }\n  pre.fn   { background-color: #fde }\n  pre.pass { background-color: #cfc }\n  pre.fail { background-color: #d8e0e8 }\n\n  article  { margin-bottom: .5rem }\n  article h2 { padding-left:.5rem; margin:0; font-weight:normal }\n  article.pass { border-left: 5px solid #9c9 }\n  article.fail { border-left: 5px solid #9bf }\n  article.fail h2 { margin-bottom: .5rem }\n  article.pass >div { display: none }\n\n  section  { margin-bottom: .5rem }\n  section h3   { padding-left: .5rem; margin: 0; }\n  section.pass { border-left: 3px solid #9c9 }\n  section.fail { border-left: 3px solid #9bf }\n  section.fail h3 { margin-bottom: .5rem }\n  section.pass >div { display: none }\n\n  article.fail section.pass { border-left-color: #ccc }\n\n  div      { padding-left: .5em; }\n  div.fail { border-left: 3px solid #9bf; font-size: .8rem }\n  div h4   { margin: 0 }\n  div h4 { font: normal .8rem/1.2rem monaco, monospace }\n  div.fail, div.fail h4 { margin: .5rem 0 }\n\n</style>\n<h4><a href=\"#end\" id=\"top\">\u2b07</a>  " + summary + "</h4>";
          };
          this.pageFoot = function(summary) {
            return "<h4><a href=\"#top\" id=\"end\">\u2b06</a>  " + summary + "</h4>\n<script>\n  document.title='" + (summary.replace(/<\/?[^>]+>/g, '')) + "';\n</script>";
          };
          this.articleHead = function(heading, fail) {
            return ("<article class=\"" + (fail ? 'fail' : 'pass') + "\">") + ("<h2>" + (fail ? this.cross : this.tick) + heading + "</h2><div>");
          };
          this.articleFoot = '</div></article>';
          this.sectionHead = function(heading, fail) {
            return ("<section class=\"" + (fail ? 'fail' : 'pass') + "\">") + ("<h3>" + (fail ? this.cross : this.tick) + heading + "</h3><div>");
          };
          this.sectionFoot = '</div></section>';
          this.jobFormat = function(heading, result) {
            return ("<div class=\"" + (result ? 'fail' : 'pass') + "\">") + ("<h4>" + (result ? this.cross : this.tick) + heading + "</h4>") + ("" + (result ? this.formatError(result) : '')) + "</div>";
          };
          this.tick = '<b class="pass">\u2713</b> ';
          this.cross = '<b class="fail">\u2718</b> ';
          break;
        default:
          this.pageHead = function(summary) {
            return "" + summary;
          };
          this.pageFoot = function(summary) {
            return "\n" + summary;
          };
          this.articleHead = function(heading, fail) {
            return "\n" + (fail ? this.cross : this.tick) + " " + heading + "\n===" + (new Array(heading.length).join('=')) + "\n";
          };
          this.articleFoot = '';
          this.sectionHead = function(heading, fail) {
            return "\n" + (fail ? this.cross : this.tick) + " " + heading + "\n---" + (new Array(heading.length).join('-')) + "\n";
          };
          this.sectionFoot = '';
          this.jobFormat = function(heading, result) {
            return ((result ? this.cross : this.tick) + " " + heading) + ("" + (result ? '\n' + this.formatError(result) : ''));
          };
          this.jobFoot = '';
          this.tick = '\u2713';
          this.cross = '\u2718';
      }
    }

    Tudor.prototype.add = function(lines) {
      var article, i, line, runner, section;
      article = {
        sections: []
      };
      runner = null;
      section = null;
      if (ªA !== ªtype(lines)) {
        throw new Error("`lines` isn’t an array");
      }
      if (0 === lines.length) {
        throw new Error("`lines` has no elements");
      }
      if (ªS !== ªtype(lines[0])) {
        throw new Error("`lines[0]` isn’t a string");
      }
      article.heading = lines.shift();
      i = 0;
      while (i < lines.length) {
        line = lines[i];
        switch (ªtype(line)) {
          case ªO:
            if (!line.runner) {
              throw new Error("Errant object");
            }
            runner = line.runner;
            break;
          case ªF:
            section.jobs.push(line);
            break;
          case ªS:
            if (this.isAssertion(lines[i + 1], lines[i + 2])) {
              if (!section) {
                throw new Error("Cannot add an assertion here");
              }
              section.jobs.push([runner, line, lines[++i], lines[++i]]);
            } else {
              section = {
                heading: line,
                jobs: []
              };
              article.sections.push(section);
            }
        }
        i++;
      }
      return this.articles.push(article);
    };

    Tudor.prototype["do"] = function() {
      var actual, art, artFail, artPass, article, e, error, expect, heading, j, job, l, len, len1, len2, mock, mockFail, o, pge, pgeFail, pgePass, ref, ref1, ref2, result, runner, sec, secFail, secPass, section, summary;
      pge = [];
      mock = null;
      pgePass = pgeFail = mockFail = 0;
      ref = this.articles;
      for (j = 0, len = ref.length; j < len; j++) {
        article = ref[j];
        art = [];
        artPass = artFail = 0;
        ref1 = article.sections;
        for (l = 0, len1 = ref1.length; l < len1; l++) {
          section = ref1[l];
          sec = [];
          secPass = secFail = 0;
          ref2 = section.jobs;
          for (o = 0, len2 = ref2.length; o < len2; o++) {
            job = ref2[o];
            switch (ªtype(job)) {
              case ªF:
                try {
                  mock = job.apply(this, mock);
                } catch (_error) {
                  e = _error;
                  error = e.message;
                }
                if (error) {
                  mockFail++;
                  secFail++;
                  sec.push(this.formatMockModifierError(job, error));
                }
                break;
              case ªA:
                runner = job[0], heading = job[1], expect = job[2], actual = job[3];
                result = runner(expect, actual, mock);
                if (!result) {
                  sec.push(this.jobFormat("" + (this.sanitize(heading))));
                  pgePass++;
                  artPass++;
                  secPass++;
                } else {
                  sec.push(this.jobFormat("" + (this.sanitize(heading)), result));
                  pgeFail++;
                  artFail++;
                  secFail++;
                }
            }
          }
          sec.unshift(this.sectionHead("" + (this.sanitize(section.heading)), secFail));
          sec.push(this.sectionFoot);
          art = art.concat(sec);
        }
        art.unshift(this.articleHead("" + (this.sanitize(article.heading)), artFail));
        art.push(this.articleFoot);
        pge = pge.concat(art);
        summary = pgeFail ? this.cross + " FAILED " + pgeFail + "/" + (pgePass + pgeFail) : this.tick + " Passed " + pgePass + "/" + (pgePass + pgeFail);
        if (mockFail) {
          summary = "\n" + this.cross + " (MOCK FAILS)";
        }
      }
      pge.unshift(this.pageHead(summary));
      pge.push(this.pageFoot(summary));
      return pge.join('\n');
    };

    Tudor.prototype.formatError = function(result) {
      switch (result.length + "-" + this.opt.format) {
        case '2-html':
          return result[0] + "\n<pre class=\"fail\">" + (this.sanitize(result[1].message)) + "</pre>";
        case '2-plain':
          return result[0] + "\n" + (this.sanitize(result[1].message));
        case '3-html':
          return "<pre class=\"fail\">" + (this.sanitize(this.reveal(result[0]))) + "</pre>\n..." + result[1] + "...\n<pre class=\"pass\">" + (this.sanitize(this.reveal(result[2]))) + "</pre>";
        case '3-plain':
          return (this.sanitize(this.reveal(result[0]))) + "\n..." + result[1] + "...\n" + (this.sanitize(this.reveal(result[2])));
        case '4-html':
          return "<pre class=\"fail\">" + (this.sanitize(this.reveal(result[0]))) + " (" + (ªtype(result[0])) + ")</pre>\n..." + result[1] + "...\n<pre class=\"pass\">" + (this.sanitize(this.reveal(result[2]))) + " (" + (ªtype(result[2])) + ")</pre>";
        case '4-plain':
          return (this.sanitize(this.reveal(result[0]))) + " (" + (ªtype(result[0])) + ")\n..." + result[1] + "...\n" + (this.sanitize(this.reveal(result[2]))) + " (" + (ªtype(result[2])) + ")";
        default:
          throw new Error("Cannot process '" + result.length + "-" + this.opt.format + "'");
      }
    };

    Tudor.prototype.formatMockModifierError = function(fn, error) {
      switch (this.opt.format) {
        case 'html':
          return "<pre class=\"fn\">" + (this.sanitize(fn + '')) + "</pre>\n...encountered an exception:\n<pre class=\"fail\">" + (this.sanitize(error)) + "</pre>";
        default:
          return (this.sanitize(fn + '')) + "\n...encountered an exception:\n" + (this.sanitize(error));
      }
    };

    Tudor.prototype.reveal = function(value) {
      return value != null ? value.toString().replace(/^\s+|\s+$/g, function(match) {
        return '\u00b7' + (new Array(match.length)).join('\u00b7');
      }) : void 0;
    };

    Tudor.prototype.sanitize = function(value) {
      switch (this.opt.format) {
        case 'html':
          return value != null ? value.toString().replace(/</g, '&lt;') : void 0;
        default:
          return value;
      }
    };

    Tudor.prototype["throw"] = {
      runner: function(expect, actual, mock) {
        var e, error;
        error = false;
        try {
          actual.apply(this, mock);
        } catch (_error) {
          e = _error;
          error = e;
        }
        if (!error) {
          return [
            'No exception thrown, expected', {
              message: expect
            }
          ];
        } else if (expect !== error.message) {
          return [error.message, 'was thrown, but expected', expect];
        }
      }
    };

    Tudor.prototype.equal = {
      runner: function(expect, actual, mock) {
        var e, error, result;
        error = false;
        try {
          result = actual.apply(this, mock);
        } catch (_error) {
          e = _error;
          error = e;
        }
        if (error) {
          return ['Unexpected exception', error];
        } else if (expect !== result) {
          if (result + '' === expect + '') {
            return [result, 'was returned, but expected', expect, true];
          } else {
            return [result, 'was returned, but expected', expect];
          }
        }
      }
    };

    Tudor.prototype.is = {
      runner: function(expect, actual, mock) {
        var e, error, result;
        error = false;
        try {
          result = actual.apply(this, mock);
        } catch (_error) {
          e = _error;
          error = e;
        }
        if (error) {
          return ['Unexpected exception', error];
        } else if (expect !== ªtype(result)) {
          return ["type " + (ªtype(result)), 'was returned, but expected', "type " + expect];
        }
      }
    };

    Tudor.prototype.match = {
      runner: function(expect, actual, mock) {
        var e, error, result;
        error = false;
        try {
          result = actual.apply(this, mock);
        } catch (_error) {
          e = _error;
          error = e;
        }
        if (error) {
          return ['Unexpected exception', error];
        } else if (ªF !== typeof expect.test) {
          return [
            '`test()` is not a function', {
              message: expect
            }
          ];
        } else if (!expect.test('' + result)) {
          return ['' + result, 'failed test', expect];
        }
      }
    };

    Tudor.prototype.isAssertion = function(line1, line2) {
      if (ªF !== ªtype(line2)) {
        return false;
      }
      if ((ªO === ªtype(line1)) && ªF === ªtype(line1.runner)) {
        return false;
      }
      return true;
    };

    return Tudor;

  })();

  tudor = new Tudor({
    format: ªO === typeof window ? 'html' : 'plain'
  });

  Main.runTest = tudor["do"];

  mockOo3d = function() {
    var CanvasMock, item, itemI, oo3d;
    CanvasMock = (function() {
      function CanvasMock() {}

      CanvasMock.prototype.width = 2;

      CanvasMock.prototype.height = 1;

      CanvasMock.prototype.toString = function() {
        return '[object HTMLCanvasElement]';
      };

      CanvasMock.prototype.getContext = function() {
        return {
          createBuffer: function() {
            return {};
          },
          createProgram: function() {},
          useProgram: function() {},
          attachShader: function() {},
          linkProgram: function() {},
          createShader: function() {},
          shaderSource: function() {},
          compileShader: function() {},
          getShaderParameter: function() {
            return true;
          },
          getProgramParameter: function() {
            return true;
          },
          getAttribLocation: function() {},
          enableVertexAttribArray: function() {},
          getUniformLocation: function() {},
          bindBuffer: function() {},
          bufferData: function() {},
          clearColor: function() {},
          enable: function() {},
          depthFunc: function() {},
          scissor: function() {},
          clear: function() {},
          TRIANGLES: 4
        };
      };

      return CanvasMock;

    })();
    oo3d = new Main({
      $main: new CanvasMock
    });
    itemI = oo3d.add('Item.Mesh', {
      positionI: oo3d.add('Buffer.Position'),
      colorI: oo3d.add('Buffer.Color'),
      renderMode: null,
      blend: null
    });
    item = oo3d._all[itemI];
    return [oo3d, item, itemI];
  };

  tudor.add([
    "1-01 `new Oo3d`", tudor.is, "The class and instance are expected types", "The class is a function", ªF, function() {
      return Main;
    }, "`new` returns an object", ªO, function() {
      return new Main;
    }, tudor.equal, "`oo3d.toString()` as expected", '[object Oo3d]', function(oo3d) {
      oo3d = new Main;
      return '' + oo3d;
    }, "`oo3d.C` as expected", 'Oo3d', function(oo3d) {
      oo3d = new Main;
      return oo3d.C;
    }, "Config exceptions", tudor["throw"], "If set, `config` must be an object", "/oo3d/src/class-main.litcoffee Oo3d()\n  Optional `config` is array not object", function() {
      return new Main([]);
    }, "If set, `config.$main` must be an HTMLCanvasElement", "/oo3d/src/class-main.litcoffee Oo3d()\n  Optional `config.$main` is number not HTMLCanvasElement", function() {
      return new Main({
        $main: 123
      });
    }, "If set, `config.bkgnd` must be a Float32Array", "/oo3d/src/class-main.litcoffee Oo3d()\n  Optional `config.bkgnd` is number not float32array", function() {
      return new Main({
        bkgnd: 456
      });
    }, "`config.bkgnd` must contain four elements", "/oo3d/src/class-main.litcoffee Oo3d()\n  If set `config.bkgnd` must contain four elements", function() {
      return new Main({
        bkgnd: new Float32Array([1, 1, 1])
      });
    }, "`config.bkgnd[0]` must be 0 or greater", "/oo3d/src/class-main.litcoffee Oo3d()\n  `config.bkgnd[0]` (red) is not within range 0-1", function() {
      return new Main({
        bkgnd: new Float32Array([-0.02, 1, 1, 1])
      });
    }, "`config.bkgnd[0]` must be 1 or less", "/oo3d/src/class-main.litcoffee Oo3d()\n  `config.bkgnd[0]` (red) is not within range 0-1", function() {
      return new Main({
        bkgnd: new Float32Array([1.02, 1, 1, 1])
      });
    }, "`config.bkgnd[1]` must be 0 or greater", "/oo3d/src/class-main.litcoffee Oo3d()\n  `config.bkgnd[1]` (green) is not within range 0-1", function() {
      return new Main({
        bkgnd: new Float32Array([0, -0.02, 1, 1])
      });
    }, "`config.bkgnd[1]` must be 1 or less", "/oo3d/src/class-main.litcoffee Oo3d()\n  `config.bkgnd[1]` (green) is not within range 0-1", function() {
      return new Main({
        bkgnd: new Float32Array([0, 1.02, 1, 1])
      });
    }, "`config.bkgnd[2]` must be 0 or greater", "/oo3d/src/class-main.litcoffee Oo3d()\n  `config.bkgnd[2]` (blue) is not within range 0-1", function() {
      return new Main({
        bkgnd: new Float32Array([0, 1, -Infinity, 1])
      });
    }, "`config.bkgnd[2]` must be 1 or less", "/oo3d/src/class-main.litcoffee Oo3d()\n  `config.bkgnd[2]` (blue) is not within range 0-1", function() {
      return new Main({
        bkgnd: new Float32Array([0, 1, Infinity, 1])
      });
    }, "`config.bkgnd[3]` must be 0 or greater", "/oo3d/src/class-main.litcoffee Oo3d()\n  `config.bkgnd[3]` (alpha) is not within range 0-1", function() {
      return new Main({
        bkgnd: new Float32Array([0, 1, 1, -0.000001])
      });
    }, "`config.bkgnd[3]` must be 1 or less", "/oo3d/src/class-main.litcoffee Oo3d()\n  `config.bkgnd[3]` (alpha) is not within range 0-1", function() {
      return new Main({
        bkgnd: new Float32Array([0, 1, 0, 1.00001])
      });
    }, "Config usage", tudor.equal, "`config.bkgnd` can contain four floats 0-1, or NaN", '[object Oo3d]', function() {
      return '' + (new Main({
        bkgnd: new Float32Array([1, 0, NaN, 0.5])
      }));
    }
  ]);

  tudor.add([
    "1-02 `oo3d.browse()`", tudor.is, "(Mock an `Oo3d` instance)", function() {
      var CanvasMock, oo3d;
      CanvasMock = (function() {
        function CanvasMock() {}

        CanvasMock.prototype.width = 2;

        CanvasMock.prototype.height = 1;

        CanvasMock.prototype.toString = function() {
          return '[object HTMLCanvasElement]';
        };

        CanvasMock.prototype.getContext = function() {
          return {
            createBuffer: function() {
              return {};
            },
            bindBuffer: function() {},
            bufferData: function() {},
            clearColor: function() {},
            enable: function() {},
            depthFunc: function() {},
            scissor: function() {},
            clear: function() {},
            TRIANGLES: 4
          };
        };

        return CanvasMock;

      })();
      oo3d = new Main({
        $main: new CanvasMock
      });
      return [oo3d];
    }, "The method is a function and returns an object", "`oo3d.browse()` is a function", ªF, function(oo3d) {
      return oo3d.browse;
    }, "`oo3d.browse()` returns an array", ªA, function(oo3d) {
      return oo3d.browse();
    }, "`oo3d.browse('abc')` returns an array", ªA, function(oo3d) {
      return oo3d.browse('abc');
    }
  ]);

  tudor.add([
    "1-03 `oo3d.read()`", tudor.is, "(Mock an Oo3d instance)", mockOo3d, "The method is a function and returns an object", "`oo3d.read()` is a function", ªF, function(oo3d) {
      return oo3d.read;
    }, "`oo3d.read()` returns an object", ªO, function(oo3d) {
      return oo3d.read(4);
    }
  ]);

  tudor.add([
    "1-04 `oo3d.edit()`", tudor.is, "(Mock an Oo3d instance)", mockOo3d, "The method is a function and returns an object", "`oo3d.edit()` is a function", ªF, function(oo3d, item, itemI) {
      return oo3d.edit;
    }, "`oo3d.edit(0)` returns an object", ªO, function(oo3d, item, itemI) {
      return oo3d.edit(itemI);
    }
  ]);

  tudor.add([
    "1-05 `oo3d.add()`", tudor.is, "(Mock an Oo3d instance)", mockOo3d, "The method is a function and returns a number", "`oo3d.add()` is a function", ªF, function(oo3d) {
      return oo3d.add;
    }, "`oo3d.add('Item.Mesh')` returns a number", ªN, function(oo3d) {
      return oo3d.add('Item.Mesh');
    }, "`item.add()` exceptions", tudor["throw"], "`className` is not optional", "/oo3d/src/class-main.litcoffee Main:add()\n  `className` is undefined not string", function(oo3d) {
      return oo3d.add();
    }, "`className` must not be boolean", "/oo3d/src/class-main.litcoffee Main:add()\n  `className` is boolean not string", function(oo3d) {
      return oo3d.add(true);
    }, "`className` must not be an empty string", "/oo3d/src/class-main.litcoffee Main:add()\n  `className` must be in 2 parts, not 1", function(oo3d) {
      return oo3d.add('');
    }, "`className` must not have three parts", "/oo3d/src/class-main.litcoffee Main:add()\n  `className` must be in 2 parts, not 3", function(oo3d) {
      return oo3d.add('Item.Mesh.FooBar');
    }, "`className` base must be a recognised base-class", "/oo3d/src/class-main.litcoffee Main:add()\n  `className` base must be 'Buffer|Item|Layer|Program|Renderer'", function(oo3d) {
      return oo3d.add('NotReally.Anything');
    }, "`className` child must be a recognised child-class", "/oo3d/src/class-main.litcoffee Main:add()\n  For `className` 'Item' use 'Camera|Mesh'", function(oo3d) {
      return oo3d.add('Item.NonExistant');
    }, "`item.add()` usage", tudor.equal, "Adding an Item.Mesh increments `_all`", 1, function(oo3d) {
      var count;
      count = oo3d._all.length;
      oo3d.add('Item.Mesh');
      return oo3d._all.length - count;
    }, "Two calls to `add()` returns two indices in sequence", 1, function(oo3d) {
      var firstI, secondI;
      firstI = oo3d.add('Item.Mesh');
      secondI = oo3d.add('Item.Mesh');
      return secondI - firstI;
    }
  ]);

  tudor.add([
    "1-06 `oo3d.delete()`", tudor.is, "(Mock an Oo3d instance)", mockOo3d, "The method is a function and returns an object", "`oo3d.delete()` is a function", ªF, function(oo3d) {
      return oo3d["delete"];
    }, "`oo3d.delete()` returns an object", ªO, function(oo3d) {
      return oo3d["delete"]();
    }, "`oo3d.delete('abc')` returns an object", ªO, function(oo3d) {
      return oo3d["delete"]('abc');
    }
  ]);

  tudor.add([
    "2-1-01 `new Buffer`", tudor.is, "(Mock an Oo3d instance)", mockOo3d, "The class and instance are expected types", "The class is a function", ªF, function() {
      return Buffer;
    }, "`new` returns an object", ªO, function(oo3d) {
      return new Buffer(oo3d, 0);
    }, tudor.equal, "`buffer.toString()` as expected", '[object Buffer]', function(oo3d) {
      var buffer;
      buffer = new Buffer(oo3d, 0);
      return '' + buffer;
    }, "`buffer.C` as expected", 'Buffer', function(oo3d) {
      var buffer;
      buffer = new Buffer(oo3d, 0);
      return buffer.C;
    }, "Buffer Constructor exceptions", tudor["throw"], "`config.main` must be an object", "/oo3d/src/buffer/base-buffer.litcoffee Buffer#NaN()\n  `main` is number not object", function(oo3d) {
      return new Buffer(123);
    }, "`config.main` must be an Oo3d instance", "/oo3d/src/buffer/base-buffer.litcoffee Buffer#NaN()\n  `main` is '[object Object]' not '[object Oo3d]'", function(oo3d) {
      return new Buffer({});
    }, "`index` must be a number", "/oo3d/src/buffer/base-buffer.litcoffee Buffer#1()\n  `index` is boolean not number", function(oo3d) {
      return new Buffer(oo3d, true);
    }, "`index` must be an integer", "/oo3d/src/buffer/base-buffer.litcoffee Buffer#3.5()\n  `index` is 3.5 not 0 or a positive integer below 2^53", function(oo3d) {
      return new Buffer(oo3d, 3.5);
    }, "`index` must be positive", "/oo3d/src/buffer/base-buffer.litcoffee Buffer#-44()\n  `index` is -44 not 0 or a positive integer below 2^53", function(oo3d) {
      return new Buffer(oo3d, -44);
    }, "`index` must be below 2^53", "/oo3d/src/buffer/base-buffer.litcoffee Buffer#9007199254740992()\n  `index` is 9007199254740992 not 0 or a positive integer below 2^53", function(oo3d) {
      return new Buffer(oo3d, 9007199254740992);
    }, "`config` must be an object", "/oo3d/src/buffer/base-buffer.litcoffee Buffer#0()\n  Optional `config` is date not object", function(oo3d) {
      return new Buffer(oo3d, 0, new Date);
    }, "If set, `config.data` must be a regular array", "/oo3d/src/buffer/base-buffer.litcoffee Buffer#0()\n  `config.data` is float32array not array", function(oo3d) {
      return new Buffer(oo3d, 0, {
        data: new Float32Array()
      });
    }, "If set, `config.data` must only contain numbers", "/oo3d/src/buffer/base-buffer.litcoffee Buffer#0()\n  `config.data` contains a non-numeric value", function(oo3d) {
      return new Buffer(oo3d, 0, {
        data: [1, 2, 'foo']
      });
    }, "Buffer Constructor usage", tudor.is, "`config` can contain unexpected properties, which are not recorded", ªU, function(oo3d) {
      var buffer;
      buffer = new Buffer(oo3d, 0, {
        foo: 'bar'
      });
      return buffer.foo;
    }, "If set, `config.data` can contain strings which resolve to numbers", ªO, function(oo3d) {
      var buffer;
      buffer = new Buffer(oo3d, 0, {
        data: [1, 2, '3']
      });
      return buffer.glData;
    }
  ]);

  tudor.add([
    "2-2-01 `new Buffer.Color`", tudor.is, "(Mock an Oo3d instance)", mockOo3d, "The class and instance are expected types", "The class is a function", ªF, function() {
      return Buffer.Color;
    }, "`new` returns an object", ªO, function(oo3d) {
      return new Buffer.Color(oo3d, 0);
    }, tudor.equal, "`colorBuffer.toString()` as expected", '[object Buffer.Color]', function(oo3d) {
      var colorBuffer;
      colorBuffer = new Buffer.Color(oo3d, 0);
      return '' + colorBuffer;
    }, "`colorBuffer.C` as expected", 'Buffer.Color', function(oo3d) {
      var colorBuffer;
      colorBuffer = new Buffer.Color(oo3d, 0);
      return colorBuffer.C;
    }, "Buffer.Color Constructor exceptions", tudor["throw"], "`config.main` must be an object", "/oo3d/src/buffer/base-buffer.litcoffee Buffer#NaN()\n  `main` is number not object", function(oo3d) {
      return new Buffer.Color(123);
    }, "`config.main` must be an Oo3d instance", "/oo3d/src/buffer/base-buffer.litcoffee Buffer#NaN()\n  `main` is '[object Object]' not '[object Oo3d]'", function(oo3d) {
      return new Buffer.Color({});
    }, "`index` must be a number", "/oo3d/src/buffer/base-buffer.litcoffee Buffer#1()\n  `index` is boolean not number", function(oo3d) {
      return new Buffer.Color(oo3d, true);
    }, "`index` must be an integer", "/oo3d/src/buffer/base-buffer.litcoffee Buffer#3.5()\n  `index` is 3.5 not 0 or a positive integer below 2^53", function(oo3d) {
      return new Buffer.Color(oo3d, 3.5);
    }, "`index` must be positive", "/oo3d/src/buffer/base-buffer.litcoffee Buffer#-44()\n  `index` is -44 not 0 or a positive integer below 2^53", function(oo3d) {
      return new Buffer.Color(oo3d, -44);
    }, "`index` must be below 2^53", "/oo3d/src/buffer/base-buffer.litcoffee Buffer#9007199254740992()\n  `index` is 9007199254740992 not 0 or a positive integer below 2^53", function(oo3d) {
      return new Buffer.Color(oo3d, 9007199254740992);
    }, "`config` must be an object", "/oo3d/src/buffer/base-buffer.litcoffee Buffer#0()\n  Optional `config` is date not object", function(oo3d) {
      return new Buffer.Color(oo3d, 0, new Date);
    }, "If set, `config.data` must be a regular array", "/oo3d/src/buffer/base-buffer.litcoffee Buffer#0()\n  `config.data` is float32array not array", function(oo3d) {
      return new Buffer.Color(oo3d, 0, {
        data: new Float32Array()
      });
    }, "If set, `config.data` must only contain numbers", "/oo3d/src/buffer/base-buffer.litcoffee Buffer#0()\n  `config.data` contains a non-numeric value", function(oo3d) {
      return new Buffer.Color(oo3d, 0, {
        data: [1, 2, 'foo']
      });
    }, "If set, `config.data.length` must not be `1`", "/oo3d/src/buffer/class-buffer-color.litcoffee Buffer.Color#0()\n  `config.data.length` 1 not divisible by 4", function(oo3d) {
      return new Buffer.Color(oo3d, 0, {
        data: [1]
      });
    }, "If set, `config.data.length` must not be `6`", "/oo3d/src/buffer/class-buffer-color.litcoffee Buffer.Color#0()\n  `config.data.length` 6 not divisible by 4", function(oo3d) {
      return new Buffer.Color(oo3d, 0, {
        data: [1, 2, 3, 4, 5, 6]
      });
    }, "Buffer.Color Constructor usage", tudor.is, "`config` can contain unexpected properties, which are not recorded", ªU, function(oo3d) {
      var colorBuffer;
      colorBuffer = new Buffer.Color(oo3d, 0, {
        foo: 'bar'
      });
      return colorBuffer.foo;
    }, "If set, `config.data` can contain strings which resolve to numbers", ªO, function(oo3d) {
      var colorBuffer;
      colorBuffer = new Buffer.Color(oo3d, 0, {
        data: [1, 2, '3', '4']
      });
      return colorBuffer.glData;
    }
  ]);

  tudor.add([
    "2-2-01 `new Buffer.Position`", tudor.is, "(Mock an Oo3d instance)", mockOo3d, "The class and instance are expected types", "The class is a function", ªF, function() {
      return Buffer.Position;
    }, "`new` returns an object", ªO, function(oo3d) {
      return new Buffer.Position(oo3d, 0);
    }, tudor.equal, "`positionBuffer.toString()` as expected", '[object Buffer.Position]', function(oo3d) {
      var positionBuffer;
      positionBuffer = new Buffer.Position(oo3d, 0);
      return '' + positionBuffer;
    }, "`positionBuffer.C` as expected", 'Buffer.Position', function(oo3d) {
      var positionBuffer;
      positionBuffer = new Buffer.Position(oo3d, 0);
      return positionBuffer.C;
    }, "Buffer.Position Constructor exceptions", tudor["throw"], "`config.main` must be an object", "/oo3d/src/buffer/base-buffer.litcoffee Buffer#NaN()\n  `main` is number not object", function(oo3d) {
      return new Buffer.Position(123);
    }, "`config.main` must be an Oo3d instance", "/oo3d/src/buffer/base-buffer.litcoffee Buffer#NaN()\n  `main` is '[object Object]' not '[object Oo3d]'", function(oo3d) {
      return new Buffer.Position({});
    }, "`index` must be a number", "/oo3d/src/buffer/base-buffer.litcoffee Buffer#1()\n  `index` is boolean not number", function(oo3d) {
      return new Buffer.Position(oo3d, true);
    }, "`index` must be an integer", "/oo3d/src/buffer/base-buffer.litcoffee Buffer#3.5()\n  `index` is 3.5 not 0 or a positive integer below 2^53", function(oo3d) {
      return new Buffer.Position(oo3d, 3.5);
    }, "`index` must be positive", "/oo3d/src/buffer/base-buffer.litcoffee Buffer#-44()\n  `index` is -44 not 0 or a positive integer below 2^53", function(oo3d) {
      return new Buffer.Position(oo3d, -44);
    }, "`index` must be below 2^53", "/oo3d/src/buffer/base-buffer.litcoffee Buffer#9007199254740992()\n  `index` is 9007199254740992 not 0 or a positive integer below 2^53", function(oo3d) {
      return new Buffer.Position(oo3d, 9007199254740992);
    }, "`config` must be an object", "/oo3d/src/buffer/base-buffer.litcoffee Buffer#0()\n  Optional `config` is date not object", function(oo3d) {
      return new Buffer.Position(oo3d, 0, new Date);
    }, "If set, `config.data` must be a regular array", "/oo3d/src/buffer/base-buffer.litcoffee Buffer#0()\n  `config.data` is float32array not array", function(oo3d) {
      return new Buffer.Position(oo3d, 0, {
        data: new Float32Array()
      });
    }, "If set, `config.data` must only contain numbers", "/oo3d/src/buffer/base-buffer.litcoffee Buffer#0()\n  `config.data` contains a non-numeric value", function(oo3d) {
      return new Buffer.Position(oo3d, 0, {
        data: [1, 2, 'foo']
      });
    }, "If set, `config.data.length` must not be `1`", "/oo3d/src/buffer/class-buffer-position.litcoffee Buffer.Position#0()\n  `config.data.length` 1 not divisible by 3", function(oo3d) {
      return new Buffer.Position(oo3d, 0, {
        data: [1]
      });
    }, "If set, `config.data.length` must not be `5`", "/oo3d/src/buffer/class-buffer-position.litcoffee Buffer.Position#0()\n  `config.data.length` 5 not divisible by 3", function(oo3d) {
      return new Buffer.Position(oo3d, 0, {
        data: [1, 2, 3, 4, 5]
      });
    }, "Buffer.Position Constructor usage", tudor.is, "`config` can contain unexpected properties, which are not recorded", ªU, function(oo3d) {
      var positionBuffer;
      positionBuffer = new Buffer.Position(oo3d, 0, {
        foo: 'bar'
      });
      return positionBuffer.foo;
    }, "If set, `config.data` can contain strings which resolve to numbers", ªO, function(oo3d) {
      var positionBuffer;
      positionBuffer = new Buffer.Position(oo3d, 0, {
        data: [1, 2, '3']
      });
      return positionBuffer.glData;
    }
  ]);

  tudor.add([
    "3-1-01 `new Item`", tudor.is, "(Mock an Oo3d instance)", mockOo3d, "The class and instance are expected types", "The class is a function", ªF, function() {
      return Item;
    }, "`new` returns an object", ªO, function(oo3d) {
      return new Item(oo3d, 0);
    }, tudor.equal, "`item.toString()` as expected", '[object Item]', function(oo3d) {
      var item;
      item = new Item(oo3d, 0);
      return '' + item;
    }, "`item.C` as expected", 'Item', function(oo3d) {
      var item;
      item = new Item(oo3d, 0);
      return item.C;
    }, "Constructor exceptions", tudor["throw"], "`config.main` must be an object", "/oo3d/src/item/base-item.litcoffee Item#NaN()\n  `main` is number not object", function(oo3d) {
      return new Item(123);
    }, "`config.main` must be an Oo3d instance", "/oo3d/src/item/base-item.litcoffee Item#NaN()\n  `main` is '[object Object]' not '[object Oo3d]'", function(oo3d) {
      return new Item({});
    }, "`index` must be a number", "/oo3d/src/item/base-item.litcoffee Item#1()\n  `index` is boolean not number", function(oo3d) {
      return new Item(oo3d, true);
    }, "`index` must be an integer", "/oo3d/src/item/base-item.litcoffee Item#3.5()\n  `index` is 3.5 not 0 or a positive integer below 2^53", function(oo3d) {
      return new Item(oo3d, 3.5);
    }, "`index` must be positive", "/oo3d/src/item/base-item.litcoffee Item#-44()\n  `index` is -44 not 0 or a positive integer below 2^53", function(oo3d) {
      return new Item(oo3d, -44);
    }, "`index` must be below 2^53", "/oo3d/src/item/base-item.litcoffee Item#9007199254740992()\n  `index` is 9007199254740992 not 0 or a positive integer below 2^53", function(oo3d) {
      return new Item(oo3d, 9007199254740992);
    }, "`config` must be an object", "/oo3d/src/item/base-item.litcoffee Item#0()\n  Optional `config` is date not object", function(oo3d) {
      return new Item(oo3d, 0, new Date);
    }, "Constructor usage", tudor.equal, "`config` can be an empty object", '[object Item]', function(oo3d) {
      var item;
      item = new Item(oo3d, 0, {});
      return '' + item;
    }, "`item.mT` as expected", '1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1', function(oo3d) {
      var item, n;
      item = new Item(oo3d, 0, {});
      return ((function() {
        var j, len, ref, results;
        ref = item.mT;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          n = ref[j];
          results.push('' + n);
        }
        return results;
      })()).join(' ');
    }, "`item.rX` `item.rY` `item.rZ` as expected", '0 0 0', function(oo3d) {
      var item;
      item = new Item(oo3d, 0, {});
      return [item.rX, item.rY, item.rZ].join(' ');
    }, "`item.sX` `item.sY` `item.sZ` as expected", '1 1 1', function(oo3d) {
      var item;
      item = new Item(oo3d, 0, {});
      return [item.sX, item.sY, item.sZ].join(' ');
    }, "`item.tX` `item.tY` `item.tZ` as expected", '0 0 0', function(oo3d) {
      var item;
      item = new Item(oo3d, 0, {});
      return [item.tX, item.tY, item.tZ].join(' ');
    }
  ]);

  tudor.add([
    "3-1-02 `item.browse()`", tudor.is, "(Mock an Oo3d instance)", mockOo3d, "The method is a function and returns an object", "`item.browse()` is a function", ªF, function(oo3d, item) {
      return item.browse;
    }, "`item.browse()` returns an array", ªA, function(oo3d, item) {
      return item.browse();
    }, "`item.browse('abc')` returns an array", ªA, function(oo3d, item) {
      return item.browse('abc');
    }
  ]);

  tudor.add([
    "3-1-03 `item.read()`", tudor.is, "(Mock an Oo3d instance)", mockOo3d, "The method is a function and returns expected types", "`item.read()` is a function", ªF, function(oo3d, item) {
      return item.read;
    }, "`item.read()` returns an object", ªO, function(oo3d, item) {
      return item.read();
    }, "`item.read('object')` returns an object", ªO, function(oo3d, item) {
      return item.read('object');
    }, "`item.read('log')` returns a string", ªS, function(oo3d, item) {
      return item.read('log');
    }, "`item.read('nwang')` returns a string", ªS, function(oo3d, item) {
      return item.read('nwang');
    }, "`item.read()` exceptions", tudor["throw"], "`format` must not be boolean", "/oo3d/src/item/base-item.litcoffee Item#4:read()\n  Optional `format` is boolean not string|object", function(oo3d, item) {
      return item.read(false);
    }, "`format` must not be null", "/oo3d/src/item/base-item.litcoffee Item#4:read()\n  Optional `format` is null not string|object", function(oo3d, item) {
      return item.read(null);
    }, "`format` 'NOPE!' is not recognized", "/oo3d/src/item/base-item.litcoffee Item#4:read()\n  Optional `format` is not 'object|log|nwang'", function(oo3d, item) {
      return item.read('NOPE!');
    }, "`item.read()` usage", tudor.equal, "Object from a default Item contains expected keys and values", "i 4 mT 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 r 0 0 0 s 1 1 1 t 0 0 0", function(oo3d, item) {
      var obj;
      obj = item.read();
      return "i " + obj.index + " mT " + obj.mT[0] + " " + obj.mT[1] + " " + obj.mT[2] + " " + obj.mT[3] + " " + obj.mT[4] + " " + obj.mT[5] + " " + obj.mT[6] + " " + obj.mT[7] + " " + obj.mT[8] + " " + obj.mT[9] + " " + obj.mT[10] + " " + obj.mT[11] + " " + obj.mT[12] + " " + obj.mT[13] + " " + obj.mT[14] + " " + obj.mT[15] + " r " + obj.rX + " " + obj.rY + " " + obj.rZ + " s " + obj.sX + " " + obj.sY + " " + obj.sZ + " t " + obj.tX + " " + obj.tY + " " + obj.tZ;
    }, "Object from a default Item contains no unexpected keys", "index mT rX rY rZ sX sY sZ tX tY tZ", function(oo3d, item) {
      var k, obj, v;
      obj = item.read();
      return ((function() {
        var results;
        results = [];
        for (k in obj) {
          v = obj[k];
          results.push(k);
        }
        return results;
      })()).sort().join(' ');
    }, "Dumped 'log' from a default Item as expected", "i 4 mT 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 r 0 0 0 s 1 1 1 t 0 0 0", function(oo3d, item) {
      return item.read('log');
    }, "Dumped 'nwang' from a default Item as expected", "쨔죨셼셼셼셼죨셼셼셼셼죨셼셼셼셼죨셼셼셼죨죨죨셼셼셼", function(oo3d, item) {
      return item.read('nwang');
    }, function(oo3d, item, itemI) {
      item.edit({
        rX: 0.001,
        rY: (Math.PI * -2 / 2306) + 0.0001,
        rZ: (Math.PI / 6) + (Math.PI * 10),
        sX: 0.001,
        sY: -0.5000001,
        sZ: 12,
        tX: 0.001,
        tY: -0.5000001,
        tZ: 12
      });
      return [oo3d, item, itemI];
    }, "Dumped 'log' from a transformed Item as expected", "i 4 mT 0.0008660224266350269 0.0004999974626116455 0.0000027730632154998602 0 0.24999919533729553 -0.4330132305622101 0.00022316427202895284 0 -0.03149650618433952 -0.011999956332147121 11.99995231628418 0 0.0010000000474974513 -0.5000001192092896 12 1 r 0.001 -0.0026247117550648683 31.93952531149623 s 0.001 -0.5000001 12 t 0.001 -0.5000001 12", function(oo3d, item) {
      return item.read('log');
    }, "Dumped 'nwang' from a transformed Item as expected", '쨔솅솁셼셼엺뱇셾셼쁁섄첀셼솆밄첀죨솆셢쵇솆밄첀솆밄첀', function(oo3d, item) {
      return item.read('nwang');
    }
  ]);

  tudor.add([
    "3-1-04 `item.edit()`", tudor.is, "(Mock an Oo3d instance)", mockOo3d, "The method is a function and returns an object", "`item.edit()` is a function", ªF, function(oo3d, item) {
      return item.edit;
    }, "`item.edit()` returns an object", ªO, function(oo3d, item) {
      return item.edit();
    }, "`item.edit('i 4 mT 1 0 0 0 ... t 0 0 0')` returns an object", ªO, function(oo3d, item) {
      return item.edit("i 4 mT 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 r 0 0 0 s 1 1 1 t 0 0 0");
    }, "`item.rX` is a number", ªN, function(oo3d, item) {
      return item.rX;
    }, "`item.rY` is a number", ªN, function(oo3d, item) {
      return item.rY;
    }, "`item.rZ` is a number", ªN, function(oo3d, item) {
      return item.rZ;
    }, "`item.sX` is a number", ªN, function(oo3d, item) {
      return item.sX;
    }, "`item.sY` is a number", ªN, function(oo3d, item) {
      return item.sY;
    }, "`item.sZ` is a number", ªN, function(oo3d, item) {
      return item.sZ;
    }, "`item.tX` is a number", ªN, function(oo3d, item) {
      return item.tX;
    }, "`item.tY` is a number", ªN, function(oo3d, item) {
      return item.tY;
    }, "`item.tZ` is a number", ªN, function(oo3d, item) {
      return item.tZ;
    }, "Ensure private functions cannot be accessed", tudor.equal, "`xx()` cannot be accessed", ªU, function(oo3d, item) {
      return typeof xx;
    }, "`set` argument exceptions", tudor["throw"], "`set` cannot be a Date object", "/oo3d/src/item/base-item.litcoffee Item#4:edit()\n  Optional `set` is date not string|object", function(oo3d, item) {
      return item.edit(new Date);
    }, "`set` cannot be the string 'NOPE!'", "/oo3d/src/item/base-item.litcoffee Item#4:edit()\n  Optional `set` is string but not 'reset' or log|nwang format", function(oo3d, item) {
      return item.edit('NOPE!');
    }, "`set` cannot be an empty string", "/oo3d/src/item/base-item.litcoffee Item#4:edit()\n  Optional `set` is string but not 'reset' or log|nwang format", function(oo3d, item) {
      return item.edit('');
    }, "An object passed to the `set` argument must not must not change `item.index` to a boolean", "/oo3d/src/item/base-item.litcoffee Item#4:edit()\n  `this.index` cannot be altered by `set.index`", function(oo3d, item) {
      return item.edit({
        index: true
      });
    }, "An object passed to the `set` argument must not must not change `item.index` to a number", "/oo3d/src/item/base-item.litcoffee Item#4:edit()\n  `this.index` cannot be altered by `set.index`", function(oo3d, item) {
      return item.edit({
        index: 1234
      });
    }, "An `sY` property passed to the `set` argument must be a number", "/oo3d/src/item/base-item.litcoffee Item#4:edit()\n  `set.sY` is array not number", function(oo3d, item) {
      return item.edit({
        rX: 1,
        sY: ['NOPE!'],
        tZ: 3
      });
    }, "A `tX` property passed to the `set` argument must not be NaN", "/oo3d/src/item/base-item.litcoffee Item#4:edit()\n  `set.tX` is NaN", function(oo3d, item) {
      return item.edit({
        rX: 1,
        tX: NaN,
        tZ: 3
      });
    }, "An `mT` property passed to the `set` argument must be Float32Array|array", "/oo3d/src/item/base-item.litcoffee Item#4:edit()\n  `set.TtM` is object not array|*Array", function(oo3d, item) {
      return item.edit({
        mT: {}
      });
    }, "An `mT` property passed to the `set` argument must contain 16 values", "/oo3d/src/item/base-item.litcoffee Item#4:edit()\n  `set.TtM` has 17 elements not 16", function(oo3d, item) {
      return item.edit({
        mT: [1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7]
      });
    }, "An 'nwang' string passed to the `set` argument must not be 8 characters", "/oo3d/src/item/base-item.litcoffee Item#4:edit()\n  `set` appears to be 'nwang' but is 8 characters", function(oo3d, item) {
      return item.edit('솆셢쵇솆밄첀솆밄');
    }, "An 'nwang' string passed to the `set` argument must not be 10 characters", "/oo3d/src/item/base-item.litcoffee Item#4:edit()\n  `set` appears to be 'nwang' but is 10 characters", function(oo3d, item) {
      return item.edit('솆셢쵇솆밄첀솆밄첀첀');
    }, "An 'nwang' string passed to the `set` argument must be valid nwang", "/nwang/src/class-main.litcoffee:Main:sf3()\n  `x` codepoint 102 < 44032", function(oo3d, item) {
      return item.edit('솆셢쵇솆밄foo첀');
    }, "An 'nwang' string passed to the `set` argument must not change `item.index`", "/oo3d/src/item/base-item.litcoffee Item#4:edit()\n  `this.index` cannot be altered by passing `set` an 'nwang'", function(oo3d, item) {
      return item.edit('솆솅솁셼셼엺뱇셾셼쁁섄첀셼밁쑑퀜죨솆셢쵇솆밄첀솆밄첀');
    }, "A 9-value 'log' string passed to the `set` argument must only contain numbers", "/oo3d/src/item/base-item.litcoffee Item#4:edit()\n  `set` appears to be 9-char 'log' with non-numeric values", function(oo3d, item) {
      return item.edit('r A B C s foo bar baz t 7 8 9');
    }, "A 16-value 'log' string passed to the `set` argument must only contain numbers", "/oo3d/src/item/base-item.litcoffee Item#4:edit()\n  `set` appears to be 26-char 'log' with non-numeric values", function(oo3d, item) {
      return item.edit('i 4 mT 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 r A B C s foo bar baz t 7 8 9');
    }, "A 'log' string passed to the `set` argument must not change `item.index`", "/oo3d/src/item/base-item.litcoffee Item#4:edit()\n  `this.index` cannot be altered by passing `set` a 'log'", function(oo3d, item) {
      return item.edit('i 12345 mT 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 r 1 2 3 s 4 5 6 t 7 8 9');
    }, "`delta` argument exceptions", tudor["throw"], "`delta` cannot be the Math object", "/oo3d/src/item/base-item.litcoffee Item#4:edit()\n  Optional `delta` is math not string|object", function(oo3d, item) {
      return item.edit(null, Math);
    }, "`delta` cannot be the string 'NOPE!'", "/oo3d/src/item/base-item.litcoffee Item#4:edit()\n  Optional `delta` is a string, but not 'log|nwang' format", function(oo3d, item) {
      return item.edit(null, 'NOPE!');
    }, "`delta` cannot be an empty string", "/oo3d/src/item/base-item.litcoffee Item#4:edit()\n  Optional `delta` is a string, but not 'log|nwang' format", function(oo3d, item) {
      return item.edit(null, '');
    }, "An `rX` property passed to the `delta` argument must be a number", "/oo3d/src/item/base-item.litcoffee Item#4:edit()\n  `delta.rX` is string not number", function(oo3d, item) {
      return item.edit(null, {
        rX: '22'
      });
    }, "A `tZ` property passed to the `set` argument must not be NaN", "/oo3d/src/item/base-item.litcoffee Item#4:edit()\n  `delta.tZ` is NaN", function(oo3d, item) {
      return item.edit(null, {
        rX: Math.PI,
        tX: -44.3,
        tZ: NaN
      });
    }, "An 'nwang' string passed to the `delta` argument must not be 8 characters", "/oo3d/src/item/base-item.litcoffee Item#4:edit()\n  `delta` appears to be 'nwang' but is 8 characters", function(oo3d, item) {
      return item.edit(null, '솆셢쵇솆밄첀솆밄');
    }, "An 'nwang' string passed to the `delta` argument must not be 26 characters", "/oo3d/src/item/base-item.litcoffee Item#4:edit()\n  `delta` appears to be 'nwang' but is 26 characters", function(oo3d, item) {
      return item.edit(null, '솆솅솁셼셼엺뱇셾셼쁁섄첀셼밁쑑퀜죨솆셢쵇솆밄첀솆밄첀');
    }, "An 'nwang' string passed to the `delta` argument must be valid nwang", "/nwang/src/class-main.litcoffee:Main:sf3()\n  `x` codepoint 102 < 44032", function(oo3d, item) {
      return item.edit(null, '셼셼셼죨죨foo셼');
    }, "A 'log' string passed to the `delta` argument must only contain numbers", "/oo3d/src/item/base-item.litcoffee Item#4:edit()\n  `delta` appears to be 9-char 'log' with non-numeric values", function(oo3d, item) {
      return item.edit(null, 'r 88 77 66 s foo bar baz t A Z 9');
    }, "Noop ways of calling `item.edit()`", tudor.equal, "No arguments", 'i 4 mT 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 r 0 0 0 s 1 1 1 t 0 0 0', function(oo3d, item) {
      item.edit();
      return item.read('log');
    }, "Pass null to the `set` and `delta` arguments", 'i 4 mT 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 r 0 0 0 s 1 1 1 t 0 0 0', function(oo3d, item) {
      item.edit(null, null);
      return item.read('log');
    }, "Pass undefined to the `set` and `delta` arguments", 'i 4 mT 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 r 0 0 0 s 1 1 1 t 0 0 0', function(oo3d, item) {
      item.edit(void 0, void 0);
      return item.read('log');
    }, "Pass empty object to the `set` argument", 'i 4 mT 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 r 0 0 0 s 1 1 1 t 0 0 0', function(oo3d, item) {
      item.edit({});
      return item.read('log');
    }, "Pass empty object to the `delta` argument", 'i 4 mT 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 r 0 0 0 s 1 1 1 t 0 0 0', function(oo3d, item) {
      item.edit(void 0, {});
      return item.read('log');
    }, "Pass empty objects to the `set` and `delta` arguments", 'i 4 mT 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 r 0 0 0 s 1 1 1 t 0 0 0', function(oo3d, item) {
      item.edit({}, {});
      return item.read('log');
    }, "Pass an object to the `set` argument", "Pass a complete object to the `set` argument", 'i 4 mT 1 2 2 2 2 1 3 3 3 3 1 4 4 4 4 1 r 1 2 3 s 4 5 6 t 7 8 9', function(oo3d, item) {
      item.edit({
        index: 4,
        mT: [1, 2, 2, 2, 2, 1, 3, 3, 3, 3, 1, 4, 4, 4, 4, 1],
        rX: 1,
        rY: 2,
        rZ: 3,
        sX: 4,
        sY: 5,
        sZ: 6,
        tX: 7,
        tY: 8,
        tZ: 9
      });
      return item.read('log');
    }, "Pass a partial object to the `set` argument, which includes `mT`", 'i 4 mT 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 r 1 2 3 s 4 5 6 t 44 8 9', function(oo3d, item) {
      item.edit({
        mT: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        tX: 44
      });
      return item.read('log');
    }, "Pass a partial object to the `set` argument, which does not include `mT`", 'i 4 mT 1.6479289531707764 -2.724970817565918 2.420509099960327 0 0.29363322257995605 -3.2143642902374268 -3.818591594696045 0 5.455784797668457 2.10105299949646 -1.3490705490112305 0 44 55 66 1 r 1 2 3 s 4 5 6 t 44 55 66', function(oo3d, item) {
      item.edit({
        tY: 55,
        tZ: 66
      });
      return item.read('log');
    }, "Random properties are ignored", 'i 4 mT 1.6479289531707764 -2.724970817565918 2.420509099960327 0 0.29363322257995605 -3.2143642902374268 -3.818591594696045 0 5.455784797668457 2.10105299949646 -1.3490705490112305 0 44 55 100 1 r 1 2 3 s 4 5 6 t 44 55 100', function(oo3d, item) {
      item.edit({
        foo: 'IGNORED!',
        bar: 'IGNORED!',
        tZ: 100
      });
      return item.read('log');
    }, "An `mT` property passed to the `set` argument can contain non-numeric values (will become NaN)", "i 4 mT 1 2 3 4 5 6 7 8 9 NaN 1 2 3 4 5 6 r 1 2 3 s 4 5 6 t 44 55 100", function(oo3d, item) {
      item.edit({
        mT: [1, 2, 3, 4, 5, 6, 7, 8, 9, 'ten', 1, 2, 3, 4, 5, 6]
      });
      return item.read('log');
    }, "An `mT` property passed to the `set` argument can be UInt8Array", "i 4 mT 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 r 1 2 3 s 4 5 6 t 44 55 100", function(oo3d, item) {
      item.edit({
        mT: new Uint8Array([8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8])
      });
      return item.read('log');
    }, "Pass an 'nwang' string to the `set` argument", "Pass a 26-value 'nwang' string to the `set` argument", "i 4 mT 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 r 0.001 -0.0026 31.9 s 0.001 -0.5 12 t 0.001 -0.5 12", function(oo3d, item) {
      item.edit('쨔죨셼셼셼셼죨셼셼셼셼죨셼셼셼셼죨솆셢쵇솆밄첀솆밄첀');
      return item.read('log');
    }, "Pass a 9-value 'nwang' string to the `set` argument", 'i 4 mT 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 r 0 0 0 s 1 1 1 t 0 0 0', function(oo3d, item) {
      item.edit('셼셼셼죨죨죨셼셼셼');
      return item.read('log');
    }, "Pass a 'log' string to the `set` argument", "Pass a 26-value 'log' string to the `set` argument, which resets the Item", 'i 4 mT 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 r 0 0 0 s 1 1 1 t 0 0 0', function(oo3d, item) {
      item.edit('i 4 mT 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 r 0 0 0 s 1 1 1 t 0 0 0');
      return item.read('log');
    }, "Note that an inconsistent 26-value 'log' should be accepted without complaint!", 'i 4 mT 1 2 3 4 5 6 7 8 9 0 1 0 0 0 0 1 r 0 0 0 s 1 1 1 t 0 0 0', function(oo3d, item) {
      item.edit('i 4 mT 1 2 3 4 5 6 7 8 9 0 1 0 0 0 0 1 r 0 0 0 s 1 1 1 t 0 0 0');
      return item.read('log');
    }, "Pass a 9-value 'log' string to the `set` argument", 'i 4 mT -0.6581568121910095 -1.7472580671310425 5.7020978927612305 0 0.4779578745365143 -4.773890972137451 -1.4076658487319946 0 3.957432985305786 0.23985300958156586 0.5302779078483582 0 3 2 1 1 r 9 8 7 s 6 5 4 t 3 2 1', function(oo3d, item) {
      item.edit('r 9 8 7 s 6 5 4 t 3 2 1');
      return item.read('log');
    }, "Pass an object to the `delta` argument", "Pass a 'unity' 9-value object to the `delta` argument", 'i 4 mT -0.6581568121910095 -1.7472580671310425 5.7020978927612305 0 0.4779578745365143 -4.773890972137451 -1.4076658487319946 0 3.957432985305786 0.23985300958156586 0.5302779078483582 0 3 2 1 1 r 9 8 7 s 6 5 4 t 3 2 1', function(oo3d, item) {
      item.edit(null, {
        rX: 0,
        rY: 0,
        rZ: 0,
        sX: 1,
        sY: 1,
        sZ: 1,
        tX: 0,
        tY: 0,
        tZ: 0
      });
      return item.read('log');
    }, "Pass a transforming 9-value object to the `delta` argument", 'i 4 mT 25.574983596801758 22.437387466430664 -33.85976791381836 0 -29.616554260253906 9.995354652404785 -15.746511459350586 0 -0.2124314159154892 20.078948974609375 13.144987106323242 0 21 22 23 1 r 21 22 23 s 48 35 24 t 21 22 23', function(oo3d, item) {
      item.edit(null, {
        rX: 12,
        rY: 14,
        rZ: 16,
        sX: 8,
        sY: 7,
        sZ: 6,
        tX: 18,
        tY: 20,
        tZ: 22
      });
      return item.read('log');
    }, "Pass a transforming 2-value object to the `delta` argument", 'i 4 mT 25.574983596801758 -3.992623805999756 40.422508239746094 0 74.0413818359375 3.6715314388275146 -46.48271942138672 0 -0.2124314159154892 -23.895618438720703 -2.2258212566375732 0 21 22 23 1 r -479 22 23 s 48 -87.5 24 t 21 22 23', function(oo3d, item) {
      item.edit(null, {
        rX: -500,
        sY: -2.5
      });
      return item.read('log');
    }, "Pass an 'nwang' string to the `delta` argument", "Pass a 'unity' 9-value 'nwang' string to the `delta` argument", 'i 4 mT 25.574983596801758 -3.992623805999756 40.422508239746094 0 74.0413818359375 3.6715314388275146 -46.48271942138672 0 -0.2124314159154892 -23.895618438720703 -2.2258212566375732 0 21 22 23 1 r -479 22 23 s 48 -87.5 24 t 21 22 23', function(oo3d, item) {
      item.edit(null, '셼셼셼죨죨죨셼셼셼');
      return item.read('log');
    }, "Pass a transforming 9-value 'nwang' string to the `delta` argument", 'i 4 mT 0 0 0 0 -18.84529685974121 -2.4989914894104004 39.695213317871094 0 0.00007556568016298115 -0.023954685777425766 -0.0014721800107508898 0 165 23 23.000999450683594 1 r -479.0315 21.988 35 s 0 44.0125 0.024 t 165 23 23.001', function(oo3d, item) {
      item.edit(null, '쁁섄첀셼밁솆퀜죨솆');
      return item.read('log');
    }
  ]);

  tudor.add([
    "3-2-01 `new Item.Mesh`", tudor.is, "(Mock an Oo3d instance)", mockOo3d, "The class and instance are expected types", "The class is a function", ªF, function() {
      return Item.Mesh;
    }, "`new` returns an object", ªO, function(oo3d) {
      return new Item.Mesh(oo3d, 0);
    }, "Item Constructor exceptions", tudor["throw"], "`config.main` must be an object", "/oo3d/src/item/base-item.litcoffee Item#NaN()\n  `main` is number not object", function(oo3d) {
      return new Item.Mesh(123);
    }, "`config.main` must be an Oo3d instance", "/oo3d/src/item/base-item.litcoffee Item#NaN()\n  `main` is '[object Object]' not '[object Oo3d]'", function(oo3d) {
      return new Item.Mesh({});
    }, "`index` must be a number", "/oo3d/src/item/base-item.litcoffee Item#1()\n  `index` is boolean not number", function(oo3d) {
      return new Item.Mesh(oo3d, true);
    }, "`index` must be an integer", "/oo3d/src/item/base-item.litcoffee Item#3.5()\n  `index` is 3.5 not 0 or a positive integer below 2^53", function(oo3d) {
      return new Item.Mesh(oo3d, 3.5);
    }, "`index` must be positive", "/oo3d/src/item/base-item.litcoffee Item#-44()\n  `index` is -44 not 0 or a positive integer below 2^53", function(oo3d) {
      return new Item.Mesh(oo3d, -44);
    }, "`index` must be below 2^53", "/oo3d/src/item/base-item.litcoffee Item#9007199254740992()\n  `index` is 9007199254740992 not 0 or a positive integer below 2^53", function(oo3d) {
      return new Item.Mesh(oo3d, 9007199254740992);
    }, "`config` must be an object", "/oo3d/src/item/base-item.litcoffee Item#0()\n  Optional `config` is date not object", function(oo3d) {
      return new Item.Mesh(oo3d, 0, new Date);
    }, "Item.Mesh Constructor exceptions", "If set, config.positionI must refer to an actual positionBuffer", "/oo3d/src/item/class-item-mesh.litcoffee Item.Mesh#0()\n  `config.positionI` foo does not exist", function(oo3d) {
      return new Item.Mesh(oo3d, 0, {
        positionI: 'foo'
      });
    }, "If set, config.colorI must refer to an actual colorBuffer", "/oo3d/src/item/class-item-mesh.litcoffee Item.Mesh#0()\n  `config.colorI` 123 does not exist", function(oo3d) {
      return new Item.Mesh(oo3d, 0, {
        colorI: 123
      });
    }, "A positionBuffer with one coordinate does not match a colorBuffer with two", "/oo3d/src/item/class-item-mesh.litcoffee Item.Mesh#0()\n  `config.positionI` mismatches config.colorI", function(oo3d) {
      var colorI, positionI;
      positionI = oo3d.add('Buffer.Position', {
        data: [1, 2, 3]
      });
      colorI = oo3d.add('Buffer.Color', {
        data: [1, 0, 0, 1, 0, 1, 0, 1]
      });
      return new Item.Mesh(oo3d, 0, {
        positionI: positionI,
        colorI: colorI
      });
    }, "If set, config.renderMode must be a recognised value", "/oo3d/src/item/class-item-mesh.litcoffee Item.Mesh#0()\n  `config.renderMode` ZERO is not recognised by WebGL", function(oo3d) {
      return new Item.Mesh(oo3d, 0, {
        renderMode: 'ZERO'
      });
    }, "If set, config.blend must be an array", "/oo3d/src/item/class-item-mesh.litcoffee Item.Mesh#0()\n  If set, `config.blend` must be array not number", function(oo3d) {
      return new Item.Mesh(oo3d, 0, {
        blend: 1
      });
    }, "config.blend[0] (for item.sBlend) must be a recognised value", "/oo3d/src/item/class-item-mesh.litcoffee Item.Mesh#0()\n  `config.blend[0]` is not recognised by WebGL", function(oo3d) {
      return new Item.Mesh(oo3d, 0, {
        blend: ['TRIANGLES']
      });
    }, "config.blend[1] (for item.dBlend) must be a recognised value", "/oo3d/src/item/class-item-mesh.litcoffee Item.Mesh#0()\n  `config.blend[1]` is not recognised by WebGL", function(oo3d) {
      return new Item.Mesh(oo3d, 0, {
        blend: ['ZERO']
      });
    }, "Item Constructor usage", tudor.equal, "`config` can be an empty object", '[object Item.Mesh]', function(oo3d) {
      var mesh;
      mesh = new Item.Mesh(oo3d, 0, {});
      return '' + mesh;
    }, "`item.mT` as expected", '1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1', function(oo3d) {
      var mesh, n;
      mesh = new Item.Mesh(oo3d, 0, {});
      return ((function() {
        var j, len, ref, results;
        ref = mesh.mT;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          n = ref[j];
          results.push('' + n);
        }
        return results;
      })()).join(' ');
    }, "`mesh.rX` `mesh.rY` `mesh.rZ` as expected", '0 0 0', function(oo3d) {
      var mesh;
      mesh = new Item.Mesh(oo3d, 0, {});
      return [mesh.rX, mesh.rY, mesh.rZ].join(' ');
    }, "`mesh.sX` `mesh.sY` `mesh.sZ` as expected", '1 1 1', function(oo3d) {
      var mesh;
      mesh = new Item.Mesh(oo3d, 0, {});
      return [mesh.sX, mesh.sY, mesh.sZ].join(' ');
    }, "`mesh.tX` `mesh.tY` `mesh.tZ` as expected", '0 0 0', function(oo3d) {
      var mesh;
      mesh = new Item.Mesh(oo3d, 0, {});
      return [mesh.tX, mesh.tY, mesh.tZ].join(' ');
    }, "Item.Mesh Constructor usage", "Complete set of `config` defaults", 'TRIANGLESnullnull', function(oo3d) {
      var mesh;
      mesh = new Item.Mesh(oo3d, 0, {
        positionI: 0,
        colorI: 0,
        renderMode: null,
        blend: null
      });
      return mesh.renderMode + (ªtype(mesh.sBlend)) + (ªtype(mesh.dBlend));
    }
  ]);

  tudor.add([
    "3-3-01 `new Item.Camera`", tudor.is, "(Mock an Oo3d instance)", mockOo3d, "The class and instance are expected types", "The class is a function", ªF, function() {
      return Item.Camera;
    }, "`new` returns an object", ªO, function(oo3d) {
      return new Item.Camera(oo3d, 0);
    }, "Item Constructor exceptions", tudor["throw"], "`config.main` must be an object", "/oo3d/src/item/base-item.litcoffee Item#NaN()\n  `main` is number not object", function(oo3d) {
      return new Item.Camera(123);
    }, "`config.main` must be an Oo3d instance", "/oo3d/src/item/base-item.litcoffee Item#NaN()\n  `main` is '[object Object]' not '[object Oo3d]'", function(oo3d) {
      return new Item.Camera({});
    }, "`index` must be a number", "/oo3d/src/item/base-item.litcoffee Item#1()\n  `index` is boolean not number", function(oo3d) {
      return new Item.Camera(oo3d, true);
    }, "`index` must be an integer", "/oo3d/src/item/base-item.litcoffee Item#3.5()\n  `index` is 3.5 not 0 or a positive integer below 2^53", function(oo3d) {
      return new Item.Camera(oo3d, 3.5);
    }, "`index` must be positive", "/oo3d/src/item/base-item.litcoffee Item#-44()\n  `index` is -44 not 0 or a positive integer below 2^53", function(oo3d) {
      return new Item.Camera(oo3d, -44);
    }, "`index` must be below 2^53", "/oo3d/src/item/base-item.litcoffee Item#9007199254740992()\n  `index` is 9007199254740992 not 0 or a positive integer below 2^53", function(oo3d) {
      return new Item.Camera(oo3d, 9007199254740992);
    }, "`config` must be an object", "/oo3d/src/item/base-item.litcoffee Item#0()\n  Optional `config` is date not object", function(oo3d) {
      return new Item.Camera(oo3d, 0, new Date);
    }, "Item.Camera Constructor exceptions", "If set, config.fovy must be a number", "/oo3d/src/item/class-item-camera.litcoffee Item.Camera#0()\n  Optional `config.fovy` is string not number", function(oo3d) {
      return new Item.Camera(oo3d, 0, {
        fovy: 'abc'
      });
    }, "If set, config.fovy must be greater than zero", "/oo3d/src/item/class-item-camera.litcoffee Item.Camera#0()\n  Optional `config.fovy` is 0 not greater than zero", function(oo3d) {
      return new Item.Camera(oo3d, 0, {
        fovy: 0
      });
    }, "If set, config.aspect must be a number", "/oo3d/src/item/class-item-camera.litcoffee Item.Camera#0()\n  Optional `config.aspect` is array not number", function(oo3d) {
      return new Item.Camera(oo3d, 0, {
        aspect: []
      });
    }, "If set, config.aspect must be greater than zero", "/oo3d/src/item/class-item-camera.litcoffee Item.Camera#0()\n  Optional `config.aspect` is -3 not greater than zero", function(oo3d) {
      return new Item.Camera(oo3d, 0, {
        aspect: -3
      });
    }, "Item Constructor usage", tudor.equal, "`config` can be an empty object", '[object Item.Camera]', function(oo3d) {
      var camera;
      camera = new Item.Camera(oo3d, 0, {});
      return '' + camera;
    }, "`item.mT` as expected", '1 0 0 0 0 1 0 0 0 0 1 0 0 0 -4 1', function(oo3d) {
      var camera, n;
      camera = new Item.Camera(oo3d, 0, {});
      return ((function() {
        var j, len, ref, results;
        ref = camera.mT;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          n = ref[j];
          results.push('' + n);
        }
        return results;
      })()).join(' ');
    }, "`camera.rX` `camera.rY` `camera.rZ` as expected", '0 0 0', function(oo3d) {
      var camera;
      camera = new Item.Camera(oo3d, 0, {});
      return [camera.rX, camera.rY, camera.rZ].join(' ');
    }, "`camera.sX` `camera.sY` `camera.sZ` as expected", '1 1 1', function(oo3d) {
      var camera;
      camera = new Item.Camera(oo3d, 0, {});
      return [camera.sX, camera.sY, camera.sZ].join(' ');
    }, "`camera.tX` `camera.tY` `camera.tZ` as expected", '0 0 -4', function(oo3d) {
      var camera;
      camera = new Item.Camera(oo3d, 0, {});
      return [camera.tX, camera.tY, camera.tZ].join(' ');
    }, "Item.Camera Constructor usage", "Complete set of `config` defaults", '0.785398163 2', function(oo3d) {
      var camera;
      camera = new Item.Camera(oo3d, 0);
      return camera.fovy + ' ' + camera.aspect;
    }
  ]);

  tudor.add([
    "4-1-01 `new Layer`", tudor.is, "(Mock an Oo3d instance)", mockOo3d, "The class and instance are expected types", "The class is a function", ªF, function() {
      return Layer;
    }, "`new` returns an object", ªO, function(oo3d) {
      return new Layer(oo3d, 0);
    }, tudor.equal, "`layer.toString()` as expected", '[object Layer]', function(oo3d) {
      var layer;
      layer = new Layer(oo3d, 0);
      return '' + layer;
    }, "`layer.C` as expected", 'Layer', function(oo3d) {
      var layer;
      layer = new Layer(oo3d, 0);
      return layer.C;
    }, "layer Constructor exceptions", tudor["throw"], "`config.main` must be an object", "/oo3d/src/layer/base-layer.litcoffee Layer#NaN()\n  `main` is number not object", function(oo3d) {
      return new Layer(123);
    }, "`config.main` must be an Oo3d instance", "/oo3d/src/layer/base-layer.litcoffee Layer#NaN()\n  `main` is '[object Object]' not '[object Oo3d]'", function(oo3d) {
      return new Layer({});
    }, "`index` must be a number", "/oo3d/src/layer/base-layer.litcoffee Layer#1()\n  `index` is boolean not number", function(oo3d) {
      return new Layer(oo3d, true);
    }, "`index` must be an integer", "/oo3d/src/layer/base-layer.litcoffee Layer#3.5()\n  `index` is 3.5 not 0 or a positive integer below 2^53", function(oo3d) {
      return new Layer(oo3d, 3.5);
    }, "`index` must be positive", "/oo3d/src/layer/base-layer.litcoffee Layer#-44()\n  `index` is -44 not 0 or a positive integer below 2^53", function(oo3d) {
      return new Layer(oo3d, -44);
    }, "`index` must be below 2^53", "/oo3d/src/layer/base-layer.litcoffee Layer#9007199254740992()\n  `index` is 9007199254740992 not 0 or a positive integer below 2^53", function(oo3d) {
      return new Layer(oo3d, 9007199254740992);
    }, "`config` must be an object", "/oo3d/src/layer/base-layer.litcoffee Layer#0()\n  Optional `config` is date not object", function(oo3d) {
      return new Layer(oo3d, 0, new Date);
    }, "`config.rendererIs` must be a regular array", "/oo3d/src/layer/base-layer.litcoffee Layer#0()\n  `config.rendererIs` is uint8array not array", function(oo3d) {
      return new Layer(oo3d, 0, {
        rendererIs: new Uint8Array()
      });
    }, function(oo3d) {
      oo3d.add('Item.Mesh');
      oo3d.add('Renderer.Wireframe', {
        programI: oo3d.add('Item.Camera'),
        cameraI: oo3d.add('Program.Flat')
      });
      return [oo3d];
    }, "`config.rendererIs` must only contain numbers", "/oo3d/src/layer/base-layer.litcoffee Layer#0()\n  `config.rendererIs[1]` is string not number", function(oo3d) {
      return new Layer(oo3d, 0, {
        rendererIs: [8, 'foo', 8, 'bar']
      });
    }, "`config.rendererIs` must all refer to Renderer instances", "/oo3d/src/layer/base-layer.litcoffee Layer#0()\n  `config.rendererIs[0]` refs Item.Camera at `main._all[6]`", function(oo3d) {
      return new Layer(oo3d, 0, {
        rendererIs: [6, 7, 'foobar']
      });
    }, "layer Constructor usage", tudor.equal, "Complete set of `config` defaults", ªA, function(oo3d) {
      var layer;
      layer = new Layer(oo3d, 0, {
        rendererIs: [8, 8]
      });
      return ªtype(layer.renderers);
    }
  ]);

  tudor.add([
    "9-1-01 `pick.indexToColor()`", tudor.is, "The function exists, and returns the expected type", "The container exists", ªO, function() {
      return pick;
    }, "The function exists", ªF, function() {
      return pick.indexToColor;
    }, "`pick.indexToColor(0)` returns a Float32Array", 'float32array', function() {
      return pick.indexToColor(0);
    }, "`pick.indexToColor()` usage", tudor.equal, "Returns an array with four elements", 4, function() {
      return pick.indexToColor(0).length;
    }, "Zero returns black, with 100% alpha", '0 0 0 255', function() {
      var channel;
      return ((function() {
        var j, len, ref, results;
        ref = pick.indexToColor(0);
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          channel = ref[j];
          results.push(channel * 255);
        }
        return results;
      })()).join(' ');
    }, "`1` returns 50% brightness red", '128 0 0 255', function() {
      var channel;
      return ((function() {
        var j, len, ref, results;
        ref = pick.indexToColor(1);
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          channel = ref[j];
          results.push(Math.round(channel * 255));
        }
        return results;
      })()).join(' ');
    }, "`1` to `7` return combinations of R, G and B at 50% brightness", "1: 128   0   0 255\n2:   0 128   0 255\n3: 128 128   0 255\n4:   0   0 128 255\n5: 128   0 128 255\n6:   0 128 128 255\n7: 128 128 128 255", function() {
      var channel, i;
      return ((function() {
        var j, results;
        results = [];
        for (i = j = 1; j <= 7; i = ++j) {
          results.push(i + ': ' + ((function() {
            var l, len, ref, results1;
            ref = pick.indexToColor(i);
            results1 = [];
            for (l = 0, len = ref.length; l < len; l++) {
              channel = ref[l];
              results1.push(('  ' + Math.round(channel * 255)).slice(-3));
            }
            return results1;
          })()).join(' '));
        }
        return results;
      })()).join('\n');
    }, "`585, 521, 73, 9, 577, 513, 65, 1, 584, 520, 72, 8` return various shades of red", "585: 240   0   0 255\n521: 208   0   0 255\n 73: 224   0   0 255\n  9: 192   0   0 255\n577: 176   0   0 255\n513: 144   0   0 255\n 65: 160   0   0 255\n  1: 128   0   0 255\n584: 112   0   0 255\n520:  80   0   0 255\n 72:  96   0   0 255\n  8:  64   0   0 255", function() {
      var channel, i;
      return ((function() {
        var j, len, ref, results;
        ref = [parseInt('1001001001', 2), parseInt('1000001001', 2), parseInt('0001001001', 2), parseInt('0000001001', 2), parseInt('1001000001', 2), parseInt('1000000001', 2), parseInt('0001000001', 2), parseInt('0000000001', 2), parseInt('1001001000', 2), parseInt('1000001000', 2), parseInt('0001001000', 2), parseInt('0000001000', 2)];
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          i = ref[j];
          results.push(('  ' + i).slice(-3) + ': ' + ((function() {
            var l, len1, ref1, results1;
            ref1 = pick.indexToColor(i);
            results1 = [];
            for (l = 0, len1 = ref1.length; l < len1; l++) {
              channel = ref1[l];
              results1.push(('  ' + Math.round(channel * 255)).slice(-3));
            }
            return results1;
          })()).join(' '));
        }
        return results;
      })()).join('\n');
    }, "`585, 73, 521, 9, 577, 65, 513, 1, 584, 72, 520, 8, 576, 64, 512, 0` return various shades of red", "585: 240   0   0 255\n 73: 224   0   0 255\n521: 208   0   0 255\n  9: 192   0   0 255\n577: 176   0   0 255\n 65: 160   0   0 255\n513: 144   0   0 255\n  1: 128   0   0 255\n584: 112   0   0 255\n 72:  96   0   0 255\n520:  80   0   0 255\n  8:  64   0   0 255\n576:  48   0   0 255\n 64:  32   0   0 255\n512:  16   0   0 255\n  0:   0   0   0 255", function() {
      var channel, i;
      return ((function() {
        var j, len, ref, results;
        ref = [parseInt('1001001001', 2), parseInt('0001001001', 2), parseInt('1000001001', 2), parseInt('0000001001', 2), parseInt('1001000001', 2), parseInt('0001000001', 2), parseInt('1000000001', 2), parseInt('0000000001', 2), parseInt('1001001000', 2), parseInt('0001001000', 2), parseInt('1000001000', 2), parseInt('0000001000', 2), parseInt('1001000000', 2), parseInt('0001000000', 2), parseInt('1000000000', 2), parseInt('0000000000', 2)];
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          i = ref[j];
          results.push(('  ' + i).slice(-3) + ': ' + ((function() {
            var l, len1, ref1, results1;
            ref1 = pick.indexToColor(i);
            results1 = [];
            for (l = 0, len1 = ref1.length; l < len1; l++) {
              channel = ref1[l];
              results1.push(('  ' + Math.round(channel * 255)).slice(-3));
            }
            return results1;
          })()).join(' '));
        }
        return results;
      })()).join('\n');
    }, "`1170, 146, 1042, 18, 1154, 130, 1026, 2, 1168, 144, 1040, 16, 1152, 128, 1024, 0` return various shades of green", "1170:   0 240   0 255\n 146:   0 224   0 255\n1042:   0 208   0 255\n  18:   0 192   0 255\n1154:   0 176   0 255\n 130:   0 160   0 255\n1026:   0 144   0 255\n   2:   0 128   0 255\n1168:   0 112   0 255\n 144:   0  96   0 255\n1040:   0  80   0 255\n  16:   0  64   0 255\n1152:   0  48   0 255\n 128:   0  32   0 255\n1024:   0  16   0 255\n   0:   0   0   0 255", function() {
      var channel, i;
      return ((function() {
        var j, len, ref, results;
        ref = [parseInt('10010010010', 2), parseInt('00010010010', 2), parseInt('10000010010', 2), parseInt('00000010010', 2), parseInt('10010000010', 2), parseInt('00010000010', 2), parseInt('10000000010', 2), parseInt('00000000010', 2), parseInt('10010010000', 2), parseInt('00010010000', 2), parseInt('10000010000', 2), parseInt('00000010000', 2), parseInt('10010000000', 2), parseInt('00010000000', 2), parseInt('10000000000', 2), parseInt('00000000000', 2)];
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          i = ref[j];
          results.push(('   ' + i).slice(-4) + ': ' + ((function() {
            var l, len1, ref1, results1;
            ref1 = pick.indexToColor(i);
            results1 = [];
            for (l = 0, len1 = ref1.length; l < len1; l++) {
              channel = ref1[l];
              results1.push(('  ' + Math.round(channel * 255)).slice(-3));
            }
            return results1;
          })()).join(' '));
        }
        return results;
      })()).join('\n');
    }, "`2340, 292, 2084, 36, 2308, 260, 2052, 4, 2336, 288, 2080, 32, 2304, 256, 2048, 0` return various shades of blue", "2340:   0   0 240 255\n 292:   0   0 224 255\n2084:   0   0 208 255\n  36:   0   0 192 255\n2308:   0   0 176 255\n 260:   0   0 160 255\n2052:   0   0 144 255\n   4:   0   0 128 255\n2336:   0   0 112 255\n 288:   0   0  96 255\n2080:   0   0  80 255\n  32:   0   0  64 255\n2304:   0   0  48 255\n 256:   0   0  32 255\n2048:   0   0  16 255\n   0:   0   0   0 255", function() {
      var channel, i;
      return ((function() {
        var j, len, ref, results;
        ref = [parseInt('100100100100', 2), parseInt('000100100100', 2), parseInt('100000100100', 2), parseInt('000000100100', 2), parseInt('100100000100', 2), parseInt('000100000100', 2), parseInt('100000000100', 2), parseInt('000000000100', 2), parseInt('100100100000', 2), parseInt('000100100000', 2), parseInt('100000100000', 2), parseInt('000000100000', 2), parseInt('100100000000', 2), parseInt('000100000000', 2), parseInt('100000000000', 2), parseInt('000000000000', 2)];
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          i = ref[j];
          results.push(('   ' + i).slice(-4) + ': ' + ((function() {
            var l, len1, ref1, results1;
            ref1 = pick.indexToColor(i);
            results1 = [];
            for (l = 0, len1 = ref1.length; l < len1; l++) {
              channel = ref1[l];
              results1.push(('  ' + Math.round(channel * 255)).slice(-3));
            }
            return results1;
          })()).join(' '));
        }
        return results;
      })()).join('\n');
    }
  ]);

  tudor.add([
    "9-1-02 `pick.colorToIndex()`", tudor.is, "The function exists, and returns the expected type", "The container exists", ªO, function() {
      return pick;
    }, "The function exists", ªF, function() {
      return pick.colorToIndex;
    }, "`pick.colorToIndex(0)` returns a number", ªN, function() {
      return pick.colorToIndex([1, 2, 3, 255]);
    }, "`pick.colorToIndex()` usage", tudor.equal, "Black with 100% alpha returns zero", 0, function() {
      return pick.colorToIndex([0, 0, 0, 255]);
    }, "50% brightness red returns `1`", 1, function() {
      return pick.colorToIndex([128, 0, 0, 255]);
    }, "combinations of R, G and B at 50% brightness return `1` to `7`", "1 2 3 4 5 6 7", function() {
      var color;
      return ((function() {
        var j, len, ref, results;
        ref = [[128, 0, 0, 255], [0, 128, 0, 255], [128, 128, 0, 255], [0, 0, 128, 255], [128, 0, 128, 255], [0, 128, 128, 255], [128, 128, 128, 255]];
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          color = ref[j];
          results.push(pick.colorToIndex(color));
        }
        return results;
      })()).join(' ');
    }, "various shades of red return `585, 73, 521, 9, 577, 65, 513, 1, 584, 72, 520, 8, 576, 64, 512, 0`", "585 73 521 9 577 65 513 1 584 72 520 8 576 64 512 0", function() {
      var color;
      return ((function() {
        var j, len, ref, results;
        ref = [[240, 0, 0, 255], [224, 0, 0, 255], [208, 0, 0, 255], [192, 0, 0, 255], [176, 0, 0, 255], [160, 0, 0, 255], [144, 0, 0, 255], [128, 0, 0, 255], [112, 0, 0, 255], [96, 0, 0, 255], [80, 0, 0, 255], [64, 0, 0, 255], [48, 0, 0, 255], [32, 0, 0, 255], [16, 0, 0, 255], [0, 0, 0, 255]];
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          color = ref[j];
          results.push(pick.colorToIndex(color));
        }
        return results;
      })()).join(' ');
    }, "various shades of green return `1170, 146, 1042, 18, 1154, 130, 1026, 2, 1168, 144, 1040, 16, 1152, 128, 1024, 0`", "1170 146 1042 18 1154 130 1026 2 1168 144 1040 16 1152 128 1024 0", function() {
      var color;
      return ((function() {
        var j, len, ref, results;
        ref = [[0, 240, 0, 255], [0, 224, 0, 255], [0, 208, 0, 255], [0, 192, 0, 255], [0, 176, 0, 255], [0, 160, 0, 255], [0, 144, 0, 255], [0, 128, 0, 255], [0, 112, 0, 255], [0, 96, 0, 255], [0, 80, 0, 255], [0, 64, 0, 255], [0, 48, 0, 255], [0, 32, 0, 255], [0, 16, 0, 255], [0, 0, 0, 255]];
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          color = ref[j];
          results.push(pick.colorToIndex(color));
        }
        return results;
      })()).join(' ');
    }, "various shades of blue return `2340, 292, 2084, 36, 2308, 260, 2052, 4, 2336, 288, 2080, 32, 2304, 256, 2048, 0`", "2340 292 2084 36 2308 260 2052 4 2336 288 2080 32 2304 256 2048 0", function() {
      var color;
      return ((function() {
        var j, len, ref, results;
        ref = [[0, 0, 240, 255], [0, 0, 224, 255], [0, 0, 208, 255], [0, 0, 192, 255], [0, 0, 176, 255], [0, 0, 160, 255], [0, 0, 144, 255], [0, 0, 128, 255], [0, 0, 112, 255], [0, 0, 96, 255], [0, 0, 80, 255], [0, 0, 64, 255], [0, 0, 48, 255], [0, 0, 32, 255], [0, 0, 16, 255], [0, 0, 0, 255]];
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          color = ref[j];
          results.push(pick.colorToIndex(color));
        }
        return results;
      })()).join(' ');
    }
  ]);

}).call(this);
