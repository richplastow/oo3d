// Generated by CoffeeScript 1.9.2

/*! Oo3d 0.0.3 //// MIT Licence //// http://oo3d.richplastow.com/ */

(function() {
  var Main, getFragmentSource, getVertexSource, ª, ªA, ªB, ªC, ªE, ªF, ªN, ªO, ªR, ªS, ªU, ªV, ªW, ªX, ªex, ªhas, ªredefine, ªtype, ªuid;

  ªC = 'Oo3d';

  ªV = '0.0.3';

  ªA = 'array';

  ªB = 'boolean';

  ªE = 'error';

  ªF = 'function';

  ªN = 'number';

  ªO = 'object';

  ªR = 'regexp';

  ªS = 'string';

  ªU = 'undefined';

  ªX = 'null';

  ªW = this;

  ª = console.log.bind(console);

  ªex = function(x, a, b) {
    var pos;
    if (-1 === (pos = a.indexOf(x))) {
      return x;
    } else {
      return b.charAt(pos);
    }
  };

  ªhas = function(h, n, t, f) {
    if (t == null) {
      t = true;
    }
    if (f == null) {
      f = false;
    }
    if (-1 !== h.indexOf(n)) {
      return t;
    } else {
      return f;
    }
  };

  ªtype = function(x) {
    return {}.toString.call(x).match(/\s([a-z|A-Z]+)/)[1].toLowerCase();
  };

  ªuid = function(p) {
    return p + '_' + (Math.random() + '1111111111111111').slice(2, 18);
  };

  ªredefine = function(obj, name, value, kind) {
    switch (kind) {
      case 'constant':
        return Object.defineProperty(obj, name, {
          value: value,
          enumerable: true
        });
      case 'private':
        return Object.defineProperty(obj, name, {
          value: value,
          enumerable: false
        });
    }
  };

  Main = (function() {
    Main.prototype.C = ªC;

    Main.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function Main(config) {
      var k, v;
      if (config == null) {
        config = {};
      }
      for (k in config) {
        v = config[k];
        this[k] = v;
      }
      this.$main = config.$main || null;
      if (this.$main && ('htmlcanvaselement' !== ªtype(this.$main))) {
        throw Error("If set, config.$main must be HTMLCanvasElement not " + (ªtype(this.$main)));
      }
      this.gl = null;
      this.fragmentShader = null;
      this.vertexShader = null;
      this.vpAttribute = null;
      this.shaderProgram = null;
      this.buffer = null;
      if (this.$main) {
        this.initWebGL();
        if (this.gl) {
          this.initCanvas();
          this.initShaders();
          this.initShaderProgram();
          this.initBuffer();
        }
      }
    }

    Main.prototype.initWebGL = function() {
      try {
        this.gl = this.$main.getContext('webgl' || this.$main.getContext('experimental-webgl'));
      } catch (_error) {

      }
      if (!this.gl) {
        return alert("Unable to initialize WebGL. Your browser may not support it.");
      }
    };

    Main.prototype.initCanvas = function() {
      this.gl.clearColor(0.3984375, 0.40625, 0.703125, 1.0);
      this.gl.enable(this.gl.DEPTH_TEST);
      this.gl.depthFunc(this.gl.LEQUAL);
      return this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
    };

    Main.prototype.initShaders = function() {
      this.fragmentShader = this.gl.createShader(this.gl.FRAGMENT_SHADER);
      this.vertexShader = this.gl.createShader(this.gl.VERTEX_SHADER);
      this.gl.shaderSource(this.fragmentShader, getFragmentSource());
      this.gl.shaderSource(this.vertexShader, getVertexSource());
      this.gl.compileShader(this.fragmentShader);
      this.gl.compileShader(this.vertexShader);
      if (!this.gl.getShaderParameter(this.fragmentShader, this.gl.COMPILE_STATUS)) {
        throw Error("@fragmentShader did not compile successfully");
      }
      if (!this.gl.getShaderParameter(this.vertexShader, this.gl.COMPILE_STATUS)) {
        throw Error("@vertexShader did not compile successfully");
      }
    };

    Main.prototype.initShaderProgram = function() {
      this.shaderProgram = this.gl.createProgram();
      this.gl.attachShader(this.shaderProgram, this.fragmentShader);
      this.gl.attachShader(this.shaderProgram, this.vertexShader);
      this.gl.linkProgram(this.shaderProgram);
      if (!this.gl.getProgramParameter(this.shaderProgram, this.gl.LINK_STATUS)) {
        throw Error("@shaderProgram did not link successfully");
      }
      this.gl.useProgram(this.shaderProgram);
      this.vpAttribute = this.gl.getAttribLocation(this.shaderProgram, 'aVertexPosition');
      return this.gl.enableVertexAttribArray(this.vpAttribute);
    };

    Main.prototype.initBuffer = function() {
      var vertices;
      vertices = new Float32Array([0.0, 1.0, 0.0, -1.0, -1.0, 0.0, 0.0, -1.0, 0.0]);
      this.buffer = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
      return this.gl.bufferData(this.gl.ARRAY_BUFFER, vertices, this.gl.STATIC_DRAW);
    };

    Main.prototype.render = function() {
      this.gl.vertexAttribPointer(this.vpAttribute, 3, this.gl.FLOAT, false, 0, 0);
      return this.gl.drawArrays(this.gl.TRIANGLES, 0, 3);
    };

    return Main;

  })();

  getFragmentSource = function() {
    return "void main(void) {\n  gl_FragColor = vec4(0,1,0,0.7); // green\n}";
  };

  getVertexSource = function() {
    return "attribute vec2 aVertexPosition;\n\nvoid main() {\n  gl_Position = vec4(aVertexPosition, 0, 1);\n}";
  };

  if (ªF === typeof define && define.amd) {
    define(function() {
      return Main;
    });
  } else if (ªO === typeof module && module && module.exports) {
    module.exports = Main;
  } else {
    ªW[ªC] = Main;
  }

}).call(this);
