// Generated by CoffeeScript 1.9.2

/*! Oo3d 0.0.23 //// MIT Licence //// http://oo3d.richplastow.com/ */

(function() {
  var Camera, Layer, Main, Program, Renderer, Scene, Shader, Shape, mat4, ª, ªA, ªB, ªC, ªE, ªF, ªN, ªO, ªR, ªS, ªU, ªV, ªW, ªX, ªex, ªhas, ªisU, ªredefine, ªtype, ªuid,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ªC = 'Oo3d';

  ªV = '0.0.23';

  ªA = 'array';

  ªB = 'boolean';

  ªE = 'error';

  ªF = 'function';

  ªN = 'number';

  ªO = 'object';

  ªR = 'regexp';

  ªS = 'string';

  ªU = 'undefined';

  ªX = 'null';

  ªW = this;

  ª = console.log.bind(console);

  ªex = function(x, a, b) {
    var pos;
    if (-1 === (pos = a.indexOf(x))) {
      return x;
    } else {
      return b.charAt(pos);
    }
  };

  ªhas = function(h, n, t, f) {
    if (t == null) {
      t = true;
    }
    if (f == null) {
      f = false;
    }
    if (-1 !== h.indexOf(n)) {
      return t;
    } else {
      return f;
    }
  };

  ªtype = function(x) {
    return {}.toString.call(x).match(/\s([a-z0-9]+)/i)[1].toLowerCase();
  };

  ªisU = function(x) {
    return ªU === typeof x;
  };

  ªuid = function(p) {
    return p + '_' + (Math.random() + '1111111111111111').slice(2, 18);
  };

  ªredefine = function(obj, name, value, kind) {
    switch (kind) {
      case 'constant':
        return Object.defineProperty(obj, name, {
          value: value,
          enumerable: true
        });
      case 'private':
        return Object.defineProperty(obj, name, {
          value: value,
          enumerable: false
        });
    }
  };

  Camera = (function() {
    Camera.prototype.C = 'Camera';

    Camera.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function Camera(main1, config) {
      this.main = main1;
      if (config == null) {
        config = {};
      }
      if (ªO !== ªtype(config)) {
        throw TypeError("`config` must be object not " + (ªtype(config)));
      }
      if (ªO !== ªtype(this.main)) {
        throw TypeError("`main` must be object not " + (ªtype(this.main)));
      }
      if ('[object Oo3d]' !== '' + this.main) {
        throw TypeError("`main` must be [object Oo3d] not " + this.main);
      }
      this.fovy = config.fovy;
      if (!this.fovy) {
        this.fovy = 0.785398163;
      } else if ('number' !== ªtype(this.fovy)) {
        throw TypeError("If set, config.fovy must be number not " + (ªtype(this.fovy)));
      } else if (0 >= this.fovy) {
        throw RangeError("If set, config.fovy must be greater than 0 not " + this.fovy);
      }
      this.aspect = config.aspect;
      if (!this.aspect) {
        this.aspect = this.main.$main.width / this.main.$main.height;
      } else if ('number' !== ªtype(this.aspect)) {
        throw TypeError("If set, config.aspect must be number not " + (ªtype(this.aspect)));
      } else if (0 >= this.aspect) {
        throw RangeError("If set, config.aspect must be greater than 0 not " + this.aspect);
      }
      this.rX = 0;
      this.rY = 0;
      this.rZ = 0;
      this.sX = 1;
      this.sY = 1;
      this.sZ = 1;
      this.tX = 0;
      this.tY = 0;
      this.tZ = -4;
      this.matTransform = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, -4, 1]);
      this.matProjection = mat4.perspective(this.fovy, this.aspect, 1, 100);
      ª(this.fovy, this.aspect);
      this.matCamera = null;
      this.updateCamera();
    }

    Camera.prototype.updateCamera = function() {
      return this.matCamera = new Float32Array(mat4.multiply(this.matProjection, this.matTransform));
    };

    Camera.prototype.xx = function() {};

    return Camera;

  })();

  Layer = (function() {
    Layer.prototype.C = 'Layer';

    Layer.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function Layer(main1, config) {
      var float, i, j, len, ref;
      this.main = main1;
      if (config == null) {
        config = {};
      }
      if (ªO !== ªtype(config)) {
        throw TypeError("`config` must be object not " + (ªtype(config)));
      }
      if (ªO !== ªtype(this.main)) {
        throw TypeError("`main` must be object not " + (ªtype(this.main)));
      }
      if ('[object Oo3d]' !== '' + this.main) {
        throw TypeError("`main` must be [object Oo3d] not " + this.main);
      }
      if (!config.rendererIs) {
        this.renderers = [];
      } else if ('uint16array' !== ªtype(config.rendererIs)) {
        throw TypeError("If set, config.rendererIs must be Uint16Array not " + (ªtype(config.rendererIs)));
      } else {
        this.renderers = (function() {
          var j, len, ref, results;
          ref = config.rendererIs;
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            i = ref[j];
            results.push(this.main.renderers[i] || (function() {
              throw RangeError("No such index " + i + " in main.renderers");
            })());
          }
          return results;
        }).call(this);
      }
      this.scissor = config.scissor;
      if (!this.scissor) {
        this.scissor = null;
      } else if ('float32array' !== ªtype(this.scissor)) {
        throw TypeError("If set, config.scissor must be Float32Array not " + (ªtype(this.scissor)));
      } else if (4 !== this.scissor.length) {
        throw RangeError("If set, config.scissor.length must be 4 not " + this.scissor.length);
      } else {
        ref = this.scissor;
        for (j = 0, len = ref.length; j < len; j++) {
          float = ref[j];
          if (0 > float || 1 < float) {
            throw RangeError("config.scissor contains out-of-range " + float);
          }
        }
      }
    }

    Layer.prototype.render = function() {
      var j, len, ref, renderer, results;
      if (this.scissor) {
        this.main.gl.scissor(this.scissor[0] * this.main.$main.width, this.scissor[1] * this.main.$main.height, this.scissor[2] * this.main.$main.width, this.scissor[3] * this.main.$main.height);
      }
      ref = this.renderers;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        renderer = ref[j];
        results.push(renderer.render());
      }
      return results;
    };

    return Layer;

  })();

  Main = (function() {
    Main.prototype.C = ªC;

    Main.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function Main(config) {
      var k, v;
      if (config == null) {
        config = {};
      }
      for (k in config) {
        v = config[k];
        this[k] = v;
      }
      this.$main = config.$main || null;
      if (this.$main && ('htmlcanvaselement' !== ªtype(this.$main))) {
        throw Error("If set, config.$main must be HTMLCanvasElement not " + (ªtype(this.$main)));
      }
      this.gl = null;
      if (ªA === ªtype(config.background)) {
        this.bkgndR = config.background[0];
        this.bkgndG = config.background[1];
        this.bkgndB = config.background[2];
        this.bkgndA = config.background[3];
      } else {
        this.bkgndR = this.bkgndG = this.bkgndB = 0.25;
        this.bkgndA = 1;
      }
      this.cameras = [];
      this.programs = [];
      this.renderers = [];
      this.layers = [];
      this.items = [];
      this.positionBuffers = [];
      this.colorBuffers = [];
      if (this.$main) {
        this.initGL();
        if (this.gl) {
          this.initCanvas();
        }
      }
    }

    Main.prototype.initGL = function() {
      try {
        this.gl = this.$main.getContext('webgl' || this.$main.getContext('experimental-webgl'));
      } catch (_error) {

      }
      if (!this.gl) {
        throw Error("Unable to initialize WebGL. Your browser may not support it.");
      }
    };

    Main.prototype.initCanvas = function() {
      this.gl.clearColor(this.bkgndR, this.bkgndG, this.bkgndB, this.bkgndA);
      this.gl.enable(this.gl.DEPTH_TEST);
      this.gl.enable(this.gl.SCISSOR_TEST);
      this.gl.depthFunc(this.gl.LEQUAL);
      this.gl.scissor(0, 0, this.$main.width, this.$main.height);
      this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
      return this.gl.enable(this.gl.VERTEX_PROGRAM_POINT_SIZE);
    };

    Main.prototype.cleanUp = function() {};

    Main.prototype.addItem = function(config) {
      var index;
      index = this.items.length;
      this.items[index] = new Shape(config, this);
      return index;
    };

    Main.prototype.addCamera = function(config) {
      var index;
      index = this.cameras.length;
      this.cameras[index] = new Camera(this, config);
      ª(index);
      return index;
    };

    Main.prototype.addProgram = function(config) {
      var index;
      if (ªO !== ªtype(config)) {
        throw TypeError("`config` must be object not " + (ªtype(config)));
      }
      if (ªS !== ªtype(config.subclass)) {
        throw TypeError("`config.subclass` must be string not " + (ªtype(config.subclass)));
      }
      if (!Program[config.subclass]) {
        throw RangeError("`Program." + config.subclass + "` does not exist");
      }
      index = this.programs.length;
      this.programs[index] = new Program[config.subclass](this, config);
      return index;
    };

    Main.prototype.addRenderer = function(config) {
      var index;
      index = this.renderers.length;
      this.renderers[index] = new Renderer(this, config);
      return index;
    };

    Main.prototype.addLayer = function(config) {
      var index;
      index = this.layers.length;
      this.layers[index] = new Layer(this, config);
      return index;
    };

    Main.prototype.addPositionBuffer = function(positions) {
      var index;
      index = this.positionBuffers.length;
      if (ªA !== ªtype(positions)) {
        throw Error("`positions` must be an array not " + (ªtype(positions)));
      } else if (positions.length % 3) {
        throw Error("`positions.length` must be divisible by 3");
      }
      this.positionBuffers[index] = this.gl.createBuffer();
      this.positionBuffers[index].count = positions.length / 3;
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffers[index]);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(positions), this.gl.STATIC_DRAW);
      return index;
    };

    Main.prototype.addColorBuffer = function(colors) {
      var index;
      index = this.colorBuffers.length;
      if (ªA !== ªtype(colors)) {
        throw Error("`colors` must be an array not " + (ªtype(colors)));
      } else if (colors.length % 4) {
        throw Error("`colors.length` must be divisible by 4");
      }
      this.colorBuffers[index] = this.gl.createBuffer();
      this.colorBuffers[index].count = colors.length / 4;
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffers[index]);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(colors), this.gl.STATIC_DRAW);
      return index;
    };

    Main.prototype.rotate = function(x, y, z, targetIndex) {
      var c, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, mat, s, target, x0, y0, z0;
      target = this.items[targetIndex] || this.cameras[0];
      mat = target.matTransform;
      x0 = 0 === x;
      y0 = 0 === y;
      z0 = 0 === z;
      if (x0 && y0 && z0) {
        return this;
      } else if (y0 && z0) {
        s = Math.sin(x);
        c = Math.cos(x);
        m10 = mat[4];
        m11 = mat[5];
        m12 = mat[6];
        m13 = mat[7];
        m20 = mat[8];
        m21 = mat[9];
        m22 = mat[10];
        m23 = mat[11];
        mat[4] = m10 * c + m20 * s;
        mat[5] = m11 * c + m21 * s;
        mat[6] = m12 * c + m22 * s;
        mat[7] = m13 * c + m23 * s;
        mat[8] = m20 * c - m10 * s;
        mat[9] = m21 * c - m11 * s;
        mat[10] = m22 * c - m12 * s;
        mat[11] = m23 * c - m13 * s;
        target.rX += x;
      } else if (x0 && z0) {
        s = Math.sin(y);
        c = Math.cos(y);
        m00 = mat[0];
        m01 = mat[1];
        m02 = mat[2];
        m03 = mat[3];
        m20 = mat[8];
        m21 = mat[9];
        m22 = mat[10];
        m23 = mat[11];
        mat[0] = m00 * c - m20 * s;
        mat[1] = m01 * c - m21 * s;
        mat[2] = m02 * c - m22 * s;
        mat[3] = m03 * c - m23 * s;
        mat[8] = m00 * s + m20 * c;
        mat[9] = m01 * s + m21 * c;
        mat[10] = m02 * s + m22 * c;
        mat[11] = m03 * s + m23 * c;
        target.rY += y;
      } else if (x0 && y0) {
        s = Math.sin(z);
        c = Math.cos(z);
        m00 = mat[0];
        m01 = mat[1];
        m02 = mat[2];
        m03 = mat[3];
        m10 = mat[4];
        m11 = mat[5];
        m12 = mat[6];
        m13 = mat[7];
        mat[0] = m00 * c + m10 * s;
        mat[1] = m01 * c + m11 * s;
        mat[2] = m02 * c + m12 * s;
        mat[3] = m03 * c + m13 * s;
        mat[4] = m10 * c - m00 * s;
        mat[5] = m11 * c - m01 * s;
        mat[6] = m12 * c - m02 * s;
        mat[7] = m13 * c - m03 * s;
        target.rZ += z;
      } else {
        this.rotate(x, 0, 0, targetIndex);
        this.rotate(0, y, 0, targetIndex);
        this.rotate(0, 0, z, targetIndex);
      }
      if (target === this.cameras[0]) {
        this.cameras[0].updateCamera();
      }
      return this;
    };

    Main.prototype.scale = function(x, y, z, targetIndex) {
      var mat, target, x1, y1, z1;
      target = this.items[targetIndex] || this.cameras[0];
      mat = target.matTransform;
      x1 = 1 === x;
      y1 = 1 === y;
      z1 = 1 === z;
      if (!x1) {
        mat[0] *= x;
        mat[1] *= x;
        mat[2] *= x;
        mat[3] *= x;
        target.sX *= x;
      }
      if (!y1) {
        mat[4] *= y;
        mat[5] *= y;
        mat[6] *= y;
        mat[7] *= y;
        target.sY *= y;
      }
      if (!z1) {
        mat[8] *= z;
        mat[9] *= z;
        mat[10] *= z;
        mat[11] *= z;
        target.sZ *= z;
      }
      if (target === this.cameras[0]) {
        this.cameras[0].updateCamera();
      }
      return this;
    };

    Main.prototype.translate = function(x, y, z, targetIndex) {
      var mat, target, x0, y0, z0;
      target = this.items[targetIndex] || this.cameras[0];
      mat = target.matTransform;
      x0 = 0 === x;
      y0 = 0 === y;
      z0 = 0 === z;
      if (x0 && y0 && z0) {
        return this;
      } else if (y0 && z0) {
        mat[12] += mat[0] * x;
        mat[13] += mat[1] * x;
        mat[14] += mat[2] * x;
        mat[15] += mat[3] * x;
        target.tX += x;
      } else if (x0 && z0) {
        mat[12] += mat[4] * y;
        mat[13] += mat[5] * y;
        mat[14] += mat[6] * y;
        mat[15] += mat[7] * y;
        target.tY += y;
      } else if (x0 && y0) {
        mat[12] += mat[8] * z;
        mat[13] += mat[9] * z;
        mat[14] += mat[10] * z;
        mat[15] += mat[11] * z;
        target.tZ += z;
      } else {
        mat[12] += mat[0] * x + mat[4] * y + mat[8] * z;
        mat[13] += mat[1] * x + mat[5] * y + mat[9] * z;
        mat[14] += mat[2] * x + mat[6] * y + mat[10] * z;
        mat[15] += mat[3] * x + mat[7] * y + mat[11] * z;
        target.tX += x;
        target.tY += y;
        target.tZ += z;
      }
      if (target === this.cameras[0]) {
        this.cameras[0].updateCamera();
      }
      return this;
    };

    Main.prototype.setRenderMode = function(renderMode, targetIndex) {
      return this.items[targetIndex].renderMode = renderMode;
    };

    Main.prototype.render = function() {
      var j, layer, len, ref, results;
      if (!this.gl) {
        throw Error("The WebGL rendering context is " + (ªtype(this.gl)));
      }
      this.gl.clearColor(this.bkgndR, this.bkgndG, this.bkgndB, this.bkgndA);
      this.gl.scissor(0, 0, this.$main.width, this.$main.height);
      this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
      ref = this.layers;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        layer = ref[j];
        results.push(layer.render());
      }
      return results;
    };

    return Main;

  })();

  Scene = (function() {
    Scene.prototype.C = 'Scene';

    Scene.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function Scene(config, main) {
      var index;
      if (config == null) {
        config = {};
      }
      this.main = main;
      if ('object' !== ªtype(this.main || 'oo3d' !== '' + this.main)) {
        throw Error("`main` must be Oo3d not " + (ªtype(this.main)));
      }
      this.isActive = config.isActive;
      if (ªU === ªtype(this.isActive)) {
        this.isActive = true;
      } else if (ªB !== ªtype(this.isActive)) {
        throw Error("config.isActive must be boolean not " + (ªtype(this.isActive)));
      }
      this.left = config.left || 0;
      this.top = config.top || 0;
      this.width = config.width || 1;
      this.height = config.height || 1;
      this.shapes = (function() {
        var j, len, ref, results;
        ref = config.shapeIndices;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          index = ref[j];
          results.push(main.shapes[index]);
        }
        return results;
      })();
    }

    Scene.prototype.renderz = function() {
      var j, len, ref, renderer, results;
      ref = this.renderers;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        renderer = ref[j];
        results.push(renderer.render(this.main, this.shapes));
      }
      return results;
    };

    Scene.prototype.render = function() {
      var $main, aVtxColorLoc, aVtxPositionLoc, gl, index, main, mode, shape, uMatTransformLoc;
      main = this.main;
      $main = main.$main;
      gl = main.gl;
      aVtxPositionLoc = main.aVtxPositionLoc;
      aVtxColorLoc = main.aVtxColorLoc;
      uMatTransformLoc = main.uMatTransformLoc;
      if (!gl) {
        throw Error("The WebGL rendering context is " + (ªtype(gl)));
      }
      gl.scissor(this.left * $main.width, this.top * $main.height, this.width * $main.width, this.height * $main.height);
      index = this.shapes.length;
      while (index--) {
        shape = this.shapes[index];
        gl.bindBuffer(gl.ARRAY_BUFFER, shape.positionBuffer);
        gl.vertexAttribPointer(aVtxPositionLoc, 3, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, shape.colorBuffer);
        gl.vertexAttribPointer(aVtxColorLoc, 4, gl.FLOAT, false, 0, 0);
        gl.uniformMatrix4fv(uMatTransformLoc, false, shape.matTransform);
        if (null !== shape.sBlend) {
          gl.enable(gl.BLEND);
          gl.blendFunc(shape.sBlend, shape.dBlend);
        } else {
          gl.disable(gl.BLEND);
        }
        mode = gl[shape.renderMode];
        gl.drawArrays(mode, 0, shape.count);
        gl.flush();
      }
    };

    return Scene;

  })();

  Shader = (function() {
    Shader.prototype.C = 'Shader';

    Shader.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function Shader(config) {
      if (config == null) {
        config = {};
      }
    }

    return Shader;

  })();

  Shape = (function() {
    Shape.prototype.C = 'Shape';

    Shape.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function Shape(config, main) {
      if (config == null) {
        config = {};
      }
      this.gl = main.gl;
      if ('webglrenderingcontext' !== ªtype(this.gl)) {
        throw Error("main.gl must be WebGLRenderingContext not " + (ªtype(this.gl)));
      }
      this.positionBuffer = main.positionBuffers[config.positionIndex];
      if (!this.positionBuffer) {
        throw Error("config.positionIndex " + config.positionIndex + " does not exist");
      }
      this.colorBuffer = main.colorBuffers[config.colorIndex];
      if (!this.colorBuffer) {
        throw Error("config.colorIndex " + config.colorIndex + " does not exist");
      }
      if (this.positionBuffer.count !== this.colorBuffer.count) {
        ª(this.positionBuffer.count, '!=', this.colorBuffer.count);
        throw Error("config.positionIndex mismatches config.colorIndex");
      }
      this.count = this.positionBuffer.count;
      if (ªA === ªtype(config.blend)) {
        this.sBlend = this.gl[config.blend[0]];
        this.dBlend = this.gl[config.blend[1]];
      } else {
        this.sBlend = null;
        this.dBlend = null;
      }
      this.matTransform = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
      this.rX = 0;
      this.rY = 0;
      this.rZ = 0;
      this.sX = 1;
      this.sY = 1;
      this.sZ = 1;
      this.tX = 0;
      this.tY = 0;
      this.tZ = 0;
      this.renderMode = config.renderMode || 'TRIANGLES';
      if (ªN !== ªtype(this.gl[this.renderMode])) {
        throw Error("`renderMode` " + this.renderMode + " is not recognised by WebGL");
      }
    }

    Shape.prototype.xx = function() {};

    return Shape;

  })();

  if (ªF === typeof define && define.amd) {
    define(function() {
      return Main;
    });
  } else if (ªO === typeof module && module && module.exports) {
    module.exports = Main;
  } else {
    ªW[ªC] = Main;
  }

  mat4 = {};

  mat4.multiply = function(a, b) {
    var a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23, a30, a31, a32, a33, b0, b1, b2, b3, out;
    out = new Float32Array(16);
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    a30 = a[12];
    a31 = a[13];
    a32 = a[14];
    a33 = a[15];
    b0 = b[0];
    b1 = b[1];
    b2 = b[2];
    b3 = b[3];
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return out;
  };

  mat4.perspective = function(fovy, aspect, near, far) {
    var f, nf, out;
    f = 1.0 / Math.tan(fovy / 2);
    nf = 1 / (near - far);
    out = new Float32Array(16);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (2 * far * near) * nf;
    out[15] = 0;
    return out;
  };

  mat4.rotateX = function(a, rad) {
    var a10, a11, a12, a13, a20, a21, a22, a23, c, s;
    s = Math.sin(rad);
    c = Math.cos(rad);
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    a[4] = a10 * c + a20 * s;
    a[5] = a11 * c + a21 * s;
    a[6] = a12 * c + a22 * s;
    a[7] = a13 * c + a23 * s;
    a[8] = a20 * c - a10 * s;
    a[9] = a21 * c - a11 * s;
    a[10] = a22 * c - a12 * s;
    a[11] = a23 * c - a13 * s;
    return a;
  };

  mat4.rotateY = function(a, rad) {
    var a00, a01, a02, a03, a20, a21, a22, a23, c, s;
    s = Math.sin(rad);
    c = Math.cos(rad);
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    a[0] = a00 * c - a20 * s;
    a[1] = a01 * c - a21 * s;
    a[2] = a02 * c - a22 * s;
    a[3] = a03 * c - a23 * s;
    a[8] = a00 * s + a20 * c;
    a[9] = a01 * s + a21 * c;
    a[10] = a02 * s + a22 * c;
    a[11] = a03 * s + a23 * c;
    return a;
  };

  mat4.rotateZ = function(a, rad) {
    var a00, a01, a02, a03, a10, a11, a12, a13, c, s;
    s = Math.sin(rad);
    c = Math.cos(rad);
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a[0] = a00 * c + a10 * s;
    a[1] = a01 * c + a11 * s;
    a[2] = a02 * c + a12 * s;
    a[3] = a03 * c + a13 * s;
    a[4] = a10 * c - a00 * s;
    a[5] = a11 * c - a01 * s;
    a[6] = a12 * c - a02 * s;
    a[7] = a13 * c - a03 * s;
    return a;
  };

  mat4.translate = function(a, x, y, z) {
    a[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    a[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    a[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    a[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    return a;
  };

  mat4.ortho = function(left, right, bottom, top, near, far) {
    var bt, lr, nf, out;
    lr = 1 / (left - right);
    bt = 1 / (bottom - top);
    nf = 1 / (near - far);
    out = new Float32Array(16);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
  };

  mat4.makeTranslation = function(tx, ty, tz) {
    return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, tz, 1]);
  };

  mat4.makeXRotation = function(angleInRadians) {
    var c, s;
    c = Math.cos(angleInRadians);
    s = Math.sin(angleInRadians);
    return new Float32Array([1, 0, 0, 0, 0, c, s, 0, 0, -s, c, 0, 0, 0, 0, 1]);
  };

  mat4.makeYRotation = function(angleInRadians) {
    var c, s;
    c = Math.cos(angleInRadians);
    s = Math.sin(angleInRadians);
    return new Float32Array([c, 0, -s, 0, 0, 1, 0, 0, s, 0, c, 0, 0, 0, 0, 1]);
  };

  mat4.makeZRotation = function(angleInRadians) {
    var c, s;
    c = Math.cos(angleInRadians);
    s = Math.sin(angleInRadians);
    return new Float32Array([c, s, 0, 0, -s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
  };

  mat4.makeScale = function(sx, sy, sz) {
    return new Float32Array([sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1]);
  };

  mat4.makeProjection = function(width, height, depth) {
    return new Float32Array([2 / width, 0, 0, 0, 0, -2 / height, 0, 0, 0, 0, 2 / depth, 0, -1, 1, 0, 1]);
  };

  Program = (function() {
    Program.prototype.C = 'Program';

    Program.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function Program(main1, config) {
      var gl;
      this.main = main1;
      if (config == null) {
        config = {};
      }
      if (ªO !== ªtype(config)) {
        throw TypeError("`config` must be object not " + (ªtype(config)));
      }
      if (ªO !== ªtype(this.main)) {
        throw TypeError("`main` must be object not " + (ªtype(this.main)));
      }
      if ('[object Oo3d]' !== '' + this.main) {
        throw TypeError("`main` must be [object Oo3d] not " + this.main);
      }
      gl = this.main.gl;
      this.vertexShader = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(this.vertexShader, this.vertexSource());
      gl.compileShader(this.vertexShader);
      if (!gl.getShaderParameter(this.vertexShader, gl.COMPILE_STATUS)) {
        this.cleanUp();
        throw Error("vertexShader did not compile successfully");
      }
      this.fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(this.fragmentShader, this.fragmentSource());
      gl.compileShader(this.fragmentShader);
      if (!gl.getShaderParameter(this.fragmentShader, gl.COMPILE_STATUS)) {
        this.cleanUp();
        throw Error("fragmentShader did not compile successfully");
      }
      this.program = gl.createProgram();
      gl.attachShader(this.program, this.vertexShader);
      gl.attachShader(this.program, this.fragmentShader);
      gl.linkProgram(this.program);
      if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
        this.cleanUp();
        throw Error("program did not link successfully");
      }
    }

    Program.prototype.cleanUp = function() {
      if (this.vertexShader) {
        this.main.gl.deleteShader(this.vertexShader);
      }
      if (this.fragmentShader) {
        this.main.gl.deleteShader(this.fragmentShader);
      }
      if (this.program) {
        return this.main.gl.deleteProgram(this.program);
      }
    };

    Program.prototype.vertexSource = function() {
      return "void main() {\n}";
    };

    Program.prototype.fragmentSource = function() {
      return "void main() {\n}";
    };

    return Program;

  })();

  Program.Flat = (function(superClass) {
    extend(Flat, superClass);

    Flat.prototype.C = 'Program.Flat';

    Flat.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function Flat(main, config) {
      var gl;
      if (config == null) {
        config = {};
      }
      Flat.__super__.constructor.call(this, main, config);
      gl = this.main.gl;
      gl.useProgram(this.program);
      this.aVtxPositionLoc = gl.getAttribLocation(this.program, 'aVtxPosition');
      gl.enableVertexAttribArray(this.aVtxPositionLoc);
      this.aVtxColorLoc = gl.getAttribLocation(this.program, 'aVtxColor');
      this.uMatTransformLoc = gl.getUniformLocation(this.program, 'uMatTransform');
      this.uMatCameraLoc = gl.getUniformLocation(this.program, 'uMatCamera');
    }

    Flat.prototype.vertexSource = function() {
      return "attribute vec3 aVtxPosition;\nattribute vec4 aVtxColor;\n\nuniform mat4 uMatTransform;\nuniform mat4 uMatCamera;\n\nvarying vec4 vColor; // declare `vColor`\n\nvoid main() {\n\n  // \n  gl_PointSize = 4.0;\n\n  //// Multiply the position by the camera transformation and matrices. \n  //// Note that the order of these three is important. \n  gl_Position = uMatCamera * uMatTransform * vec4(aVtxPosition, 1);\n\n  // Convert from clipspace to colorspace, and send to the fragment-shader\n  // Clipspace goes -1.0 to +1.0\n  // Colorspace goes from 0.0 to 1.0\n  // vColor = gl_Position * 0.5 + 0.5; //vec4(4,4,4,4);\n\n  //// Pass the vertex-color attribute unchanged to the fragment-shader. \n  vColor = aVtxColor;\n}";
    };

    Flat.prototype.fragmentSource = function() {
      return "precision mediump float; // boilerplate for mobile-friendly shaders\nvarying vec4 vColor;     // linear-interpolated input from fragment-shader\n\nvoid main(void) {\n  gl_FragColor = vColor;\n}";
    };

    return Flat;

  })(Program);

  Program.Flatwhite = (function(superClass) {
    extend(Flatwhite, superClass);

    Flatwhite.prototype.C = 'Program.Flatwhite';

    Flatwhite.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function Flatwhite(main, config) {
      var gl;
      if (config == null) {
        config = {};
      }
      Flatwhite.__super__.constructor.call(this, main, config);
      gl = this.main.gl;
      gl.useProgram(this.program);
      this.aVtxPositionLoc = gl.getAttribLocation(this.program, 'aVtxPosition');
      gl.enableVertexAttribArray(this.aVtxPositionLoc);
      this.uMatTransformLoc = gl.getUniformLocation(this.program, 'uMatTransform');
      this.uMatCameraLoc = gl.getUniformLocation(this.program, 'uMatCamera');
    }

    Flatwhite.prototype.vertexSource = function() {
      return "attribute vec3 aVtxPosition;\n\nuniform mat4 uMatTransform;\nuniform mat4 uMatCamera;\n\nvoid main() {\n\n  //// Multiply the position by the camera transformation and matrices. \n  //// Note that the order of these three is important. \n  gl_Position = uMatCamera * uMatTransform * vec4(aVtxPosition, 1);\n\n}";
    };

    Flatwhite.prototype.fragmentSource = function() {
      return "precision mediump float; // boilerplate for mobile-friendly shaders\n\nvec4 white = vec4(1.0,1.0,1.0,1.0);\n\nvoid main() {\n  gl_FragColor = white;\n}";
    };

    return Flatwhite;

  })(Program);

  Renderer = (function() {
    var RendererTypeError;

    Renderer.prototype.C = 'Renderer';

    Renderer.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function Renderer(main1, config) {
      var i;
      this.main = main1;
      if (config == null) {
        config = {};
      }
      if (ªO !== ªtype(config)) {
        throw TypeError("`config` must be object not " + (ªtype(config)));
      }
      if (ªO !== ªtype(this.main)) {
        throw TypeError("`main` must be object not " + (ªtype(this.main)));
      }
      if ('[object Oo3d]' !== '' + this.main) {
        throw TypeError("`main` must be [object Oo3d] not " + this.main);
      }
      if (ªN !== ªtype(config.programI)) {
        throw TypeError("config.programI must be number not " + (ªtype(config.programI)));
      }
      this.program = this.main.programs[config.programI] || (function() {
        throw RangeError("No such index " + config.programI + " in main.programs");
      })();
      if (ªN !== ªtype(config.cameraI)) {
        throw TypeError("config.cameraI must be number not " + (ªtype(config.cameraI)));
      }
      this.camera = this.main.cameras[config.cameraI] || (function() {
        throw RangeError("No such index " + config.cameraI + " in main.cameras");
      })();
      this.uMatCameraLoc = this.main.gl.getUniformLocation(this.program.program, 'uMatCamera');
      if (!config.itemIs) {
        this.items = [];
      } else if ('uint16array' !== ªtype(config.itemIs)) {
        throw TypeError("If set, config.itemIs must be Uint16Array not " + (ªtype(config.itemIs)));
      } else {
        this.items = (function() {
          var j, len, ref, results;
          ref = config.itemIs;
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            i = ref[j];
            results.push(this.main.items[i] || (function() {
              throw RangeError("No such index " + i + " in main.items");
            })());
          }
          return results;
        }).call(this);
      }
    }

    Renderer.prototype.render = function() {
      var $main, aVtxColorLoc, aVtxPositionLoc, gl, index, item, main, mode, uMatTransformLoc;
      main = this.main;
      $main = main.$main;
      gl = main.gl;
      aVtxPositionLoc = this.program.aVtxPositionLoc;
      aVtxColorLoc = this.program.aVtxColorLoc || false;
      uMatTransformLoc = this.program.uMatTransformLoc;
      if (!gl) {
        throw Error("The WebGL rendering context is " + (ªtype(gl)));
      }
      gl.useProgram(this.program.program);
      gl.uniformMatrix4fv(this.uMatCameraLoc, false, this.camera.matCamera);
      if (aVtxColorLoc) {
        gl.enableVertexAttribArray(aVtxColorLoc);
      }
      index = this.items.length;
      while (index--) {
        item = this.items[index];
        gl.uniformMatrix4fv(uMatTransformLoc, false, item.matTransform);
        gl.bindBuffer(gl.ARRAY_BUFFER, item.positionBuffer);
        gl.vertexAttribPointer(aVtxPositionLoc, 3, gl.FLOAT, false, 0, 0);
        if (aVtxColorLoc) {
          gl.bindBuffer(gl.ARRAY_BUFFER, item.colorBuffer);
          gl.vertexAttribPointer(aVtxColorLoc, 4, gl.FLOAT, false, 0, 0);
        }
        if (null !== item.sBlend) {
          gl.enable(gl.BLEND);
          gl.blendFunc(item.sBlend, item.dBlend);
        } else {
          gl.disable(gl.BLEND);
        }
        mode = gl[item.renderMode];
        gl.drawArrays(mode, 0, item.count);
        gl.flush();
      }
      if (aVtxColorLoc) {
        return gl.disableVertexAttribArray(aVtxColorLoc);
      }
    };

    RendererTypeError = (function(superClass) {
      extend(RendererTypeError, superClass);

      function RendererTypeError(message) {
        this.message = "Renderer " + message;
        this.name = this.constructor.name;
      }

      RendererTypeError.prototype = new Error();

      RendererTypeError.prototype.constructor = RendererTypeError;

      return RendererTypeError;

    })(TypeError);

    return Renderer;

  })();

  Renderer.Wireframe = (function(superClass) {
    extend(Wireframe, superClass);

    Wireframe.prototype.C = 'Renderer.Wireframe';

    function Wireframe(main, config) {
      if (config == null) {
        config = {};
      }
      Wireframe.__super__.constructor.call(this, main, config);
    }

    return Wireframe;

  })(Renderer);

}).call(this);
