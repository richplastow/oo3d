// Generated by CoffeeScript 1.9.2

/*! Oo3d 0.0.49 //// MIT Licence //// http://oo3d.richplastow.com/ */

(function() {
  var Item, Layer, Main, Nwang, Program, Renderer, mat4, pick, uri, ª, ªA, ªB, ªC, ªE, ªF, ªMAX, ªMIN, ªN, ªO, ªR, ªS, ªU, ªV, ªW, ªX, ªex, ªhas, ªisU, ªredefine, ªtype, ªuid,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ªC = 'Oo3d';

  ªV = '0.0.49';

  ªA = 'array';

  ªB = 'boolean';

  ªE = 'error';

  ªF = 'function';

  ªN = 'number';

  ªO = 'object';

  ªR = 'regexp';

  ªS = 'string';

  ªU = 'undefined';

  ªX = 'null';

  ªMAX = 9007199254740991;

  ªMIN = -9007199254740991;

  ªW = this;

  ª = console.log.bind(console);

  ªex = function(x, a, b) {
    var pos;
    if (-1 === (pos = a.indexOf(x))) {
      return x;
    } else {
      return b.charAt(pos);
    }
  };

  ªhas = function(h, n, t, f) {
    if (t == null) {
      t = true;
    }
    if (f == null) {
      f = false;
    }
    if (-1 !== h.indexOf(n)) {
      return t;
    } else {
      return f;
    }
  };

  ªtype = function(x) {
    return {}.toString.call(x).match(/\s([a-z0-9]+)/i)[1].toLowerCase();
  };

  ªisU = function(x) {
    return ªU === typeof x;
  };

  ªuid = function(p) {
    return p + '_' + (Math.random() + '1111111111111111').slice(2, 18);
  };

  ªredefine = function(obj, name, value, kind) {
    switch (kind) {
      case 'constant':
        return Object.defineProperty(obj, name, {
          value: value,
          enumerable: true
        });
      case 'private':
        return Object.defineProperty(obj, name, {
          value: value,
          enumerable: false
        });
    }
  };

  Layer = (function() {
    Layer.prototype.C = 'Layer';

    Layer.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function Layer(main1, config) {
      var float, i, j, len, ref;
      this.main = main1;
      if (config == null) {
        config = {};
      }
      if (ªO !== ªtype(config)) {
        throw TypeError("`config` must be object not " + (ªtype(config)));
      }
      if (ªO !== ªtype(this.main)) {
        throw TypeError("`main` must be object not " + (ªtype(this.main)));
      }
      if ('[object Oo3d]' !== '' + this.main) {
        throw TypeError("`main` must be [object Oo3d] not " + this.main);
      }
      if (!config.rendererIs) {
        this.renderers = [];
      } else if ('uint16array' !== ªtype(config.rendererIs)) {
        throw TypeError("If set, config.rendererIs must be Uint16Array not " + (ªtype(config.rendererIs)));
      } else {
        this.renderers = (function() {
          var j, len, ref, results;
          ref = config.rendererIs;
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            i = ref[j];
            results.push(this.main.renderers[i] || (function() {
              throw RangeError("No such index " + i + " in main.renderers");
            })());
          }
          return results;
        }).call(this);
      }
      this.scissor = config.scissor;
      if (!this.scissor) {
        this.scissor = null;
      } else if ('float32array' !== ªtype(this.scissor)) {
        throw TypeError("If set, config.scissor must be Float32Array not " + (ªtype(this.scissor)));
      } else if (4 !== this.scissor.length) {
        throw RangeError("If set, config.scissor.length must be 4 not " + this.scissor.length);
      } else {
        ref = this.scissor;
        for (j = 0, len = ref.length; j < len; j++) {
          float = ref[j];
          if (0 > float || 1 < float) {
            throw RangeError("config.scissor contains out-of-range " + float);
          }
        }
      }
    }

    Layer.prototype.render = function() {
      var j, len, ref, renderer, results;
      if (this.scissor) {
        this.main.gl.scissor(this.scissor[0] * this.main.$main.width, this.scissor[1] * this.main.$main.height, this.scissor[2] * this.main.$main.width, this.scissor[3] * this.main.$main.height);
      }
      ref = this.renderers;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        renderer = ref[j];
        results.push(renderer.render());
      }
      return results;
    };

    return Layer;

  })();

  Main = (function() {
    Main.prototype.C = "/src/class-main.litcoffee:" + ªC;

    Main.prototype.toString = function() {
      return "[object " + ªC + "]";
    };

    function Main(config) {
      var M, k, v;
      if (config == null) {
        config = {};
      }
      M = this.C + ":constructor()\n  ";
      if (ªO !== ªtype(config)) {
        throw TypeError(M + "Optional `config` is " + (ªtype(config)) + " not object");
      }
      for (k in config) {
        v = config[k];
        this[k] = v;
      }
      if (!Nwang) {
        throw Error(M + "Dependency 'Nwang' could not be found");
      }
      this.nwang = new Nwang;
      this.$main = config.$main || null;
      if (this.$main && '[object HTMLCanvasElement]' !== '' + this.$main) {
        throw TypeError(M + "Optional `config.$main` is " + (ªtype(this.$main)) + " not HTMLCanvasElement");
      }
      if (!config.bkgnd) {
        this.bkgndR = this.bkgndG = this.bkgndB = 0.25;
        this.bkgndA = 1;
      } else if ('float32array' === ªtype(config.bkgnd)) {
        if (4 !== config.bkgnd.length) {
          throw Error(M + "If set `config.bkgnd` must contain four elements");
        }
        this.bkgndR = config.bkgnd[0] || 0;
        this.bkgndG = config.bkgnd[1] || 0;
        this.bkgndB = config.bkgnd[2] || 0;
        this.bkgndA = config.bkgnd[3] || 0;
        if (0 > this.bkgndR || this.bkgndR > 1) {
          throw RangeError(M + "`config.bkgnd[0]` (red) is not within range 0-1");
        }
        if (0 > this.bkgndG || this.bkgndG > 1) {
          throw RangeError(M + "`config.bkgnd[1]` (green) is not within range 0-1");
        }
        if (0 > this.bkgndB || this.bkgndB > 1) {
          throw RangeError(M + "`config.bkgnd[2]` (blue) is not within range 0-1");
        }
        if (0 > this.bkgndA || this.bkgndA > 1) {
          throw RangeError(M + "`config.bkgnd[3]` (alpha) is not within range 0-1");
        }
      } else {
        throw TypeError(M + "Optional `config.bkgnd` is " + (ªtype(config.bkgnd)) + " not float32array");
      }
      this.gl = null;
      this.cameras = [];
      this.programs = [];
      this.renderers = [];
      this.layers = [];
      this.meshes = [];
      this.positionBuffers = [];
      this.colorBuffers = [];
      if (this.$main) {
        this.initGL();
        if (this.gl) {
          this.initCanvas();
          this.initBuffers();
        }
      }
    }

    Main.prototype.initGL = function() {
      var M, ctx, j, len, ref;
      M = this.C + ":initGL()\n  ";
      try {
        ref = ['webgl', 'experimental-webgl'];
        for (j = 0, len = ref.length; j < len; j++) {
          ctx = ref[j];
          this.gl = this.$main.getContext(ctx, {
            preserveDrawingBuffer: true
          });
          if (this.gl) {
            break;
          }
        }
      } catch (_error) {

      }
      if (!this.gl) {
        throw Error(M + "Unable to initialize WebGL. Your browser may not support it.");
      }
    };

    Main.prototype.initCanvas = function() {
      this.gl.clearColor(this.bkgndR, this.bkgndG, this.bkgndB, this.bkgndA);
      this.gl.enable(this.gl.DEPTH_TEST);
      this.gl.enable(this.gl.SCISSOR_TEST);
      this.gl.depthFunc(this.gl.LEQUAL);
      this.gl.scissor(0, 0, this.$main.width, this.$main.height);
      this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
      return this.gl.enable(this.gl.VERTEX_PROGRAM_POINT_SIZE);
    };

    Main.prototype.initBuffers = function() {
      this.addPositionBuffer([]);
      return this.addColorBuffer([]);
    };

    Main.prototype.cleanUp = function() {};

    Main.prototype.addMesh = function(config) {
      var index;
      index = this.meshes.length;
      this.meshes[index] = new Item.Mesh(this, index, config);
      return index;
    };

    Main.prototype.addCamera = function(config) {
      var index;
      index = this.cameras.length;
      this.cameras[index] = new Item.Camera(this, index, config);
      return index;
    };

    Main.prototype.addProgram = function(config) {
      var index;
      if (ªO !== ªtype(config)) {
        throw TypeError("`config` must be object not " + (ªtype(config)));
      }
      if (ªS !== ªtype(config.subclass)) {
        throw TypeError("`config.subclass` must be string not " + (ªtype(config.subclass)));
      }
      if (!Program[config.subclass]) {
        throw RangeError("`Program." + config.subclass + "` does not exist");
      }
      index = this.programs.length;
      this.programs[index] = new Program[config.subclass](this, config);
      return index;
    };

    Main.prototype.addRenderer = function(config) {
      var index;
      index = this.renderers.length;
      this.renderers[index] = new Renderer(this, config);
      return index;
    };

    Main.prototype.addLayer = function(config) {
      var index;
      index = this.layers.length;
      this.layers[index] = new Layer(this, config);
      return index;
    };

    Main.prototype.addPositionBuffer = function(positions) {
      var index;
      index = this.positionBuffers.length;
      if (ªA !== ªtype(positions)) {
        throw Error("`positions` must be an array not " + (ªtype(positions)));
      } else if (positions.length % 3) {
        throw Error("`positions.length` must be divisible by 3");
      }
      this.positionBuffers[index] = this.gl.createBuffer();
      this.positionBuffers[index].count = positions.length / 3;
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffers[index]);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(positions), this.gl.STATIC_DRAW);
      return index;
    };

    Main.prototype.addColorBuffer = function(colors) {
      var index;
      index = this.colorBuffers.length;
      if (ªA !== ªtype(colors)) {
        throw Error("`colors` must be an array not " + (ªtype(colors)));
      } else if (colors.length % 4) {
        throw Error("`colors.length` must be divisible by 4");
      }
      this.colorBuffers[index] = this.gl.createBuffer();
      this.colorBuffers[index].count = colors.length / 4;
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffers[index]);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(colors), this.gl.STATIC_DRAW);
      return index;
    };

    Main.prototype.rotate = function(x, y, z, targetIndex) {
      var c, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, mat, s, target, x0, y0, z0;
      target = this.meshes[targetIndex] || this.cameras[0];
      mat = target.mT;
      x0 = 0 === x;
      y0 = 0 === y;
      z0 = 0 === z;
      if (x0 && y0 && z0) {
        return this;
      } else if (y0 && z0) {
        s = Math.sin(x);
        c = Math.cos(x);
        m10 = mat[4];
        m11 = mat[5];
        m12 = mat[6];
        m13 = mat[7];
        m20 = mat[8];
        m21 = mat[9];
        m22 = mat[10];
        m23 = mat[11];
        mat[4] = m10 * c + m20 * s;
        mat[5] = m11 * c + m21 * s;
        mat[6] = m12 * c + m22 * s;
        mat[7] = m13 * c + m23 * s;
        mat[8] = m20 * c - m10 * s;
        mat[9] = m21 * c - m11 * s;
        mat[10] = m22 * c - m12 * s;
        mat[11] = m23 * c - m13 * s;
        target.rX += x;
      } else if (x0 && z0) {
        s = Math.sin(y);
        c = Math.cos(y);
        m00 = mat[0];
        m01 = mat[1];
        m02 = mat[2];
        m03 = mat[3];
        m20 = mat[8];
        m21 = mat[9];
        m22 = mat[10];
        m23 = mat[11];
        mat[0] = m00 * c - m20 * s;
        mat[1] = m01 * c - m21 * s;
        mat[2] = m02 * c - m22 * s;
        mat[3] = m03 * c - m23 * s;
        mat[8] = m00 * s + m20 * c;
        mat[9] = m01 * s + m21 * c;
        mat[10] = m02 * s + m22 * c;
        mat[11] = m03 * s + m23 * c;
        target.rY += y;
      } else if (x0 && y0) {
        s = Math.sin(z);
        c = Math.cos(z);
        m00 = mat[0];
        m01 = mat[1];
        m02 = mat[2];
        m03 = mat[3];
        m10 = mat[4];
        m11 = mat[5];
        m12 = mat[6];
        m13 = mat[7];
        mat[0] = m00 * c + m10 * s;
        mat[1] = m01 * c + m11 * s;
        mat[2] = m02 * c + m12 * s;
        mat[3] = m03 * c + m13 * s;
        mat[4] = m10 * c - m00 * s;
        mat[5] = m11 * c - m01 * s;
        mat[6] = m12 * c - m02 * s;
        mat[7] = m13 * c - m03 * s;
        target.rZ += z;
      } else {
        this.rotate(x, 0, 0, targetIndex);
        this.rotate(0, y, 0, targetIndex);
        this.rotate(0, 0, z, targetIndex);
      }
      if (target === this.cameras[0]) {
        this.cameras[0].updateCamera();
      }
      return this;
    };

    Main.prototype.scale = function(x, y, z, targetIndex) {
      var mat, target, x1, y1, z1;
      target = this.meshes[targetIndex] || this.cameras[0];
      mat = target.mT;
      x1 = 1 === x;
      y1 = 1 === y;
      z1 = 1 === z;
      if (!x1) {
        mat[0] *= x;
        mat[1] *= x;
        mat[2] *= x;
        mat[3] *= x;
        target.sX *= x;
      }
      if (!y1) {
        mat[4] *= y;
        mat[5] *= y;
        mat[6] *= y;
        mat[7] *= y;
        target.sY *= y;
      }
      if (!z1) {
        mat[8] *= z;
        mat[9] *= z;
        mat[10] *= z;
        mat[11] *= z;
        target.sZ *= z;
      }
      if (target === this.cameras[0]) {
        this.cameras[0].updateCamera();
      }
      return this;
    };

    Main.prototype.translate = function(x, y, z, targetIndex) {
      var mat, target, x0, y0, z0;
      target = this.meshes[targetIndex] || this.cameras[0];
      mat = target.mT;
      x0 = 0 === x;
      y0 = 0 === y;
      z0 = 0 === z;
      if (x0 && y0 && z0) {
        return this;
      } else if (y0 && z0) {
        mat[12] += mat[0] * x;
        mat[13] += mat[1] * x;
        mat[14] += mat[2] * x;
        mat[15] += mat[3] * x;
        target.tX += x;
      } else if (x0 && z0) {
        mat[12] += mat[4] * y;
        mat[13] += mat[5] * y;
        mat[14] += mat[6] * y;
        mat[15] += mat[7] * y;
        target.tY += y;
      } else if (x0 && y0) {
        mat[12] += mat[8] * z;
        mat[13] += mat[9] * z;
        mat[14] += mat[10] * z;
        mat[15] += mat[11] * z;
        target.tZ += z;
      } else {
        mat[12] += mat[0] * x + mat[4] * y + mat[8] * z;
        mat[13] += mat[1] * x + mat[5] * y + mat[9] * z;
        mat[14] += mat[2] * x + mat[6] * y + mat[10] * z;
        mat[15] += mat[3] * x + mat[7] * y + mat[11] * z;
        target.tX += x;
        target.tY += y;
        target.tZ += z;
      }
      if (target === this.cameras[0]) {
        this.cameras[0].updateCamera();
      }
      return this;
    };

    Main.prototype.resetTransform = function(targetIndex) {
      var mat, target;
      target = this.meshes[targetIndex] || this.cameras[0];
      mat = target.mT;
      target.rX = target.rY = target.rZ = 0;
      target.sX = target.sY = target.sZ = 1;
      target.tX = target.tY = target.tZ = 0;
      target.mT = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
      if (target === this.cameras[0]) {
        this.cameras[0].tZ = -4;
        this.cameras[0].mT[14] = -4;
        this.cameras[0].updateCamera();
      }
      return this;
    };

    Main.prototype.setRenderMode = function(renderMode, targetIndex) {
      if (!this.meshes[targetIndex]) {
        return;
      }
      this.meshes[targetIndex].renderMode = renderMode;
      return this;
    };

    Main.prototype.getColorAt = function(x, y) {
      var pixels;
      pixels = new Uint8Array(4);
      this.gl.readPixels(x, y, 1, 1, this.gl.RGBA, this.gl.UNSIGNED_BYTE, pixels);
      return pixels;
    };

    Main.prototype.getMeshIByColor = function(color) {
      return pick.colorToIndex(color);
    };

    Main.prototype.getCameraSnapshot = function(cameraI) {
      var camera, mat;
      camera = this.cameras[cameraI];
      mat = new Float32Array(16);
      mat.set(camera.mT);
      return {
        mat: mat,
        rX: camera.rX,
        rY: camera.rY,
        rZ: camera.rZ,
        sX: camera.sX,
        sY: camera.sY,
        sZ: camera.sZ,
        tX: camera.tX,
        tY: camera.tY,
        tZ: camera.tZ
      };
    };

    Main.prototype.getMeshSnapshot = function(meshI) {
      var item, mat;
      item = this.meshes[meshI];
      mat = new Float32Array(16);
      mat.set(item.mT);
      return {
        mat: mat,
        rX: item.rX,
        rY: item.rY,
        rZ: item.rZ,
        sX: item.sX,
        sY: item.sY,
        sZ: item.sZ,
        tX: item.tX,
        tY: item.tY,
        tZ: item.tZ
      };
    };

    Main.prototype.setCameraSnapshot = function(snapshot, cameraI) {
      var camera;
      camera = this.cameras[cameraI];
      camera.mT = new Float32Array(16);
      camera.mT.set(snapshot.mat);
      camera.rX = snapshot.rX;
      camera.rY = snapshot.rY;
      camera.rZ = snapshot.rZ;
      camera.sX = snapshot.sX;
      camera.sY = snapshot.sY;
      camera.sZ = snapshot.sZ;
      camera.tX = snapshot.tX;
      camera.tY = snapshot.tY;
      camera.tZ = snapshot.tZ;
      return this;
    };

    Main.prototype.setMeshSnapshot = function(snapshot, meshI) {
      var item;
      item = this.meshes[meshI];
      item.mT = new Float32Array(16);
      item.mT.set(snapshot.mat);
      item.rX = snapshot.rX;
      item.rY = snapshot.rY;
      item.rZ = snapshot.rZ;
      item.sX = snapshot.sX;
      item.sY = snapshot.sY;
      item.sZ = snapshot.sZ;
      item.tX = snapshot.tX;
      item.tY = snapshot.tY;
      item.tZ = snapshot.tZ;
      return this;
    };

    Main.prototype.render = function() {
      var j, layer, len, ref;
      if (!this.gl) {
        throw Error("The WebGL rendering context is " + (ªtype(this.gl)));
      }
      this.gl.clearColor(this.bkgndR, this.bkgndG, this.bkgndB, this.bkgndA);
      this.gl.scissor(0, 0, this.$main.width, this.$main.height);
      this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
      ref = this.layers;
      for (j = 0, len = ref.length; j < len; j++) {
        layer = ref[j];
        layer.render();
      }
      return this;
    };

    return Main;

  })();

  if (ªF === typeof define && define.amd) {
    define(function() {
      return Main;
    });
  } else if (ªO === typeof module && module && module.exports) {
    module.exports = Main;
  } else {
    ªW[ªC] = Main;
  }

  if (ªF === typeof define && define.amd) {

  } else if (ªO === typeof module && module && module.exports) {
    Nwang = require('nwang');
  } else {
    Nwang = window.Nwang;
  }

  mat4 = {};

  mat4.multiply = function(a, b) {
    var a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23, a30, a31, a32, a33, b0, b1, b2, b3, out;
    out = new Float32Array(16);
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    a30 = a[12];
    a31 = a[13];
    a32 = a[14];
    a33 = a[15];
    b0 = b[0];
    b1 = b[1];
    b2 = b[2];
    b3 = b[3];
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return out;
  };

  mat4.perspective = function(fovy, aspect, near, far) {
    var f, nf, out;
    f = 1.0 / Math.tan(fovy / 2);
    nf = 1 / (near - far);
    out = new Float32Array(16);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (2 * far * near) * nf;
    out[15] = 0;
    return out;
  };

  mat4.rotateX = function(a, rad) {
    var a10, a11, a12, a13, a20, a21, a22, a23, c, s;
    s = Math.sin(rad);
    c = Math.cos(rad);
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    a[4] = a10 * c + a20 * s;
    a[5] = a11 * c + a21 * s;
    a[6] = a12 * c + a22 * s;
    a[7] = a13 * c + a23 * s;
    a[8] = a20 * c - a10 * s;
    a[9] = a21 * c - a11 * s;
    a[10] = a22 * c - a12 * s;
    a[11] = a23 * c - a13 * s;
    return a;
  };

  mat4.rotateY = function(a, rad) {
    var a00, a01, a02, a03, a20, a21, a22, a23, c, s;
    s = Math.sin(rad);
    c = Math.cos(rad);
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    a[0] = a00 * c - a20 * s;
    a[1] = a01 * c - a21 * s;
    a[2] = a02 * c - a22 * s;
    a[3] = a03 * c - a23 * s;
    a[8] = a00 * s + a20 * c;
    a[9] = a01 * s + a21 * c;
    a[10] = a02 * s + a22 * c;
    a[11] = a03 * s + a23 * c;
    return a;
  };

  mat4.rotateZ = function(a, rad) {
    var a00, a01, a02, a03, a10, a11, a12, a13, c, s;
    s = Math.sin(rad);
    c = Math.cos(rad);
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a[0] = a00 * c + a10 * s;
    a[1] = a01 * c + a11 * s;
    a[2] = a02 * c + a12 * s;
    a[3] = a03 * c + a13 * s;
    a[4] = a10 * c - a00 * s;
    a[5] = a11 * c - a01 * s;
    a[6] = a12 * c - a02 * s;
    a[7] = a13 * c - a03 * s;
    return a;
  };

  mat4.translate = function(a, x, y, z) {
    a[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    a[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    a[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    a[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    return a;
  };

  mat4.ortho = function(left, right, bottom, top, near, far) {
    var bt, lr, nf, out;
    lr = 1 / (left - right);
    bt = 1 / (bottom - top);
    nf = 1 / (near - far);
    out = new Float32Array(16);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
  };

  mat4.makeTranslation = function(tx, ty, tz) {
    return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, tz, 1]);
  };

  mat4.makeXRotation = function(angleInRadians) {
    var c, s;
    c = Math.cos(angleInRadians);
    s = Math.sin(angleInRadians);
    return new Float32Array([1, 0, 0, 0, 0, c, s, 0, 0, -s, c, 0, 0, 0, 0, 1]);
  };

  mat4.makeYRotation = function(angleInRadians) {
    var c, s;
    c = Math.cos(angleInRadians);
    s = Math.sin(angleInRadians);
    return new Float32Array([c, 0, -s, 0, 0, 1, 0, 0, s, 0, c, 0, 0, 0, 0, 1]);
  };

  mat4.makeZRotation = function(angleInRadians) {
    var c, s;
    c = Math.cos(angleInRadians);
    s = Math.sin(angleInRadians);
    return new Float32Array([c, s, 0, 0, -s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
  };

  mat4.makeScale = function(sx, sy, sz) {
    return new Float32Array([sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1]);
  };

  mat4.makeProjection = function(width, height, depth) {
    return new Float32Array([2 / width, 0, 0, 0, 0, -2 / height, 0, 0, 0, 0, 2 / depth, 0, -1, 1, 0, 1]);
  };

  pick = {};

  pick.indexToColor = function(index) {
    var b, g, i, r;
    i = ('00000000000000000000000' + index.toString(2)).slice(-24).split('');
    r = "" + i[23] + i[20] + i[17] + i[14] + i[11] + i[8] + i[5] + i[2];
    g = "" + i[22] + i[19] + i[16] + i[13] + i[10] + i[7] + i[4] + i[1];
    b = "" + i[21] + i[18] + i[15] + i[12] + i[9] + i[6] + i[3] + i[0];
    return new Float32Array([parseInt(r, 2) / 255, parseInt(g, 2) / 255, parseInt(b, 2) / 255, 1.0]);
  };

  pick.colorToIndex = function(color) {
    var b, g, i, r;
    if (0 === (0x1f & color[0]) + (0x1f & color[1]) + (0x1f & color[2])) {
      return pick.qikColorToIndex(color);
    }
    r = ('0000000' + color[0].toString(2)).slice(-8).split('');
    g = ('0000000' + color[1].toString(2)).slice(-8).split('');
    b = ('0000000' + color[2].toString(2)).slice(-8).split('');
    i = ("" + b[7] + g[7] + r[7]) + ("" + b[6] + g[6] + r[6]) + ("" + b[5] + g[5] + r[5]) + ("" + b[4] + g[4] + r[4]) + ("" + b[3] + g[3] + r[3]) + ("" + b[2] + g[2] + r[2]) + ("" + b[1] + g[1] + r[1]) + ("" + b[0] + g[0] + r[0]);
    return parseInt(i, 2);
  };

  pick.qikColorToIndex = function(color) {
    var b, g, i, r;
    r = (color[0].toString(2)).split('');
    g = (color[1].toString(2)).split('');
    b = (color[2].toString(2)).split('');
    i = ("" + (b[2] || 0) + (g[2] || 0) + (r[2] || 0)) + ("" + (b[1] || 0) + (g[1] || 0) + (r[1] || 0)) + ("" + b[0] + g[0] + r[0]);
    return parseInt(i, 2);
  };

  uri = {};

  uri.r2Tenmin = function(r) {
    return Math.round(r * uri.RESOLUTION_R);
  };

  uri.tenmin2r = function(r) {
    return r / uri.RESOLUTION_R;
  };

  uri.r2uri = function(radians) {
    var PI2, c1, c1i, c2, c2i, tenmin;
    PI2 = Math.PI * 2;
    radians = radians % PI2;
    if (0 > radians) {
      radians += PI2;
    }
    tenmin = uri.r2Tenmin(radians);
    c1 = uri.USUAL_R2URI[tenmin];
    if (c1) {
      return c1;
    }
    c1i = tenmin % 36;
    c2i = (tenmin - c1i) / 36;
    c1 = "0123456789abcdefghijklmnopqrstuvwxyz"[c1i];
    c2 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWX"[c2i];
    return '' + c1 + c2;
  };

  uri.s2uri = function(s) {
    var c1, c2, c3, m, n, nM64, neg;
    if (0 > s) {
      neg = true;
      s = Math.abs(s);
    }
    if (0.0001 > s) {
      return 'A';
    }
    if (0.001 > s) {
      m = neg ? 'a' : 'p';
      n = s * 10000000;
    } else if (0.01 > s) {
      m = neg ? 'b' : 'o';
      n = s * 1000000;
    } else if (0.1 > s) {
      m = neg ? 'c' : 'n';
      n = s * 100000;
    } else if (1 > s) {
      m = neg ? 'd' : 'm';
      n = s * 10000;
    } else if (10 > s) {
      m = neg ? 'e' : 'l';
      n = s * 1000;
    } else if (100 > s) {
      m = neg ? 'f' : 'k';
      n = s * 100;
    } else if (1000 > s) {
      m = neg ? 'g' : 'j';
      n = s * 10;
    } else if (10000 > s) {
      m = neg ? 'h' : 'i';
      n = s;
    } else {
      return 'Z';
    }
    n = n / 4;
    n = Math.floor(n);
    c1 = uri.USUAL_S2URI[m + n];
    if (c1) {
      return c1;
    }
    nM64 = n % 64;
    c1 = m;
    c2 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-"[nM64];
    c3 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-"[(n - nM64) / 64];
    if (ªU === typeof c1 || ªU === typeof c2 || ªU === typeof c3) {
      ª('UNDEFINED RESULT s2uri(' + s + ')', n, nM64, (n - nM64) / 64, '' + c1 + c2 + c3);
    }
    return c1 + c2 + c3;
  };

  uri.t2uri = function(t) {
    var c1, c2, c3, m, n, nM64, neg;
    if (0 > t) {
      neg = true;
      t = Math.abs(t);
    }
    if (0.0001 > t) {
      return 'A';
    }
    if (0.001 > t) {
      m = neg ? 'a' : 'p';
      n = t * 10000000;
    } else if (0.01 > t) {
      m = neg ? 'b' : 'o';
      n = t * 1000000;
    } else if (0.1 > t) {
      m = neg ? 'c' : 'n';
      n = t * 100000;
    } else if (1 > t) {
      m = neg ? 'd' : 'm';
      n = t * 10000;
    } else if (10 > t) {
      m = neg ? 'e' : 'l';
      n = t * 1000;
    } else if (100 > t) {
      m = neg ? 'f' : 'k';
      n = t * 100;
    } else if (1000 > t) {
      m = neg ? 'g' : 'j';
      n = t * 10;
    } else if (10000 > t) {
      m = neg ? 'h' : 'i';
      n = t;
    } else {
      return 'Z';
    }
    n = n / 4;
    n = Math.floor(n);
    c1 = uri.USUAL_T2URI[m + n];
    if (c1) {
      return c1;
    }
    nM64 = n % 64;
    c1 = m;
    c2 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-"[nM64];
    c3 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-"[(n - nM64) / 64];
    if (ªU === typeof c1 || ªU === typeof c2 || ªU === typeof c3) {
      ª('UNDEFINED RESULT t2uri(' + t + ')', n, nM64, (n - nM64) / 64, '' + c1 + c2 + c3);
    }
    return c1 + c2 + c3;
  };

  uri.uri2r = function(str) {
    var c1, c2, usual;
    usual = uri.USUAL_URI2R[str];
    if (ªN === typeof usual) {
      return uri.tenmin2r(usual);
    }
    c1 = uri.B64DECODE[str[0]];
    c2 = uri.B64DECODE[str[1]];
    return uri.tenmin2r(c1 * 60 + c2);
  };

  uri.uri2s = function(str) {
    var c1, c2, c3, usual;
    usual = uri.USUAL_URI2S[str];
    if (ªN === typeof usual) {
      return usual;
    }
    c1 = uri.MULTIPLIER[str[0]];
    c2 = uri.B64DECODE[str[1]];
    c3 = uri.B64DECODE[str[2]];
    return c1 * (c2 + c3 * 64 * 4);
  };

  uri.uri2t = function(str) {
    var c1, c2, c3, usual;
    usual = uri.USUAL_URI2T[str];
    if (ªN === typeof usual) {
      return usual;
    }
    c1 = uri.MULTIPLIER[str[0]];
    c2 = uri.B64DECODE[str[1]];
    c3 = uri.B64DECODE[str[2]];
    return c1 * (c2 + c3 * 64 * 4);
  };

  uri.RESOLUTION_R = 1 / (Math.PI * 2 / 36 / 60);

  uri.USUAL_R2URI = (function() {
    var PI, out;
    PI = Math.PI;
    out = {};
    out[0] = 'A';
    out[uri.r2Tenmin(PI / 6.0)] = 'B';
    out[uri.r2Tenmin(PI / 4.0)] = 'C';
    out[uri.r2Tenmin(PI / 3.0)] = 'D';
    out[uri.r2Tenmin(PI * 0.5)] = 'E';
    out[uri.r2Tenmin(PI / 1.5)] = 'F';
    out[uri.r2Tenmin(PI * 0.75)] = 'G';
    out[uri.r2Tenmin(PI / 1.2)] = 'H';
    out[uri.r2Tenmin(PI)] = 'I';
    out[uri.r2Tenmin(PI / 6.0 + PI)] = 'J';
    out[uri.r2Tenmin(PI / 4.0 + PI)] = 'K';
    out[uri.r2Tenmin(PI / 3.0 + PI)] = 'L';
    out[uri.r2Tenmin(PI * 1.5)] = 'M';
    out[uri.r2Tenmin(PI / 1.5 + PI)] = 'N';
    out[uri.r2Tenmin(PI * 1.75)] = 'O';
    out[uri.r2Tenmin(PI / 1.2 + PI)] = 'P';
    out[uri.r2Tenmin(PI * 2.0)] = 'Q';
    return out;
  })();

  uri.USUAL_URI2R = (function() {
    var key, out, ref, val;
    out = {};
    ref = uri.USUAL_R2URI;
    for (key in ref) {
      val = ref[key];
      out[val] = +key;
    }
    return out;
  })();

  uri.USUAL_S2URI = {
    d1250: 'C',
    d2500: 'D',
    d5000: 'E',
    e1000: 'F',
    e2000: 'G',
    e4000: 'H',
    e8000: 'I',
    m1250: 'R',
    m2500: 'S',
    m5000: 'T',
    l1000: 'U',
    l2000: 'V',
    l4000: 'W',
    l8000: 'X'
  };

  uri.USUAL_URI2S = {
    A: 0,
    C: -0.125,
    D: -0.25,
    E: -0.5,
    F: -1,
    G: -2,
    H: -4,
    I: -8,
    R: 0.125,
    S: 0.25,
    T: 0.5,
    U: 1,
    V: 2,
    W: 4,
    X: 8,
    Z: 10000
  };

  uri.USUAL_T2URI = {
    d1250: 'C',
    d2500: 'D',
    d5000: 'E',
    e1000: 'F',
    e2000: 'G',
    e4000: 'H',
    e8000: 'I',
    m1250: 'R',
    m2500: 'S',
    m5000: 'T',
    l1000: 'U',
    l2000: 'V',
    l4000: 'W',
    l8000: 'X'
  };

  uri.USUAL_URI2T = {
    A: 0,
    C: -0.125,
    D: -0.25,
    E: -0.5,
    F: -1,
    G: -2,
    H: -4,
    I: -8,
    R: 0.125,
    S: 0.25,
    T: 0.5,
    U: 1,
    V: 2,
    W: 4,
    X: 8,
    Z: 10000
  };

  uri.MULTIPLIER = {
    a: -1 / 10000000,
    b: -1 / 1000000,
    c: -1 / 100000,
    d: -1 / 10000,
    e: -1 / 1000,
    f: -1 / 100,
    g: -1 / 10,
    h: -1,
    p: 1 / 10000000,
    o: 1 / 1000000,
    n: 1 / 100000,
    m: 1 / 10000,
    l: 1 / 1000,
    k: 1 / 100,
    j: 1 / 10,
    i: 1
  };

  uri.B64DECODE = (function() {
    var b64, i, j, out;
    out = {};
    b64 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-";
    for (i = j = 0; j <= 63; i = ++j) {
      out[b64[i]] = i;
    }
    return out;
  })();

  Item = (function() {
    Item.prototype.C = "/src/item/base-item.litcoffee:Item";

    Item.prototype.toString = function() {
      return "[object Item]";
    };

    function Item(main1, index1, config) {
      var M;
      this.main = main1;
      this.index = index1;
      if (config == null) {
        config = {};
      }
      M = "/src/item/base-item.litcoffee:Item:constructor()\n  ";
      if (ªO !== ªtype(config)) {
        throw TypeError(M + "Optional `config` is " + (ªtype(config)) + " not object");
      }
      if (ªO !== ªtype(this.main)) {
        throw TypeError(M + "`main` is " + (ªtype(this.main)) + " not object");
      }
      if ('[object Oo3d]' !== '' + this.main) {
        throw TypeError(M + "`main` is '" + this.main + "' not '[object Oo3d]'");
      }
      if (ªN !== ªtype(this.index)) {
        throw TypeError(M + "`index` is " + (ªtype(this.index)) + " not number");
      }
      if (ªMAX < this.index || this.index % 1 || 0 > this.index) {
        throw RangeError(M + "`index` is " + this.index + " not 0 or a positive integer below 2^53");
      }
      this.mT = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
      this.rX = 0;
      this.rY = 0;
      this.rZ = 0;
      this.sX = 1;
      this.sY = 1;
      this.sZ = 1;
      this.tX = 0;
      this.tY = 0;
      this.tZ = 0;
    }

    Item.prototype.dump = function(formatOrState) {
      var M, i, mT, mTClone, ref, ref1, sf3, type, values;
      M = "/src/item/base-item.litcoffee:Item:dump()\n  ";
      type = ªtype(formatOrState);
      if (ªU === type || 'object' === formatOrState) {
        mTClone = new Float32Array(16);
        mTClone.set(this.mT);
        return {
          index: this.index,
          mT: mTClone,
          rX: this.rX,
          rY: this.rY,
          rZ: this.rZ,
          sX: this.sX,
          sY: this.sY,
          sZ: this.sZ,
          tX: this.tX,
          tY: this.tY,
          tZ: this.tZ
        };
      } else if (ªS !== type) {
        throw TypeError(M + "Optional `formatOrState` is " + type + " not string|object");
      } else if ('log' === formatOrState) {
        mT = this.mT;
        return "i " + this.index + " mT " + mT[0] + " " + mT[1] + " " + mT[2] + " " + mT[3] + " " + mT[4] + " " + mT[5] + " " + mT[6] + " " + mT[7] + " " + mT[8] + " " + mT[9] + " " + mT[10] + " " + mT[11] + " " + mT[12] + " " + mT[13] + " " + mT[14] + " " + mT[15] + " r " + this.rX + " " + this.rY + " " + this.rZ + " s " + this.sX + " " + this.sY + " " + this.sZ + " t " + this.tX + " " + this.tY + " " + this.tZ;
      } else if ('nwang' === formatOrState) {
        mT = this.mT;
        sf3 = this.main.nwang.sf3;
        return [sf3(this.index), sf3(mT[0]), sf3(mT[1]), sf3(mT[2]), sf3(mT[3]), sf3(mT[4]), sf3(mT[5]), sf3(mT[6]), sf3(mT[7]), sf3(mT[8]), sf3(mT[9]), sf3(mT[10]), sf3(mT[11]), sf3(mT[12]), sf3(mT[13]), sf3(mT[14]), sf3(mT[15]), sf3(this.rX), sf3(this.rY), sf3(this.rZ), sf3(this.sX), sf3(this.sY), sf3(this.sZ), sf3(this.tX), sf3(this.tY), sf3(this.tZ)].join('');
      } else if ('i ' === formatOrState.slice(0, 2)) {
        values = formatOrState.split(' ');
        if (this.index !== +values[1]) {
          throw TypeError(M + "`index` must not be altered by 'log'");
        }
        this.mT = new Float32Array((function() {
          var j, len, ref, results;
          ref = [3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18];
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            i = ref[j];
            results.push(values[i]);
          }
          return results;
        })());
        ref = (function() {
          var j, len, ref, results;
          ref = [20, 21, 22, 24, 25, 26, 28, 29, 30];
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            i = ref[j];
            results.push(+values[i]);
          }
          return results;
        })(), this.rX = ref[0], this.rY = ref[1], this.rZ = ref[2], this.sX = ref[3], this.sY = ref[4], this.sZ = ref[5], this.tX = ref[6], this.tY = ref[7], this.tZ = ref[8];
        return this;
      } else if (0xAFE8 < formatOrState.charCodeAt(0)) {
        values = formatOrState.split('');
        sf3 = this.main.nwang.sf3;
        if (this.index !== +sf3(values[0])) {
          throw TypeError(M + "`index` must not be altered by 'nwang'");
        }
        this.mT = new Float32Array((function() {
          var j, results;
          results = [];
          for (i = j = 1; j <= 16; i = ++j) {
            results.push(+sf3(values[i]));
          }
          return results;
        })());
        return ref1 = (function() {
          var j, results;
          results = [];
          for (i = j = 17; j <= 25; i = ++j) {
            results.push(+sf3(values[i]));
          }
          return results;
        })(), this.rX = ref1[0], this.rY = ref1[1], this.rZ = ref1[2], this.sX = ref1[3], this.sY = ref1[4], this.sZ = ref1[5], this.tX = ref1[6], this.tY = ref1[7], this.tZ = ref1[8], ref1;
      } else {
        throw RangeError(M + "Optional `formatOrState` is not a valid string or object");
      }
    };

    Item.prototype.getSnapshot = function(format) {
      var M, m, mT, sf3;
      M = "/src/item/base-item.litcoffee:Item:getSnapshot()\n  ";
      if (ªU === typeof format || 'object' === format) {
        mT = new Float32Array(16);
        mT.set(this.mT);
        return {
          mT: mT,
          rX: this.rX,
          rY: this.rY,
          rZ: this.rZ,
          sX: this.sX,
          sY: this.sY,
          sZ: this.sZ,
          tX: this.tX,
          tY: this.tY,
          tZ: this.tZ
        };
      } else if ('log' === format) {
        m = this.mT;
        return "m:[" + m[0] + "," + m[1] + "," + m[2] + "," + m[3] + ", " + m[4] + "," + m[5] + "," + m[6] + "," + m[7] + ", " + m[8] + "," + m[9] + "," + m[10] + "," + m[11] + ", " + m[12] + "," + m[13] + "," + m[14] + "," + m[15] + "], rX:" + this.rX + ", rY:" + this.rY + ", rZ:" + this.rZ + ", sX:" + this.sX + ", sY:" + this.sY + ", sZ:" + this.sZ + ", tX:" + this.tX + ", tY:" + this.tY + ", tZ:" + this.tZ;
      } else if ('minimal' === format) {
        m = this.mT;
        return "m:[" + m[0] + "," + m[1] + "," + m[2] + "," + m[3] + ", " + m[4] + "," + m[5] + "," + m[6] + "," + m[7] + ", " + m[8] + "," + m[9] + "," + m[10] + "," + m[11] + ", " + m[12] + "," + m[13] + "," + m[14] + "," + m[15] + "], rX:" + this.rX + ", rY:" + this.rY + ", rZ:" + this.rZ + ", sX:" + this.sX + ", sY:" + this.sY + ", sZ:" + this.sZ + ", tX:" + this.tX + ", tY:" + this.tY + ", tZ:" + this.tZ;
      } else if ('nwang' === format) {
        sf3 = this.main.nwang.sf3;
        return [sf3(this.rX), sf3(this.rY), sf3(this.rZ), sf3(this.sX), sf3(this.sY), sf3(this.sZ), sf3(this.tX), sf3(this.tY), sf3(this.tZ)].join('');
      } else if (ªS !== ªtype(format)) {
        throw TypeError(M + "Optional `format` is " + (ªtype(format)) + " not string");
      } else {
        throw RangeError(M + "Optional `format` is not 'object|log|nwang'");
      }
    };

    Item.prototype.setSnapshot = function(snapshot) {
      var M, captureFn, captureFns, captureI, captureKey, captureKeys, captureLength, captureLengths, ch, chI, format, l, m, match, matches, nwang, ref;
      M = "/src/item/base-item.litcoffee:Item:setSnapshot()\n  ";
      format = ªtype(snapshot);
      if (ªS === format) {
        format = 'm:[' === snapshot.slice(0, 3) ? 'log' : 'nwang';
      }
      if ('log' === format) {
        matches = snapshot.match(/^m:\[([-+.\d,\s]+)\],\s*rX:([-+]?\d*\.?\d*),\s*rY:([-+]?\d*\.?\d*),\s*rZ:([-+]?\d*\.?\d*),\s*sX:([-+]?\d*\.?\d*),\s*sY:([-+]?\d*\.?\d*),\s*sZ:([-+]?\d*\.?\d*),\s*tX:([-+]?\d*\.?\d*),\s*tY:([-+]?\d*\.?\d*),\s*tZ:([-+]?\d*\.?\d*)$/);
        if (null === matches) {
          throw Error(M + "`snapshot`, which looks like 'log' format, is malformed");
        }
        ref = (function() {
          var j, len, results;
          results = [];
          for (j = 0, len = matches.length; j < len; j++) {
            match = matches[j];
            results.push(+match);
          }
          return results;
        })(), snapshot = ref[0], m = ref[1], this.rX = ref[2], this.rY = ref[3], this.rZ = ref[4], this.sX = ref[5], this.sY = ref[6], this.sZ = ref[7], this.tX = ref[8], this.tY = ref[9], this.tZ = ref[10];
        this.mat = new Float32Array(matches[1].split(','));
      } else if ('nwang' === format) {
        nwang = this.main.nwang;
        captureKeys = ['rX', 'rY', 'rZ', 'sX', 'sY', 'sZ', 'tX', 'tY', 'tZ'];
        captureLengths = [1, 1, 1, 1, 1, 1, 1, 1, 1];
        captureFns = [nwang.sf3, nwang.sf3, nwang.sf3, nwang.sf3, nwang.sf3, nwang.sf3, nwang.sf3, nwang.sf3, nwang.sf3];
        chI = 0;
        l = snapshot.length;
        captureI = 0;
        while (chI < l) {
          captureKey = captureKeys[captureI];
          captureLength = captureLengths[captureI];
          captureFn = captureFns[captureI];
          ch = snapshot[chI];
          chI++;
          this[captureKey] = captureFn(ch);
          captureI++;
        }
        this.mT = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
        this.main.rotate(this.rX, this.rY, this.rZ, this.index);
        this.main.scale(this.sX, this.sY, this.sZ, this.index);
        this.main.translate(this.tX, this.tY, this.tZ, this.index);
      }
      return this;
    };

    return Item;

  })();

  Item.Camera = (function(superClass) {
    extend(Camera, superClass);

    Camera.prototype.C = "/src/item/class-item-camera.litcoffee:Item.Camera";

    Camera.prototype.toString = function() {
      return "[object Item.Camera]";
    };

    function Camera(main, index, config) {
      var M;
      if (config == null) {
        config = {};
      }
      M = this.C + ":constructor()\n  ";
      Camera.__super__.constructor.call(this, main, index, config);
      this.fovy = config.fovy;
      if (ªU === ªtype(this.fovy)) {
        this.fovy = 0.785398163;
      } else if (ªN !== ªtype(this.fovy)) {
        throw TypeError(M + "Optional `config.fovy` is " + (ªtype(this.fovy)) + " not number");
      } else if (0 >= this.fovy) {
        throw RangeError(M + "Optional `config.fovy` is " + this.fovy + " not greater than zero");
      }
      this.aspect = config.aspect;
      if (ªU === ªtype(this.aspect)) {
        this.aspect = this.main.$main.width / this.main.$main.height;
      } else if (ªN !== ªtype(this.aspect)) {
        throw TypeError(M + "Optional `config.aspect` is " + (ªtype(this.aspect)) + " not number");
      } else if (0 >= this.aspect) {
        throw RangeError(M + "Optional `config.aspect` is " + this.aspect + " not greater than zero");
      }
      this.matProjection = mat4.perspective(this.fovy, this.aspect, 1, 100);
      this.matCamera = null;
      this.mT[14] = -4;
      this.tZ = -4;
      this.updateCamera();
    }

    Camera.prototype.updateCamera = function() {
      return this.matCamera = new Float32Array(mat4.multiply(this.matProjection, this.mT));
    };

    Camera.prototype.xx = function() {};

    return Camera;

  })(Item);

  Item.Mesh = (function(superClass) {
    extend(Mesh, superClass);

    Mesh.prototype.C = "/src/item/class-item-mesh.litcoffee:Item.Mesh";

    Mesh.prototype.toString = function() {
      return "[object Item.Mesh]";
    };

    function Mesh(main, index, config) {
      var M;
      if (config == null) {
        config = {};
      }
      M = this.C + ":constructor()\n  ";
      Mesh.__super__.constructor.call(this, main, index, config);
      Mesh.__super__.constructor.call(this, main, index, config);
      this.color = pick.indexToColor(this.index);
      this.positionBuffer = this.main.positionBuffers[config.positionI || 0];
      if (!this.positionBuffer) {
        throw Error(M + "`config.positionI` " + config.positionI + " does not exist");
      }
      this.colorBuffer = this.main.colorBuffers[config.colorI || 0];
      if (!this.colorBuffer) {
        throw Error(M + "`config.colorI` " + config.colorI + " does not exist");
      }
      if (this.positionBuffer.count !== this.colorBuffer.count) {
        throw Error(M + "`config.positionI` mismatches config.colorI");
      }
      this.count = this.positionBuffer.count;
      this.renderMode = config.renderMode || 'TRIANGLES';
      if (!Item.Mesh.validRenderMode[this.renderMode]) {
        throw Error(M + "`config.renderMode` " + this.renderMode + " is not recognised by WebGL");
      }
      if (!config.blend) {
        this.sBlend = null;
        this.dBlend = null;
      } else if (ªA !== ªtype(config.blend)) {
        throw Error(M + "If set, `config.blend` must be array not " + (ªtype(config.blend)));
      } else {
        if (!Item.Mesh.validBlend[config.blend[0]]) {
          throw Error(M + "`config.blend[0]` is not recognised by WebGL");
        }
        if (!Item.Mesh.validBlend[config.blend[1]]) {
          throw Error(M + "`config.blend[1]` is not recognised by WebGL");
        }
        this.sBlend = this.main.gl[config.blend[0]];
        this.dBlend = this.main.gl[config.blend[1]];
      }
    }

    Mesh.prototype.xx = function(xx) {};

    return Mesh;

  })(Item);

  Item.Mesh.validRenderMode = {
    'POINTS': 1,
    'LINES': 1,
    'LINE_STRIP': 1,
    'LINE_LOOP': 1,
    'TRIANGLES': 1,
    'TRIANGLE_STRIP': 1,
    'TRIANGLE_FAN': 1
  };

  Item.Mesh.validBlend = {
    'ZERO': 1,
    'ONE': 1,
    'SRC_COLOR': 1,
    'ONE_MINUS_SRC_COLOR': 1,
    'DST_COLOR': 1,
    'ONE_MINUS_DST_COLOR': 1,
    'SRC_ALPHA': 1,
    'ONE_MINUS_SRC_ALPHA': 1,
    'DST_ALPHA': 1,
    'ONE_MINUS_DST_ALPHA': 1,
    'SRC_ALPHA_SATURATE': 1
  };

  Program = (function() {
    Program.prototype.C = 'Program';

    Program.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function Program(main1, config) {
      var gl;
      this.main = main1;
      if (config == null) {
        config = {};
      }
      if (ªO !== ªtype(config)) {
        throw TypeError("`config` must be object not " + (ªtype(config)));
      }
      if (ªO !== ªtype(this.main)) {
        throw TypeError("`main` must be object not " + (ªtype(this.main)));
      }
      if ('[object Oo3d]' !== '' + this.main) {
        throw TypeError("`main` must be [object Oo3d] not " + this.main);
      }
      gl = this.main.gl;
      this.vertexShader = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(this.vertexShader, this.vertexSource());
      gl.compileShader(this.vertexShader);
      if (!gl.getShaderParameter(this.vertexShader, gl.COMPILE_STATUS)) {
        this.cleanUp();
        throw Error(this.C + ".vertexShader failed to compile");
      }
      this.fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(this.fragmentShader, this.fragmentSource());
      gl.compileShader(this.fragmentShader);
      if (!gl.getShaderParameter(this.fragmentShader, gl.COMPILE_STATUS)) {
        this.cleanUp();
        throw Error(this.C + ".fragmentShader failed to compile");
      }
      this.program = gl.createProgram();
      gl.attachShader(this.program, this.vertexShader);
      gl.attachShader(this.program, this.fragmentShader);
      gl.linkProgram(this.program);
      if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
        this.cleanUp();
        throw Error(this.C + ".program failed to link");
      }
    }

    Program.prototype.cleanUp = function() {
      if (this.vertexShader) {
        this.main.gl.deleteShader(this.vertexShader);
      }
      if (this.fragmentShader) {
        this.main.gl.deleteShader(this.fragmentShader);
      }
      if (this.program) {
        return this.main.gl.deleteProgram(this.program);
      }
    };

    Program.prototype.vertexSource = function() {
      return "void main() {\n}";
    };

    Program.prototype.fragmentSource = function() {
      return "void main() {\n}";
    };

    return Program;

  })();

  Program.Flat = (function(superClass) {
    extend(Flat, superClass);

    Flat.prototype.C = 'Program.Flat';

    Flat.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function Flat(main, config) {
      var gl;
      if (config == null) {
        config = {};
      }
      Flat.__super__.constructor.call(this, main, config);
      gl = this.main.gl;
      gl.useProgram(this.program);
      this.aVtxPositionLoc = gl.getAttribLocation(this.program, 'aVtxPosition');
      gl.enableVertexAttribArray(this.aVtxPositionLoc);
      this.aVtxColorLoc = gl.getAttribLocation(this.program, 'aVtxColor');
      this.uMatTransformLoc = gl.getUniformLocation(this.program, 'uMatTransform');
      this.uMatCameraLoc = gl.getUniformLocation(this.program, 'uMatCamera');
    }

    Flat.prototype.vertexSource = function() {
      return "attribute vec3 aVtxPosition;\nattribute vec4 aVtxColor;\n\nuniform mat4 uMatTransform;\nuniform mat4 uMatCamera;\n\nvarying vec4 vColor; // declare `vColor`\n\nvoid main() {\n\n  //// Increase the size of gl.POINT from 1px to 4px. \n  gl_PointSize = 4.0;\n\n  //// Apply the Camera and Mesh transforms to each vertex position. \n  //// Note that the order of these three is important. \n  gl_Position = uMatCamera * uMatTransform * vec4(aVtxPosition, 1);\n\n  //// Pass the vertex-color attribute unchanged to the fragment-shader. \n  vColor = aVtxColor;\n}";
    };

    Flat.prototype.fragmentSource = function() {
      return "precision mediump float; // boilerplate for mobile-friendly shaders\n\nvarying vec4 vColor; // linear-interpolated input from fragment-shader\n\nvoid main(void) {\n  gl_FragColor = vColor;\n}";
    };

    return Flat;

  })(Program);

  Program.FlatItem = (function(superClass) {
    extend(FlatItem, superClass);

    FlatItem.prototype.C = 'Program.FlatItem';

    FlatItem.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function FlatItem(main, config) {
      var gl;
      if (config == null) {
        config = {};
      }
      FlatItem.__super__.constructor.call(this, main, config);
      gl = this.main.gl;
      gl.useProgram(this.program);
      this.aVtxPositionLoc = gl.getAttribLocation(this.program, 'aVtxPosition');
      gl.enableVertexAttribArray(this.aVtxPositionLoc);
      this.uMatTransformLoc = gl.getUniformLocation(this.program, 'uMatTransform');
      this.uMatCameraLoc = gl.getUniformLocation(this.program, 'uMatCamera');
      this.uMeshColorLoc = gl.getUniformLocation(this.program, 'uMeshColor');
    }

    FlatItem.prototype.vertexSource = function() {
      return "attribute vec3 aVtxPosition;\n\nuniform mat4 uMatTransform;\nuniform mat4 uMatCamera;\n\nuniform vec4 uMeshColor; // the mesh renders as a single flat color\n\n\nvarying vec4 vColor; // declare `vColor`\n\nvoid main() {\n\n  //// Multiply the position by the camera transformation and matrices. \n  //// Note that the order of these three is important. \n  gl_Position = uMatCamera * uMatTransform * vec4(aVtxPosition, 1);\n\n  //// Pass the vertex-color attribute unchanged to the fragment-shader. \n  vColor = uMeshColor;\n\n}";
    };

    FlatItem.prototype.fragmentSource = function() {
      return "precision mediump float; // boilerplate for mobile-friendly shaders\n\nvarying vec4 vColor; // linear-interpolated input from fragment-shader\n\nvoid main() {\n  gl_FragColor = vColor;\n}";
    };

    return FlatItem;

  })(Program);

  Program.Flatwhite = (function(superClass) {
    extend(Flatwhite, superClass);

    Flatwhite.prototype.C = 'Program.Flatwhite';

    Flatwhite.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function Flatwhite(main, config) {
      var gl;
      if (config == null) {
        config = {};
      }
      Flatwhite.__super__.constructor.call(this, main, config);
      gl = this.main.gl;
      gl.useProgram(this.program);
      this.aVtxPositionLoc = gl.getAttribLocation(this.program, 'aVtxPosition');
      gl.enableVertexAttribArray(this.aVtxPositionLoc);
      this.uMatTransformLoc = gl.getUniformLocation(this.program, 'uMatTransform');
      this.uMatCameraLoc = gl.getUniformLocation(this.program, 'uMatCamera');
    }

    Flatwhite.prototype.vertexSource = function() {
      return "attribute vec3 aVtxPosition;\n\nuniform mat4 uMatTransform;\nuniform mat4 uMatCamera;\n\nvoid main() {\n\n  //// Multiply the position by the camera transformation and matrices. \n  //// Note that the order of these three is important. \n  gl_Position = uMatCamera * uMatTransform * vec4(aVtxPosition, 1);\n\n}";
    };

    Flatwhite.prototype.fragmentSource = function() {
      return "precision mediump float; // boilerplate for mobile-friendly shaders\n\nvec4 white = vec4(1.0,1.0,1.0,1.0);\n\nvoid main() {\n  gl_FragColor = white;\n}";
    };

    return Flatwhite;

  })(Program);

  Renderer = (function() {
    var RendererTypeError;

    Renderer.prototype.C = 'Renderer';

    Renderer.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function Renderer(main1, config) {
      var i;
      this.main = main1;
      if (config == null) {
        config = {};
      }
      if (ªO !== ªtype(config)) {
        throw TypeError("`config` must be object not " + (ªtype(config)));
      }
      if (ªO !== ªtype(this.main)) {
        throw TypeError("`main` must be object not " + (ªtype(this.main)));
      }
      if ('[object Oo3d]' !== '' + this.main) {
        throw TypeError("`main` must be [object Oo3d] not " + this.main);
      }
      if (ªN !== ªtype(config.programI)) {
        throw TypeError("config.programI must be number not " + (ªtype(config.programI)));
      }
      this.program = this.main.programs[config.programI] || (function() {
        throw RangeError("No such index " + config.programI + " in main.programs");
      })();
      if (ªN !== ªtype(config.cameraI)) {
        throw TypeError("config.cameraI must be number not " + (ªtype(config.cameraI)));
      }
      this.camera = this.main.cameras[config.cameraI] || (function() {
        throw RangeError("No such index " + config.cameraI + " in main.cameras");
      })();
      this.uMatCameraLoc = this.main.gl.getUniformLocation(this.program.program, 'uMatCamera');
      if (!config.meshIs) {
        this.meshes = [];
      } else if ('uint16array' !== ªtype(config.meshIs)) {
        throw TypeError("If set, config.meshIs must be Uint16Array not " + (ªtype(config.meshIs)));
      } else {
        this.meshes = (function() {
          var j, len, ref, results;
          ref = config.meshIs;
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            i = ref[j];
            results.push(this.main.meshes[i] || (function() {
              throw RangeError("No such index " + i + " in main.meshes");
            })());
          }
          return results;
        }).call(this);
      }
    }

    Renderer.prototype.render = function() {
      var $main, aVtxColorLoc, aVtxPositionLoc, gl, index, main, mesh, mode, uMatTransformLoc, uMeshColorLoc;
      main = this.main;
      $main = main.$main;
      gl = main.gl;
      aVtxPositionLoc = this.program.aVtxPositionLoc;
      aVtxColorLoc = this.program.aVtxColorLoc || false;
      uMatTransformLoc = this.program.uMatTransformLoc;
      uMeshColorLoc = this.program.uMeshColorLoc;
      if (!gl) {
        throw Error("The WebGL rendering context is " + (ªtype(gl)));
      }
      gl.useProgram(this.program.program);
      gl.uniformMatrix4fv(this.uMatCameraLoc, false, this.camera.matCamera);
      if (aVtxColorLoc) {
        gl.enableVertexAttribArray(aVtxColorLoc);
      }
      index = this.meshes.length;
      while (index--) {
        mesh = this.meshes[index];
        if (!mesh) {
          continue;
        }
        gl.uniformMatrix4fv(uMatTransformLoc, gl.FALSE, mesh.mT);
        if (uMeshColorLoc) {
          gl.uniform4fv(uMeshColorLoc, mesh.color);
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, mesh.positionBuffer);
        gl.vertexAttribPointer(aVtxPositionLoc, 3, gl.FLOAT, false, 0, 0);
        if (aVtxColorLoc) {
          gl.bindBuffer(gl.ARRAY_BUFFER, mesh.colorBuffer);
          gl.vertexAttribPointer(aVtxColorLoc, 4, gl.FLOAT, false, 0, 0);
        }
        if (null !== mesh.sBlend) {
          gl.enable(gl.BLEND);
          gl.blendFunc(mesh.sBlend, mesh.dBlend);
        } else {
          gl.disable(gl.BLEND);
        }
        mode = gl[mesh.renderMode];
        gl.drawArrays(mode, 0, mesh.count);
        gl.flush();
      }
      if (aVtxColorLoc) {
        return gl.disableVertexAttribArray(aVtxColorLoc);
      }
    };

    RendererTypeError = (function(superClass) {
      extend(RendererTypeError, superClass);

      function RendererTypeError(message) {
        this.message = "Renderer " + message;
        this.name = this.constructor.name;
      }

      RendererTypeError.prototype = new Error();

      RendererTypeError.prototype.constructor = RendererTypeError;

      return RendererTypeError;

    })(TypeError);

    return Renderer;

  })();

  Renderer.Wireframe = (function(superClass) {
    extend(Wireframe, superClass);

    Wireframe.prototype.C = 'Renderer.Wireframe';

    function Wireframe(main, config) {
      if (config == null) {
        config = {};
      }
      Wireframe.__super__.constructor.call(this, main, config);
    }

    return Wireframe;

  })(Renderer);

}).call(this);
