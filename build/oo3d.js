// Generated by CoffeeScript 1.9.2

/*! Oo3d 0.0.41 //// MIT Licence //// http://oo3d.richplastow.com/ */

(function() {
  var Camera, Item, Layer, Main, Program, Renderer, mat4, pick, uri, ª, ªA, ªB, ªC, ªE, ªF, ªN, ªO, ªR, ªS, ªU, ªV, ªW, ªX, ªex, ªhas, ªisU, ªredefine, ªtype, ªuid,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ªC = 'Oo3d';

  ªV = '0.0.41';

  ªA = 'array';

  ªB = 'boolean';

  ªE = 'error';

  ªF = 'function';

  ªN = 'number';

  ªO = 'object';

  ªR = 'regexp';

  ªS = 'string';

  ªU = 'undefined';

  ªX = 'null';

  ªW = this;

  ª = console.log.bind(console);

  ªex = function(x, a, b) {
    var pos;
    if (-1 === (pos = a.indexOf(x))) {
      return x;
    } else {
      return b.charAt(pos);
    }
  };

  ªhas = function(h, n, t, f) {
    if (t == null) {
      t = true;
    }
    if (f == null) {
      f = false;
    }
    if (-1 !== h.indexOf(n)) {
      return t;
    } else {
      return f;
    }
  };

  ªtype = function(x) {
    return {}.toString.call(x).match(/\s([a-z0-9]+)/i)[1].toLowerCase();
  };

  ªisU = function(x) {
    return ªU === typeof x;
  };

  ªuid = function(p) {
    return p + '_' + (Math.random() + '1111111111111111').slice(2, 18);
  };

  ªredefine = function(obj, name, value, kind) {
    switch (kind) {
      case 'constant':
        return Object.defineProperty(obj, name, {
          value: value,
          enumerable: true
        });
      case 'private':
        return Object.defineProperty(obj, name, {
          value: value,
          enumerable: false
        });
    }
  };

  Camera = (function() {
    Camera.prototype.C = 'Camera';

    Camera.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function Camera(main1, config) {
      this.main = main1;
      if (config == null) {
        config = {};
      }
      if (ªO !== ªtype(config)) {
        throw TypeError("`config` must be object not " + (ªtype(config)));
      }
      if (ªO !== ªtype(this.main)) {
        throw TypeError("`main` must be object not " + (ªtype(this.main)));
      }
      if ('[object Oo3d]' !== '' + this.main) {
        throw TypeError("`main` must be [object Oo3d] not " + this.main);
      }
      this.fovy = config.fovy;
      if (!this.fovy) {
        this.fovy = 0.785398163;
      } else if ('number' !== ªtype(this.fovy)) {
        throw TypeError("If set, config.fovy must be number not " + (ªtype(this.fovy)));
      } else if (0 >= this.fovy) {
        throw RangeError("If set, config.fovy must be greater than 0 not " + this.fovy);
      }
      this.aspect = config.aspect;
      if (!this.aspect) {
        this.aspect = this.main.$main.width / this.main.$main.height;
      } else if ('number' !== ªtype(this.aspect)) {
        throw TypeError("If set, config.aspect must be number not " + (ªtype(this.aspect)));
      } else if (0 >= this.aspect) {
        throw RangeError("If set, config.aspect must be greater than 0 not " + this.aspect);
      }
      this.rX = 0;
      this.rY = 0;
      this.rZ = 0;
      this.sX = 1;
      this.sY = 1;
      this.sZ = 1;
      this.tX = 0;
      this.tY = 0;
      this.tZ = -4;
      this.matTransform = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, -4, 1]);
      this.matProjection = mat4.perspective(this.fovy, this.aspect, 1, 100);
      ª(this.fovy, this.aspect);
      this.matCamera = null;
      this.updateCamera();
    }

    Camera.prototype.updateCamera = function() {
      return this.matCamera = new Float32Array(mat4.multiply(this.matProjection, this.matTransform));
    };

    Camera.prototype.xx = function() {};

    return Camera;

  })();

  Item = (function() {
    Item.prototype.C = "/src/class-item.litcoffee:Item";

    Item.prototype.toString = function() {
      return "[object Item]";
    };

    function Item(main1, index1, config) {
      var M;
      this.main = main1;
      this.index = index1;
      if (config == null) {
        config = {};
      }
      M = this.C + ":constructor()\n  ";
      if (ªO !== ªtype(config)) {
        throw TypeError(M + "`config` must be object not " + (ªtype(config)));
      }
      if (ªO !== ªtype(this.main)) {
        throw TypeError(M + "`main` must be object not " + (ªtype(this.main)));
      }
      if ('[object Oo3d]' !== '' + this.main) {
        throw TypeError(M + "`main` must be [object Oo3d] not " + this.main);
      }
      if (ªN !== ªtype(this.index)) {
        throw TypeError(M + "`index` must be number not " + (ªtype(this.index)));
      }
      this.color = pick.indexToColor(this.index);
      this.positionBuffer = this.main.positionBuffers[config.positionI || 0];
      if (!this.positionBuffer) {
        throw Error(M + "`config.positionI` " + config.positionI + " does not exist");
      }
      this.colorBuffer = this.main.colorBuffers[config.colorI || 0];
      if (!this.colorBuffer) {
        throw Error(M + "`config.colorI` " + config.colorI + " does not exist");
      }
      if (this.positionBuffer.count !== this.colorBuffer.count) {
        throw Error(M + "`config.positionI` mismatches config.colorI");
      }
      this.count = this.positionBuffer.count;
      this.renderMode = config.renderMode || 'TRIANGLES';
      if (!Item.validRenderMode[this.renderMode]) {
        throw Error(M + "`config.renderMode` " + this.renderMode + " is not recognised by WebGL");
      }
      if (!config.blend) {
        this.sBlend = null;
        this.dBlend = null;
      } else if (ªA !== ªtype(config.blend)) {
        throw Error(M + "If set, `config.blend` must be array not " + (ªtype(config.blend)));
      } else {
        if (!Item.validBlend[config.blend[0]]) {
          throw Error(M + "`config.blend[0]` is not recognised by WebGL");
        }
        if (!Item.validBlend[config.blend[1]]) {
          throw Error(M + "`config.blend[1]` is not recognised by WebGL");
        }
        this.sBlend = this.main.gl[config.blend[0]];
        this.dBlend = this.main.gl[config.blend[1]];
      }
      this.matTransform = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
      this.rX = 0;
      this.rY = 0;
      this.rZ = 0;
      this.sX = 1;
      this.sY = 1;
      this.sZ = 1;
      this.tX = 0;
      this.tY = 0;
      this.tZ = 0;
    }

    Item.prototype.getSnapshot = function(format) {
      var m, mat;
      if ('log' === format) {
        m = this.matTransform;
        return "m:[" + m[0] + "," + m[1] + "," + m[2] + "," + m[3] + ", " + m[4] + "," + m[5] + "," + m[6] + "," + m[7] + ", " + m[8] + "," + m[9] + "," + m[10] + "," + m[11] + ", " + m[12] + "," + m[13] + "," + m[14] + "," + m[15] + "], rX:" + this.rX + ", rY:" + this.rY + ", rZ:" + this.rZ + ", sX:" + this.sX + ", sY:" + this.sY + ", sZ:" + this.sZ + ", tX:" + this.tX + ", tY:" + this.tY + ", tZ:" + this.tZ;
      } else if ('uri' === format) {
        return [uri.r2uri(this.rX), uri.r2uri(this.rY), uri.r2uri(this.rZ), uri.s2uri(this.sX), uri.s2uri(this.sY), uri.s2uri(this.sZ), uri.t2uri(this.tX), uri.t2uri(this.tY), uri.t2uri(this.tZ)].join('');
      } else {
        mat = new Float32Array(16);
        mat.set(this.matTransform);
        return {
          mat: mat,
          rX: this.rX,
          rY: this.rY,
          rZ: this.rZ,
          sX: this.sX,
          sY: this.sY,
          sZ: this.sZ,
          tX: this.tX,
          tY: this.tY,
          tZ: this.tZ
        };
      }
    };

    Item.prototype.setSnapshot = function(snapshot) {
      var M, captureFn, captureFns, captureI, captureKey, captureKeys, captureLength, captureLengths, ch, chI, format, isUC, l, m, matches, results;
      M = this.C + ":setSnapshot()\n  ";
      format = ªtype(snapshot);
      if (ªS === format) {
        format = 'm:[' === snapshot.slice(0, 3) ? 'log' : 'uri';
      }
      if ('log' === format) {
        matches = snapshot.match(/^m:\[(.*)\],\s*rX:(-?[.\d]*),\s*rY:(-?[.\d]*),\s*rZ:(-?[.\d]*),\s*sX:(-?[.\d]*),\s*sY:(-?[.\d]*),\s*sZ:(-?[.\d]*),\s*tX:(-?[.\d]*),\s*tY:(-?[.\d]*),\s*tZ:(-?[.\d]*)$/);
        if (null === matches) {
          throw Error(M + "log-format snapshot is invalid");
        }
        snapshot = matches[0], m = matches[1], this.rX = matches[2], this.rY = matches[3], this.rZ = matches[4], this.sX = matches[5], this.sY = matches[6], this.sZ = matches[7], this.tX = matches[8], this.tY = matches[9], this.tZ = matches[10];
        return this.matTransform = new Float32Array(m.split(','));
      } else if ('uri' === format) {
        isUC = {
          A: 1,
          B: 1,
          C: 1,
          D: 1,
          E: 1,
          F: 1,
          G: 1,
          H: 1,
          I: 1,
          J: 1,
          K: 1,
          L: 1,
          M: 1,
          N: 1,
          O: 1,
          P: 1,
          Q: 1,
          R: 1,
          S: 1,
          T: 1,
          U: 1,
          V: 1,
          W: 1,
          X: 1,
          Y: 1,
          Z: 1
        };
        captureKeys = ['rX', 'rY', 'rZ', 'sX', 'sY', 'sZ', 'tX', 'tY', 'tZ'];
        captureLengths = [2, 2, 2, 3, 3, 3, 3, 3, 3];
        captureFns = [uri.uri2r, uri.uri2r, uri.uri2r, uri.uri2s, uri.uri2s, uri.uri2s, uri.uri2t, uri.uri2t, uri.uri2t];
        chI = 0;
        l = snapshot.length;
        captureI = 0;
        results = [];
        while (chI < l) {
          captureKey = captureKeys[captureI];
          captureLength = captureLengths[captureI];
          captureFn = captureFns[captureI];
          ch = snapshot[chI];
          if (isUC[ch]) {
            chI++;
            this[captureKey] = captureFn(ch);
          } else {
            this[captureKey] = captureFn(snapshot.substr(chI, captureLength));
            chI += captureLength;
          }
          results.push(captureI++);
        }
        return results;
      }
    };

    return Item;

  })();

  Item.validRenderMode = {
    'POINTS': 1,
    'LINES': 1,
    'LINE_STRIP': 1,
    'LINE_LOOP': 1,
    'TRIANGLES': 1,
    'TRIANGLE_STRIP': 1,
    'TRIANGLE_FAN': 1
  };

  Item.validBlend = {
    'ZERO': 1,
    'ONE': 1,
    'SRC_COLOR': 1,
    'ONE_MINUS_SRC_COLOR': 1,
    'DST_COLOR': 1,
    'ONE_MINUS_DST_COLOR': 1,
    'SRC_ALPHA': 1,
    'ONE_MINUS_SRC_ALPHA': 1,
    'DST_ALPHA': 1,
    'ONE_MINUS_DST_ALPHA': 1,
    'SRC_ALPHA_SATURATE': 1
  };

  Layer = (function() {
    Layer.prototype.C = 'Layer';

    Layer.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function Layer(main1, config) {
      var float, i, j, len, ref;
      this.main = main1;
      if (config == null) {
        config = {};
      }
      if (ªO !== ªtype(config)) {
        throw TypeError("`config` must be object not " + (ªtype(config)));
      }
      if (ªO !== ªtype(this.main)) {
        throw TypeError("`main` must be object not " + (ªtype(this.main)));
      }
      if ('[object Oo3d]' !== '' + this.main) {
        throw TypeError("`main` must be [object Oo3d] not " + this.main);
      }
      if (!config.rendererIs) {
        this.renderers = [];
      } else if ('uint16array' !== ªtype(config.rendererIs)) {
        throw TypeError("If set, config.rendererIs must be Uint16Array not " + (ªtype(config.rendererIs)));
      } else {
        this.renderers = (function() {
          var j, len, ref, results;
          ref = config.rendererIs;
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            i = ref[j];
            results.push(this.main.renderers[i] || (function() {
              throw RangeError("No such index " + i + " in main.renderers");
            })());
          }
          return results;
        }).call(this);
      }
      this.scissor = config.scissor;
      if (!this.scissor) {
        this.scissor = null;
      } else if ('float32array' !== ªtype(this.scissor)) {
        throw TypeError("If set, config.scissor must be Float32Array not " + (ªtype(this.scissor)));
      } else if (4 !== this.scissor.length) {
        throw RangeError("If set, config.scissor.length must be 4 not " + this.scissor.length);
      } else {
        ref = this.scissor;
        for (j = 0, len = ref.length; j < len; j++) {
          float = ref[j];
          if (0 > float || 1 < float) {
            throw RangeError("config.scissor contains out-of-range " + float);
          }
        }
      }
    }

    Layer.prototype.render = function() {
      var j, len, ref, renderer, results;
      if (this.scissor) {
        this.main.gl.scissor(this.scissor[0] * this.main.$main.width, this.scissor[1] * this.main.$main.height, this.scissor[2] * this.main.$main.width, this.scissor[3] * this.main.$main.height);
      }
      ref = this.renderers;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        renderer = ref[j];
        results.push(renderer.render());
      }
      return results;
    };

    return Layer;

  })();

  Main = (function() {
    Main.prototype.C = ªC;

    Main.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function Main(config) {
      var k, v;
      if (config == null) {
        config = {};
      }
      for (k in config) {
        v = config[k];
        this[k] = v;
      }
      this.$main = config.$main || null;
      if (this.$main && ('htmlcanvaselement' !== ªtype(this.$main))) {
        throw Error("If set, config.$main must be HTMLCanvasElement not " + (ªtype(this.$main)));
      }
      this.gl = null;
      if (ªA === ªtype(config.background)) {
        this.bkgndR = config.background[0];
        this.bkgndG = config.background[1];
        this.bkgndB = config.background[2];
        this.bkgndA = config.background[3];
      } else {
        this.bkgndR = this.bkgndG = this.bkgndB = 0.25;
        this.bkgndA = 1;
      }
      this.cameras = [];
      this.programs = [];
      this.renderers = [];
      this.layers = [];
      this.items = [];
      this.positionBuffers = [];
      this.colorBuffers = [];
      if (this.$main) {
        this.initGL();
        if (this.gl) {
          this.initCanvas();
          this.initBuffers();
        }
      }
    }

    Main.prototype.initGL = function() {
      var ctx, j, len, ref;
      try {
        ref = ['webgl', 'experimental-webgl'];
        for (j = 0, len = ref.length; j < len; j++) {
          ctx = ref[j];
          ª(ctx);
          this.gl = this.$main.getContext(ctx, {
            preserveDrawingBuffer: true
          });
          if (this.gl) {
            break;
          }
        }
      } catch (_error) {

      }
      if (!this.gl) {
        throw Error("Unable to initialize WebGL. Your browser may not support it.");
      }
    };

    Main.prototype.initCanvas = function() {
      this.gl.clearColor(this.bkgndR, this.bkgndG, this.bkgndB, this.bkgndA);
      this.gl.enable(this.gl.DEPTH_TEST);
      this.gl.enable(this.gl.SCISSOR_TEST);
      this.gl.depthFunc(this.gl.LEQUAL);
      this.gl.scissor(0, 0, this.$main.width, this.$main.height);
      this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
      return this.gl.enable(this.gl.VERTEX_PROGRAM_POINT_SIZE);
    };

    Main.prototype.initBuffers = function() {
      this.addPositionBuffer([]);
      return this.addColorBuffer([]);
    };

    Main.prototype.cleanUp = function() {};

    Main.prototype.addItem = function(config) {
      var index;
      index = this.items.length;
      this.items[index] = new Item(this, index, config);
      return index;
    };

    Main.prototype.addCamera = function(config) {
      var index;
      index = this.cameras.length;
      this.cameras[index] = new Camera(this, config);
      ª(index);
      return index;
    };

    Main.prototype.addProgram = function(config) {
      var index;
      if (ªO !== ªtype(config)) {
        throw TypeError("`config` must be object not " + (ªtype(config)));
      }
      if (ªS !== ªtype(config.subclass)) {
        throw TypeError("`config.subclass` must be string not " + (ªtype(config.subclass)));
      }
      if (!Program[config.subclass]) {
        throw RangeError("`Program." + config.subclass + "` does not exist");
      }
      index = this.programs.length;
      this.programs[index] = new Program[config.subclass](this, config);
      return index;
    };

    Main.prototype.addRenderer = function(config) {
      var index;
      index = this.renderers.length;
      this.renderers[index] = new Renderer(this, config);
      return index;
    };

    Main.prototype.addLayer = function(config) {
      var index;
      index = this.layers.length;
      this.layers[index] = new Layer(this, config);
      return index;
    };

    Main.prototype.addPositionBuffer = function(positions) {
      var index;
      index = this.positionBuffers.length;
      if (ªA !== ªtype(positions)) {
        throw Error("`positions` must be an array not " + (ªtype(positions)));
      } else if (positions.length % 3) {
        throw Error("`positions.length` must be divisible by 3");
      }
      this.positionBuffers[index] = this.gl.createBuffer();
      this.positionBuffers[index].count = positions.length / 3;
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffers[index]);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(positions), this.gl.STATIC_DRAW);
      return index;
    };

    Main.prototype.addColorBuffer = function(colors) {
      var index;
      index = this.colorBuffers.length;
      if (ªA !== ªtype(colors)) {
        throw Error("`colors` must be an array not " + (ªtype(colors)));
      } else if (colors.length % 4) {
        throw Error("`colors.length` must be divisible by 4");
      }
      this.colorBuffers[index] = this.gl.createBuffer();
      this.colorBuffers[index].count = colors.length / 4;
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffers[index]);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(colors), this.gl.STATIC_DRAW);
      return index;
    };

    Main.prototype.rotate = function(x, y, z, targetIndex) {
      var c, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, mat, s, target, x0, y0, z0;
      target = this.items[targetIndex] || this.cameras[0];
      mat = target.matTransform;
      x0 = 0 === x;
      y0 = 0 === y;
      z0 = 0 === z;
      if (x0 && y0 && z0) {
        return this;
      } else if (y0 && z0) {
        s = Math.sin(x);
        c = Math.cos(x);
        m10 = mat[4];
        m11 = mat[5];
        m12 = mat[6];
        m13 = mat[7];
        m20 = mat[8];
        m21 = mat[9];
        m22 = mat[10];
        m23 = mat[11];
        mat[4] = m10 * c + m20 * s;
        mat[5] = m11 * c + m21 * s;
        mat[6] = m12 * c + m22 * s;
        mat[7] = m13 * c + m23 * s;
        mat[8] = m20 * c - m10 * s;
        mat[9] = m21 * c - m11 * s;
        mat[10] = m22 * c - m12 * s;
        mat[11] = m23 * c - m13 * s;
        target.rX += x;
      } else if (x0 && z0) {
        s = Math.sin(y);
        c = Math.cos(y);
        m00 = mat[0];
        m01 = mat[1];
        m02 = mat[2];
        m03 = mat[3];
        m20 = mat[8];
        m21 = mat[9];
        m22 = mat[10];
        m23 = mat[11];
        mat[0] = m00 * c - m20 * s;
        mat[1] = m01 * c - m21 * s;
        mat[2] = m02 * c - m22 * s;
        mat[3] = m03 * c - m23 * s;
        mat[8] = m00 * s + m20 * c;
        mat[9] = m01 * s + m21 * c;
        mat[10] = m02 * s + m22 * c;
        mat[11] = m03 * s + m23 * c;
        target.rY += y;
      } else if (x0 && y0) {
        s = Math.sin(z);
        c = Math.cos(z);
        m00 = mat[0];
        m01 = mat[1];
        m02 = mat[2];
        m03 = mat[3];
        m10 = mat[4];
        m11 = mat[5];
        m12 = mat[6];
        m13 = mat[7];
        mat[0] = m00 * c + m10 * s;
        mat[1] = m01 * c + m11 * s;
        mat[2] = m02 * c + m12 * s;
        mat[3] = m03 * c + m13 * s;
        mat[4] = m10 * c - m00 * s;
        mat[5] = m11 * c - m01 * s;
        mat[6] = m12 * c - m02 * s;
        mat[7] = m13 * c - m03 * s;
        target.rZ += z;
      } else {
        this.rotate(x, 0, 0, targetIndex);
        this.rotate(0, y, 0, targetIndex);
        this.rotate(0, 0, z, targetIndex);
      }
      if (target === this.cameras[0]) {
        this.cameras[0].updateCamera();
      }
      return this;
    };

    Main.prototype.scale = function(x, y, z, targetIndex) {
      var mat, target, x1, y1, z1;
      target = this.items[targetIndex] || this.cameras[0];
      mat = target.matTransform;
      x1 = 1 === x;
      y1 = 1 === y;
      z1 = 1 === z;
      if (!x1) {
        mat[0] *= x;
        mat[1] *= x;
        mat[2] *= x;
        mat[3] *= x;
        target.sX *= x;
      }
      if (!y1) {
        mat[4] *= y;
        mat[5] *= y;
        mat[6] *= y;
        mat[7] *= y;
        target.sY *= y;
      }
      if (!z1) {
        mat[8] *= z;
        mat[9] *= z;
        mat[10] *= z;
        mat[11] *= z;
        target.sZ *= z;
      }
      if (target === this.cameras[0]) {
        this.cameras[0].updateCamera();
      }
      return this;
    };

    Main.prototype.translate = function(x, y, z, targetIndex) {
      var mat, target, x0, y0, z0;
      target = this.items[targetIndex] || this.cameras[0];
      mat = target.matTransform;
      x0 = 0 === x;
      y0 = 0 === y;
      z0 = 0 === z;
      if (x0 && y0 && z0) {
        return this;
      } else if (y0 && z0) {
        mat[12] += mat[0] * x;
        mat[13] += mat[1] * x;
        mat[14] += mat[2] * x;
        mat[15] += mat[3] * x;
        target.tX += x;
      } else if (x0 && z0) {
        mat[12] += mat[4] * y;
        mat[13] += mat[5] * y;
        mat[14] += mat[6] * y;
        mat[15] += mat[7] * y;
        target.tY += y;
      } else if (x0 && y0) {
        mat[12] += mat[8] * z;
        mat[13] += mat[9] * z;
        mat[14] += mat[10] * z;
        mat[15] += mat[11] * z;
        target.tZ += z;
      } else {
        mat[12] += mat[0] * x + mat[4] * y + mat[8] * z;
        mat[13] += mat[1] * x + mat[5] * y + mat[9] * z;
        mat[14] += mat[2] * x + mat[6] * y + mat[10] * z;
        mat[15] += mat[3] * x + mat[7] * y + mat[11] * z;
        target.tX += x;
        target.tY += y;
        target.tZ += z;
      }
      if (target === this.cameras[0]) {
        this.cameras[0].updateCamera();
      }
      return this;
    };

    Main.prototype.setRenderMode = function(renderMode, targetIndex) {
      this.items[targetIndex].renderMode = renderMode;
      return this;
    };

    Main.prototype.getColorAt = function(x, y) {
      var pixels;
      pixels = new Uint8Array(4);
      this.gl.readPixels(x, y, 1, 1, this.gl.RGBA, this.gl.UNSIGNED_BYTE, pixels);
      return pixels;
    };

    Main.prototype.getItemIByColor = function(color) {
      return pick.colorToIndex(color);
    };

    Main.prototype.getItemSnapshot = function(itemI) {
      var item, mat;
      item = this.items[itemI];
      mat = new Float32Array(16);
      mat.set(item.matTransform);
      return {
        mat: mat,
        rX: item.rX,
        rY: item.rY,
        rZ: item.rZ,
        sX: item.sX,
        sY: item.sY,
        sZ: item.sZ,
        tX: item.tX,
        tY: item.tY,
        tZ: item.tZ
      };
    };

    Main.prototype.setItemSnapshot = function(snapshot, itemI) {
      var item;
      item = this.items[itemI];
      item.matTransform = new Float32Array(16);
      item.matTransform.set(snapshot.mat);
      item.rX = snapshot.rX;
      item.rY = snapshot.rY;
      item.rZ = snapshot.rZ;
      item.sX = snapshot.sX;
      item.sY = snapshot.sY;
      item.sZ = snapshot.sZ;
      item.tX = snapshot.tX;
      item.tY = snapshot.tY;
      item.tZ = snapshot.tZ;
      return this;
    };

    Main.prototype.render = function() {
      var j, layer, len, ref;
      if (!this.gl) {
        throw Error("The WebGL rendering context is " + (ªtype(this.gl)));
      }
      this.gl.clearColor(this.bkgndR, this.bkgndG, this.bkgndB, this.bkgndA);
      this.gl.scissor(0, 0, this.$main.width, this.$main.height);
      this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
      ref = this.layers;
      for (j = 0, len = ref.length; j < len; j++) {
        layer = ref[j];
        layer.render();
      }
      return this;
    };

    return Main;

  })();

  if (ªF === typeof define && define.amd) {
    define(function() {
      return Main;
    });
  } else if (ªO === typeof module && module && module.exports) {
    module.exports = Main;
  } else {
    ªW[ªC] = Main;
  }

  mat4 = {};

  mat4.multiply = function(a, b) {
    var a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23, a30, a31, a32, a33, b0, b1, b2, b3, out;
    out = new Float32Array(16);
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    a30 = a[12];
    a31 = a[13];
    a32 = a[14];
    a33 = a[15];
    b0 = b[0];
    b1 = b[1];
    b2 = b[2];
    b3 = b[3];
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return out;
  };

  mat4.perspective = function(fovy, aspect, near, far) {
    var f, nf, out;
    f = 1.0 / Math.tan(fovy / 2);
    nf = 1 / (near - far);
    out = new Float32Array(16);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (2 * far * near) * nf;
    out[15] = 0;
    return out;
  };

  mat4.rotateX = function(a, rad) {
    var a10, a11, a12, a13, a20, a21, a22, a23, c, s;
    s = Math.sin(rad);
    c = Math.cos(rad);
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    a[4] = a10 * c + a20 * s;
    a[5] = a11 * c + a21 * s;
    a[6] = a12 * c + a22 * s;
    a[7] = a13 * c + a23 * s;
    a[8] = a20 * c - a10 * s;
    a[9] = a21 * c - a11 * s;
    a[10] = a22 * c - a12 * s;
    a[11] = a23 * c - a13 * s;
    return a;
  };

  mat4.rotateY = function(a, rad) {
    var a00, a01, a02, a03, a20, a21, a22, a23, c, s;
    s = Math.sin(rad);
    c = Math.cos(rad);
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    a[0] = a00 * c - a20 * s;
    a[1] = a01 * c - a21 * s;
    a[2] = a02 * c - a22 * s;
    a[3] = a03 * c - a23 * s;
    a[8] = a00 * s + a20 * c;
    a[9] = a01 * s + a21 * c;
    a[10] = a02 * s + a22 * c;
    a[11] = a03 * s + a23 * c;
    return a;
  };

  mat4.rotateZ = function(a, rad) {
    var a00, a01, a02, a03, a10, a11, a12, a13, c, s;
    s = Math.sin(rad);
    c = Math.cos(rad);
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a[0] = a00 * c + a10 * s;
    a[1] = a01 * c + a11 * s;
    a[2] = a02 * c + a12 * s;
    a[3] = a03 * c + a13 * s;
    a[4] = a10 * c - a00 * s;
    a[5] = a11 * c - a01 * s;
    a[6] = a12 * c - a02 * s;
    a[7] = a13 * c - a03 * s;
    return a;
  };

  mat4.translate = function(a, x, y, z) {
    a[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    a[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    a[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    a[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    return a;
  };

  mat4.ortho = function(left, right, bottom, top, near, far) {
    var bt, lr, nf, out;
    lr = 1 / (left - right);
    bt = 1 / (bottom - top);
    nf = 1 / (near - far);
    out = new Float32Array(16);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
  };

  mat4.makeTranslation = function(tx, ty, tz) {
    return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, tz, 1]);
  };

  mat4.makeXRotation = function(angleInRadians) {
    var c, s;
    c = Math.cos(angleInRadians);
    s = Math.sin(angleInRadians);
    return new Float32Array([1, 0, 0, 0, 0, c, s, 0, 0, -s, c, 0, 0, 0, 0, 1]);
  };

  mat4.makeYRotation = function(angleInRadians) {
    var c, s;
    c = Math.cos(angleInRadians);
    s = Math.sin(angleInRadians);
    return new Float32Array([c, 0, -s, 0, 0, 1, 0, 0, s, 0, c, 0, 0, 0, 0, 1]);
  };

  mat4.makeZRotation = function(angleInRadians) {
    var c, s;
    c = Math.cos(angleInRadians);
    s = Math.sin(angleInRadians);
    return new Float32Array([c, s, 0, 0, -s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
  };

  mat4.makeScale = function(sx, sy, sz) {
    return new Float32Array([sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1]);
  };

  mat4.makeProjection = function(width, height, depth) {
    return new Float32Array([2 / width, 0, 0, 0, 0, -2 / height, 0, 0, 0, 0, 2 / depth, 0, -1, 1, 0, 1]);
  };

  pick = {};

  pick.indexToColor = function(index) {
    var b, g, i, r;
    i = ('00000000000000000000000' + index.toString(2)).slice(-24).split('');
    r = "" + i[23] + i[20] + i[17] + i[14] + i[11] + i[8] + i[5] + i[2];
    g = "" + i[22] + i[19] + i[16] + i[13] + i[10] + i[7] + i[4] + i[1];
    b = "" + i[21] + i[18] + i[15] + i[12] + i[9] + i[6] + i[3] + i[0];
    return new Float32Array([parseInt(r, 2) / 255, parseInt(g, 2) / 255, parseInt(b, 2) / 255, 1.0]);
  };

  pick.colorToIndex = function(color) {
    var b, g, i, r;
    if (0 === (0x1f & color[0]) + (0x1f & color[1]) + (0x1f & color[2])) {
      return pick.qikColorToIndex(color);
    }
    r = ('0000000' + color[0].toString(2)).slice(-8).split('');
    g = ('0000000' + color[1].toString(2)).slice(-8).split('');
    b = ('0000000' + color[2].toString(2)).slice(-8).split('');
    i = ("" + b[7] + g[7] + r[7]) + ("" + b[6] + g[6] + r[6]) + ("" + b[5] + g[5] + r[5]) + ("" + b[4] + g[4] + r[4]) + ("" + b[3] + g[3] + r[3]) + ("" + b[2] + g[2] + r[2]) + ("" + b[1] + g[1] + r[1]) + ("" + b[0] + g[0] + r[0]);
    return parseInt(i, 2);
  };

  pick.qikColorToIndex = function(color) {
    var b, g, i, r;
    r = (color[0].toString(2)).split('');
    g = (color[1].toString(2)).split('');
    b = (color[2].toString(2)).split('');
    i = ("" + (b[2] || 0) + (g[2] || 0) + (r[2] || 0)) + ("" + (b[1] || 0) + (g[1] || 0) + (r[1] || 0)) + ("" + b[0] + g[0] + r[0]);
    return parseInt(i, 2);
  };

  uri = {};

  uri.r2Tenmin = function(r) {
    return Math.round(r * uri.RESOLUTION_R);
  };

  uri.tenmin2r = function(r) {
    return r / uri.RESOLUTION_R;
  };

  uri.r2uri = function(radians) {
    var PI2, c1, c1i, c2, c2i, tenmin;
    PI2 = Math.PI * 2;
    radians = radians % PI2;
    if (0 > radians) {
      radians += PI2;
    }
    tenmin = uri.r2Tenmin(radians);
    c1 = uri.USUAL_R2URI[tenmin];
    if (c1) {
      return c1;
    }
    c1i = tenmin % 36;
    c2i = (tenmin - c1i) / 36;
    c1 = "0123456789abcdefghijklmnopqrstuvwxyz"[c1i];
    c2 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWX"[c2i];
    return '' + c1 + c2;
  };

  uri.s2uri = function(s) {
    var c1, c2, c3, m, n, nM64, neg;
    if (0 > s) {
      neg = true;
      s = Math.abs(s);
    }
    if (0.0001 > s) {
      return 'A';
    }
    if (0.001 > s) {
      m = neg ? 'a' : 'p';
      n = s * 10000000;
    } else if (0.01 > s) {
      m = neg ? 'b' : 'o';
      n = s * 1000000;
    } else if (0.1 > s) {
      m = neg ? 'c' : 'n';
      n = s * 100000;
    } else if (1 > s) {
      m = neg ? 'd' : 'm';
      n = s * 10000;
    } else if (10 > s) {
      m = neg ? 'e' : 'l';
      n = s * 1000;
    } else if (100 > s) {
      m = neg ? 'f' : 'k';
      n = s * 100;
    } else if (1000 > s) {
      m = neg ? 'g' : 'j';
      n = s * 10;
    } else if (10000 > s) {
      m = neg ? 'h' : 'i';
      n = s;
    } else {
      return 'Z';
    }
    n = Math.floor(n);
    c1 = uri.USUAL_S2URI[m + n];
    if (c1) {
      return c1;
    }
    nM64 = n % 64;
    c1 = m;
    c2 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-"[nM64];
    c3 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-"[(n - nM64) / 64];
    return c1 + c2 + c3;
  };

  uri.t2uri = function(t) {
    var c1, c2, c3, m, n, nM64, neg;
    if (0 > t) {
      neg = true;
      t = Math.abs(t);
    }
    if (0.0001 > t) {
      return 'A';
    }
    if (0.001 > t) {
      m = neg ? 'a' : 'p';
      n = t * 10000000;
    } else if (0.01 > t) {
      m = neg ? 'b' : 'o';
      n = t * 1000000;
    } else if (0.1 > t) {
      m = neg ? 'c' : 'n';
      n = t * 100000;
    } else if (1 > t) {
      m = neg ? 'd' : 'm';
      n = t * 10000;
    } else if (10 > t) {
      m = neg ? 'e' : 'l';
      n = t * 1000;
    } else if (100 > t) {
      m = neg ? 'f' : 'k';
      n = t * 100;
    } else if (1000 > t) {
      m = neg ? 'g' : 'j';
      n = t * 10;
    } else if (10000 > t) {
      m = neg ? 'h' : 'i';
      n = t;
    } else {
      return 'Z';
    }
    n = Math.floor(n);
    c1 = uri.USUAL_T2URI[m + n];
    if (c1) {
      return c1;
    }
    nM64 = n % 64;
    c1 = m;
    c2 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-"[nM64];
    c3 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-"[(n - nM64) / 64];
    return c1 + c2 + c3;
  };

  uri.uri2r = function(str) {
    var c1, c2, usual;
    usual = uri.USUAL_URI2R[str];
    if (ªN === typeof usual) {
      return uri.tenmin2r(usual);
    }
    c1 = uri.B64DECODE[str[0]];
    c2 = uri.B64DECODE[str[1]];
    return uri.tenmin2r(c1 * 60 + c2);
  };

  uri.uri2s = function(str) {
    var c1, c2, c3, usual;
    usual = uri.USUAL_URI2S[str];
    if (ªN === typeof usual) {
      return usual;
    }
    c1 = uri.MULTIPLIER[str[0]];
    c2 = uri.B64DECODE[str[1]];
    c3 = uri.B64DECODE[str[2]];
    return c1 * (c2 + c3 * 64);
  };

  uri.uri2t = function(str) {
    var c1, c2, c3, usual;
    usual = uri.USUAL_URI2T[str];
    if (ªN === typeof usual) {
      return usual;
    }
    c1 = uri.MULTIPLIER[str[0]];
    c2 = uri.B64DECODE[str[1]];
    c3 = uri.B64DECODE[str[2]];
    return c1 * (c2 + c3 * 64);
  };

  uri.RESOLUTION_R = 1 / (Math.PI * 2 / 36 / 60);

  uri.USUAL_R2URI = (function() {
    var PI, out;
    PI = Math.PI;
    out = {};
    out[0] = 'A';
    out[uri.r2Tenmin(PI / 6.0)] = 'B';
    out[uri.r2Tenmin(PI / 4.0)] = 'C';
    out[uri.r2Tenmin(PI / 3.0)] = 'D';
    out[uri.r2Tenmin(PI * 0.5)] = 'E';
    out[uri.r2Tenmin(PI / 1.5)] = 'F';
    out[uri.r2Tenmin(PI * 0.75)] = 'G';
    out[uri.r2Tenmin(PI / 1.2)] = 'H';
    out[uri.r2Tenmin(PI)] = 'I';
    out[uri.r2Tenmin(PI / 6.0 + PI)] = 'J';
    out[uri.r2Tenmin(PI / 4.0 + PI)] = 'K';
    out[uri.r2Tenmin(PI / 3.0 + PI)] = 'L';
    out[uri.r2Tenmin(PI * 1.5)] = 'M';
    out[uri.r2Tenmin(PI / 1.5 + PI)] = 'N';
    out[uri.r2Tenmin(PI * 1.75)] = 'O';
    out[uri.r2Tenmin(PI / 1.2 + PI)] = 'P';
    out[uri.r2Tenmin(PI * 2.0)] = 'Q';
    return out;
  })();

  uri.USUAL_URI2R = (function() {
    var key, out, ref, val;
    out = {};
    ref = uri.USUAL_R2URI;
    for (key in ref) {
      val = ref[key];
      out[val] = +key;
    }
    return out;
  })();

  uri.USUAL_S2URI = {
    d1250: 'C',
    d2500: 'D',
    d5000: 'E',
    e1000: 'F',
    e2000: 'G',
    e4000: 'H',
    e8000: 'I',
    m1250: 'R',
    m2500: 'S',
    m5000: 'T',
    l1000: 'U',
    l2000: 'V',
    l4000: 'W',
    l8000: 'X'
  };

  uri.USUAL_URI2S = {
    A: 0,
    C: -0.125,
    D: -0.25,
    E: -0.5,
    F: -1,
    G: -2,
    H: -4,
    I: -8,
    R: 0.125,
    S: 0.25,
    T: 0.5,
    U: 1,
    V: 2,
    W: 4,
    X: 8,
    Z: 10000
  };

  uri.USUAL_T2URI = {
    d1250: 'C',
    d2500: 'D',
    d5000: 'E',
    e1000: 'F',
    e2000: 'G',
    e4000: 'H',
    e8000: 'I',
    m1250: 'R',
    m2500: 'S',
    m5000: 'T',
    l1000: 'U',
    l2000: 'V',
    l4000: 'W',
    l8000: 'X'
  };

  uri.USUAL_URI2T = {
    A: 0,
    C: -0.125,
    D: -0.25,
    E: -0.5,
    F: -1,
    G: -2,
    H: -4,
    I: -8,
    R: 0.125,
    S: 0.25,
    T: 0.5,
    U: 1,
    V: 2,
    W: 4,
    X: 8,
    Z: 10000
  };

  uri.MULTIPLIER = {
    a: -1 / 10000000,
    b: -1 / 1000000,
    c: -1 / 100000,
    d: -1 / 10000,
    e: -1 / 1000,
    f: -1 / 100,
    g: -1 / 10,
    h: -1,
    p: 1 / 10000000,
    o: 1 / 1000000,
    n: 1 / 100000,
    m: 1 / 10000,
    l: 1 / 1000,
    k: 1 / 100,
    j: 1 / 10,
    i: 1
  };

  uri.B64DECODE = (function() {
    var b64, i, j, out;
    out = {};
    b64 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-";
    for (i = j = 0; j <= 63; i = ++j) {
      out[b64[i]] = i;
    }
    return out;
  })();

  Program = (function() {
    Program.prototype.C = 'Program';

    Program.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function Program(main1, config) {
      var gl;
      this.main = main1;
      if (config == null) {
        config = {};
      }
      if (ªO !== ªtype(config)) {
        throw TypeError("`config` must be object not " + (ªtype(config)));
      }
      if (ªO !== ªtype(this.main)) {
        throw TypeError("`main` must be object not " + (ªtype(this.main)));
      }
      if ('[object Oo3d]' !== '' + this.main) {
        throw TypeError("`main` must be [object Oo3d] not " + this.main);
      }
      gl = this.main.gl;
      this.vertexShader = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(this.vertexShader, this.vertexSource());
      gl.compileShader(this.vertexShader);
      if (!gl.getShaderParameter(this.vertexShader, gl.COMPILE_STATUS)) {
        this.cleanUp();
        throw Error(this.C + ".vertexShader failed to compile");
      }
      this.fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(this.fragmentShader, this.fragmentSource());
      gl.compileShader(this.fragmentShader);
      if (!gl.getShaderParameter(this.fragmentShader, gl.COMPILE_STATUS)) {
        this.cleanUp();
        throw Error(this.C + ".fragmentShader failed to compile");
      }
      this.program = gl.createProgram();
      gl.attachShader(this.program, this.vertexShader);
      gl.attachShader(this.program, this.fragmentShader);
      gl.linkProgram(this.program);
      if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
        this.cleanUp();
        throw Error(this.C + ".program failed to link");
      }
    }

    Program.prototype.cleanUp = function() {
      if (this.vertexShader) {
        this.main.gl.deleteShader(this.vertexShader);
      }
      if (this.fragmentShader) {
        this.main.gl.deleteShader(this.fragmentShader);
      }
      if (this.program) {
        return this.main.gl.deleteProgram(this.program);
      }
    };

    Program.prototype.vertexSource = function() {
      return "void main() {\n}";
    };

    Program.prototype.fragmentSource = function() {
      return "void main() {\n}";
    };

    return Program;

  })();

  Program.Flat = (function(superClass) {
    extend(Flat, superClass);

    Flat.prototype.C = 'Program.Flat';

    Flat.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function Flat(main, config) {
      var gl;
      if (config == null) {
        config = {};
      }
      Flat.__super__.constructor.call(this, main, config);
      gl = this.main.gl;
      gl.useProgram(this.program);
      this.aVtxPositionLoc = gl.getAttribLocation(this.program, 'aVtxPosition');
      gl.enableVertexAttribArray(this.aVtxPositionLoc);
      this.aVtxColorLoc = gl.getAttribLocation(this.program, 'aVtxColor');
      this.uMatTransformLoc = gl.getUniformLocation(this.program, 'uMatTransform');
      this.uMatCameraLoc = gl.getUniformLocation(this.program, 'uMatCamera');
    }

    Flat.prototype.vertexSource = function() {
      return "attribute vec3 aVtxPosition;\nattribute vec4 aVtxColor;\n\nuniform mat4 uMatTransform;\nuniform mat4 uMatCamera;\n\nvarying vec4 vColor; // declare `vColor`\n\nvoid main() {\n\n  //// Increase the size of gl.POINT from 1px to 4px. \n  gl_PointSize = 4.0;\n\n  //// Apply the Camera and Item transforms to each vertex position. \n  //// Note that the order of these three is important. \n  gl_Position = uMatCamera * uMatTransform * vec4(aVtxPosition, 1);\n\n  //// Pass the vertex-color attribute unchanged to the fragment-shader. \n  vColor = aVtxColor;\n}";
    };

    Flat.prototype.fragmentSource = function() {
      return "precision mediump float; // boilerplate for mobile-friendly shaders\n\nvarying vec4 vColor; // linear-interpolated input from fragment-shader\n\nvoid main(void) {\n  gl_FragColor = vColor;\n}";
    };

    return Flat;

  })(Program);

  Program.FlatItem = (function(superClass) {
    extend(FlatItem, superClass);

    FlatItem.prototype.C = 'Program.FlatItem';

    FlatItem.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function FlatItem(main, config) {
      var gl;
      if (config == null) {
        config = {};
      }
      FlatItem.__super__.constructor.call(this, main, config);
      gl = this.main.gl;
      gl.useProgram(this.program);
      this.aVtxPositionLoc = gl.getAttribLocation(this.program, 'aVtxPosition');
      gl.enableVertexAttribArray(this.aVtxPositionLoc);
      this.uMatTransformLoc = gl.getUniformLocation(this.program, 'uMatTransform');
      this.uMatCameraLoc = gl.getUniformLocation(this.program, 'uMatCamera');
      this.uItemColorLoc = gl.getUniformLocation(this.program, 'uItemColor');
    }

    FlatItem.prototype.vertexSource = function() {
      return "attribute vec3 aVtxPosition;\n\nuniform mat4 uMatTransform;\nuniform mat4 uMatCamera;\n\nuniform vec4 uItemColor; // the Item renders as a single flat color\n\n\nvarying vec4 vColor; // declare `vColor`\n\nvoid main() {\n\n  //// Multiply the position by the camera transformation and matrices. \n  //// Note that the order of these three is important. \n  gl_Position = uMatCamera * uMatTransform * vec4(aVtxPosition, 1);\n\n  //// Pass the vertex-color attribute unchanged to the fragment-shader. \n  vColor = uItemColor;\n\n}";
    };

    FlatItem.prototype.fragmentSource = function() {
      return "precision mediump float; // boilerplate for mobile-friendly shaders\n\nvarying vec4 vColor; // linear-interpolated input from fragment-shader\n\nvoid main() {\n  gl_FragColor = vColor;\n}";
    };

    return FlatItem;

  })(Program);

  Program.Flatwhite = (function(superClass) {
    extend(Flatwhite, superClass);

    Flatwhite.prototype.C = 'Program.Flatwhite';

    Flatwhite.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function Flatwhite(main, config) {
      var gl;
      if (config == null) {
        config = {};
      }
      Flatwhite.__super__.constructor.call(this, main, config);
      gl = this.main.gl;
      gl.useProgram(this.program);
      this.aVtxPositionLoc = gl.getAttribLocation(this.program, 'aVtxPosition');
      gl.enableVertexAttribArray(this.aVtxPositionLoc);
      this.uMatTransformLoc = gl.getUniformLocation(this.program, 'uMatTransform');
      this.uMatCameraLoc = gl.getUniformLocation(this.program, 'uMatCamera');
    }

    Flatwhite.prototype.vertexSource = function() {
      return "attribute vec3 aVtxPosition;\n\nuniform mat4 uMatTransform;\nuniform mat4 uMatCamera;\n\nvoid main() {\n\n  //// Multiply the position by the camera transformation and matrices. \n  //// Note that the order of these three is important. \n  gl_Position = uMatCamera * uMatTransform * vec4(aVtxPosition, 1);\n\n}";
    };

    Flatwhite.prototype.fragmentSource = function() {
      return "precision mediump float; // boilerplate for mobile-friendly shaders\n\nvec4 white = vec4(1.0,1.0,1.0,1.0);\n\nvoid main() {\n  gl_FragColor = white;\n}";
    };

    return Flatwhite;

  })(Program);

  Renderer = (function() {
    var RendererTypeError;

    Renderer.prototype.C = 'Renderer';

    Renderer.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function Renderer(main1, config) {
      var i;
      this.main = main1;
      if (config == null) {
        config = {};
      }
      if (ªO !== ªtype(config)) {
        throw TypeError("`config` must be object not " + (ªtype(config)));
      }
      if (ªO !== ªtype(this.main)) {
        throw TypeError("`main` must be object not " + (ªtype(this.main)));
      }
      if ('[object Oo3d]' !== '' + this.main) {
        throw TypeError("`main` must be [object Oo3d] not " + this.main);
      }
      if (ªN !== ªtype(config.programI)) {
        throw TypeError("config.programI must be number not " + (ªtype(config.programI)));
      }
      this.program = this.main.programs[config.programI] || (function() {
        throw RangeError("No such index " + config.programI + " in main.programs");
      })();
      if (ªN !== ªtype(config.cameraI)) {
        throw TypeError("config.cameraI must be number not " + (ªtype(config.cameraI)));
      }
      this.camera = this.main.cameras[config.cameraI] || (function() {
        throw RangeError("No such index " + config.cameraI + " in main.cameras");
      })();
      this.uMatCameraLoc = this.main.gl.getUniformLocation(this.program.program, 'uMatCamera');
      if (!config.itemIs) {
        this.items = [];
      } else if ('uint16array' !== ªtype(config.itemIs)) {
        throw TypeError("If set, config.itemIs must be Uint16Array not " + (ªtype(config.itemIs)));
      } else {
        this.items = (function() {
          var j, len, ref, results;
          ref = config.itemIs;
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            i = ref[j];
            results.push(this.main.items[i] || (function() {
              throw RangeError("No such index " + i + " in main.items");
            })());
          }
          return results;
        }).call(this);
      }
    }

    Renderer.prototype.render = function() {
      var $main, aVtxColorLoc, aVtxPositionLoc, gl, index, item, main, mode, uItemColorLoc, uMatTransformLoc;
      main = this.main;
      $main = main.$main;
      gl = main.gl;
      aVtxPositionLoc = this.program.aVtxPositionLoc;
      aVtxColorLoc = this.program.aVtxColorLoc || false;
      uMatTransformLoc = this.program.uMatTransformLoc;
      uItemColorLoc = this.program.uItemColorLoc;
      if (!gl) {
        throw Error("The WebGL rendering context is " + (ªtype(gl)));
      }
      gl.useProgram(this.program.program);
      gl.uniformMatrix4fv(this.uMatCameraLoc, false, this.camera.matCamera);
      if (aVtxColorLoc) {
        gl.enableVertexAttribArray(aVtxColorLoc);
      }
      index = this.items.length;
      while (index--) {
        item = this.items[index];
        gl.uniformMatrix4fv(uMatTransformLoc, gl.FALSE, item.matTransform);
        if (uItemColorLoc) {
          gl.uniform4fv(uItemColorLoc, item.color);
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, item.positionBuffer);
        gl.vertexAttribPointer(aVtxPositionLoc, 3, gl.FLOAT, false, 0, 0);
        if (aVtxColorLoc) {
          gl.bindBuffer(gl.ARRAY_BUFFER, item.colorBuffer);
          gl.vertexAttribPointer(aVtxColorLoc, 4, gl.FLOAT, false, 0, 0);
        }
        if (null !== item.sBlend) {
          gl.enable(gl.BLEND);
          gl.blendFunc(item.sBlend, item.dBlend);
        } else {
          gl.disable(gl.BLEND);
        }
        mode = gl[item.renderMode];
        gl.drawArrays(mode, 0, item.count);
        gl.flush();
      }
      if (aVtxColorLoc) {
        return gl.disableVertexAttribArray(aVtxColorLoc);
      }
    };

    RendererTypeError = (function(superClass) {
      extend(RendererTypeError, superClass);

      function RendererTypeError(message) {
        this.message = "Renderer " + message;
        this.name = this.constructor.name;
      }

      RendererTypeError.prototype = new Error();

      RendererTypeError.prototype.constructor = RendererTypeError;

      return RendererTypeError;

    })(TypeError);

    return Renderer;

  })();

  Renderer.Wireframe = (function(superClass) {
    extend(Wireframe, superClass);

    Wireframe.prototype.C = 'Renderer.Wireframe';

    function Wireframe(main, config) {
      if (config == null) {
        config = {};
      }
      Wireframe.__super__.constructor.call(this, main, config);
    }

    return Wireframe;

  })(Renderer);

}).call(this);
